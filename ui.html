<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCubee Video Search System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" as="style">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Bangers&family=Oswald:wght@400;500&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        #cursedDomainVideo {
            position: fixed;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translateX(-50%) translateY(-50%);
            z-index: -2; /* Nằm dưới cả canvas */
            display: none; /* Mặc định ẩn đi */
        }
        #digitalRainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Luôn nằm dưới cùng */
            display: none; /* Mặc định ẩn đi */
        }
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-bg: #0a0e1a;
            --card-bg: rgba(20, 25, 40, 0.6);
            --border-color: rgba(255, 255, 255, 0.15);
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --accent-blue: #4facfe;
            --accent-purple: #667eea;
            --accent-pink: #f093fb;
            --glass-bg: rgba(255, 255, 255, 0.08);
            --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.25);
            --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.45);
            --radius: 16px;
        }
        body.theme-cyberpunk-neon {
            --primary-gradient: linear-gradient(135deg, #00f2fe 0%, #f00c8b 100%);
            --secondary-gradient: linear-gradient(135deg, #7c4dff 0%, #00e5ff 100%);
            --dark-bg: #010114;
            --card-bg: rgba(10, 10, 30, 0.7);
            --border-color: rgba(0, 242, 254, 0.3);
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0c0;
            --accent-blue: #00f2fe;
            --accent-purple: #f00c8b;
            --glass-bg: rgba(0, 242, 254, 0.05);
            background-image:
                linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><g fill="%23f00c8b" fill-opacity="0.1"><rect x="0" y="0" width="100" height="1" /><rect x="0" y="0" width="1" height="100" /></g></svg>');
        }

        /* --- THEME #3: Cyberpunk 2077: Netrunner Glitch --- */
        @keyframes text-glitch { 2%,64%{transform:translate(2px,0) skew(0deg)} 4%,60%{transform:translate(-2px,0) skew(0deg)} 62%{transform:translate(0,0) skew(5deg)} }
        @keyframes border-glitch { 0% { clip-path: inset(89% 0 1% 0); } 10% { clip-path: inset(23% 0 34% 0); } 20% { clip-path: inset(55% 0 3% 0); } 30% { clip-path: inset(77% 0 13% 0); } 40% { clip-path: inset(12% 0 81% 0); } 50% { clip-path: inset(90% 0 1% 0); } 60% { clip-path: inset(30% 0 30% 0); } 70% { clip-path: inset(10% 0 80% 0); } 80% { clip-path: inset(50% 0 45% 0); } 90% { clip-path: inset(20% 0 70% 0); } 100% { clip-path: inset(89% 0 1% 0); } }
        body.theme-cyberpunk-glitch {
            --cp-yellow: #fcee0a; --cp-cyan: #00f2fe; --cp-magenta: #f00c8b; --cp-bg: #0a0a0f;
            --primary-gradient: linear-gradient(135deg, var(--cp-yellow) 0%, #ffc107 100%); --secondary-gradient: linear-gradient(135deg, var(--cp-cyan) 0%, #00a2ff 100%); --dark-bg: var(--cp-bg); --card-bg: rgba(10, 10, 15, 0.8); --border-color: rgba(252, 238, 10, 0.5); --text-primary: #E0E0E0; --text-secondary: #A0A0A0; --accent-blue: var(--cp-cyan); --accent-purple: var(--cp-magenta); font-family: 'Share Tech Mono', monospace;
            background-color: var(--dark-bg);
        }
        /* Đột phá: Viền Glitch động và hiệu ứng chữ nhiễu */
        body.theme-cyberpunk-glitch .stage-card, body.theme-cyberpunk-glitch .modal-content {
            position: relative; border: 1px solid var(--border-color);
        }
        body.theme-cyberpunk-glitch .stage-card::before, body.theme-cyberpunk-glitch .modal-content::before { /* Lớp viền glitch màu xanh */
            content:''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border: 1px solid var(--cp-cyan);
            animation: border-glitch 2s infinite linear;
            transform: translateX(-2px);
        }
        body.theme-cyberpunk-glitch .stage-card::after, body.theme-cyberpunk-glitch .modal-content::after { /* Lớp viền glitch màu hồng */
            content:''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border: 1px solid var(--cp-magenta);
            animation: border-glitch 2s infinite linear reverse;
            transform: translateX(2px);
        }
        body.theme-cyberpunk-glitch .app-title {
            color: var(--cp-yellow); /* Đổi màu chữ thành vàng neon */
            text-shadow: 0 0 10px var(--cp-yellow), 0 0 5px rgba(252, 238, 10, 0.7); /* Thêm hiệu ứng phát sáng */
        }
        /* Bỏ hiệu ứng mix-blend-mode không cần thiết chỉ cho theme này */
        body.theme-cyberpunk-glitch .app-title::before {
            content: none;
        }

        /* --- THEME ĐỘT PHÁ #2: Ghost in the Shell: Digital Rain --- */
        body.theme-gits-rain {
            --gits-green: #00FF41;
            --gits-bg: #000000;
            --primary-gradient: linear-gradient(135deg, var(--gits-green) 0%, #00c732 100%);
            --secondary-gradient: linear-gradient(135deg, #CCCCCC 0%, #FFFFFF 100%);
            --dark-bg: var(--gits-bg);
            --card-bg: rgba(5, 20, 10, 0.7);
            --border-color: rgba(0, 255, 65, 0.4);
            --text-primary: #EAEAEA;
            --text-secondary: #999999;
            --accent-blue: var(--gits-green);
            --accent-purple: #B0B0B0;
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--gits-bg);
            background-image: none; /* Nền sẽ do canvas xử lý */
        }
        body.theme-gits-rain .main-content-wrapper,
        body.theme-gits-rain .top-toolbar {
            background-color: transparent !important; /* Cho phép nhìn thấy mưa mã hóa */
        }
        body.theme-gits-rain .stage-card,
        body.theme-gits-rain .modal-content {
            backdrop-filter: blur(3px);
            border-radius: 0;
            border: 1px solid var(--border-color);
        }
        body.theme-gits-rain .fas, 
        body.theme-gits-rain .app-title,
        body.theme-gits-rain h3 {
            text-shadow: 0 0 8px var(--gits-green);
        }

        /* --- THEME ĐỘT PHÁ #3: Jujutsu Kaisen: Cursed Domain --- */
        body.theme-jujutsu-domain {
            --cursed-purple: #4B0082; --cursed-red: #8B0000; --cursed-bg: #0d021f;
            --primary-gradient: linear-gradient(135deg, var(--cursed-purple) 0%, #2e0854 100%); --secondary-gradient: linear-gradient(135deg, var(--cursed-red) 0%, #6b0000 100%); --dark-bg: var(--cursed-bg); --card-bg: rgba(13, 2, 31, 0.8); --border-color: rgba(75, 0, 130, 0.5); --text-primary: #D8BFD8; --text-secondary: #9370DB; --accent-blue: var(--cursed-purple); --accent-purple: var(--cursed-red); font-family: 'Poppins', sans-serif;
            background: transparent;
        }
        body.theme-jujutsu-domain::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 2, 31, 0.6);
            z-index: -1;
        }
        /* Giữ hiệu ứng "bẻ cong" cho các card chính và modal */
        body.theme-jujutsu-domain .stage-card, 
        body.theme-jujutsu-domain .modal-content {
            filter: url(#cursed-energy-wobble);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 15px 2px rgba(75, 0, 130, 0.4);
            backdrop-filter: blur(4px);
        }
        body.theme-jujutsu-domain .stage-card:hover {
            box-shadow: 0 0 25px 5px rgba(139, 0, 0, 0.6);
        }

        /* Đột phá: Bỏ hiệu ứng bẻ cong ở ảnh, thay bằng viền neon tím */
        body.theme-jujutsu-domain .result-item {
            border: 2px solid var(--border-color); /* Viền tím nền */
            border-radius: 6px;
            box-shadow: 0 0 10px 2px rgba(75, 0, 130, 0.7); /* Hào quang neon tím */
            transition: box-shadow 0.3s ease, transform 0.3s ease;
            /* BỎ filter: url(#cursed-energy-wobble); */
        }
        body.theme-jujutsu-domain .result-item:hover {
            transform: scale(1.05); /* Phóng to nhẹ khi hover */
            box-shadow: 0 0 20px 5px rgba(139, 0, 0, 0.8); /* Hào quang chuyển sang màu đỏ mạnh hơn */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        body {
            background: var(--dark-bg);
            background-image:
                radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 80% 80%, rgba(240, 147, 251, 0.2) 0%, transparent 60%);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .top-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(10, 14, 26, 0.7);
            backdrop-filter: blur(30px);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: var(--shadow-light);
            height: 76px;
        }
        .toolbar-left, .toolbar-right { display: flex; gap: 24px; align-items: center; }
        .app-title {
            font-size: 1.7rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .app-logo {
            height: 54px;
            width: 54px;
            border-radius: 0;
            object-fit: cover;
        }
        .model-btn-wrapper { position: relative; }
        .toolbar-btn {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 10px 18px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        .toolbar-btn .btn-hover-bg { position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: var(--primary-gradient); transition: left 0.3s ease; z-index: 0; }
        .toolbar-btn > span { position: relative; z-index: 1; display: flex; align-items: center; gap: 10px; }
        .toolbar-btn:hover .btn-hover-bg { left: 0; }
        .toolbar-btn:hover {
            transform: translateY(-2px) scale(1.03);
            border-color: var(--accent-blue);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.35);
            color: var(--text-primary);
        }

        .toolbar-btn.active {
            background: var(--success-gradient);
            border-color: var(--accent-blue);
            color: var(--text-primary);
            font-weight: 600;
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.4);
        }

        .model-dropdown { display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: var(--card-bg); backdrop-filter: blur(20px); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow-heavy); padding: 12px; z-index: 101; width: 220px; }
        .main-content-wrapper {
            display: flex;
            flex-grow: 1;
            padding-top: 76px;
            height: 100vh;
            gap: 4px;
        }

        #left-search-panel {
            width: 380px;
            flex-shrink: 0;
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-light);
            border-radius: var(--radius) 0 0 var(--radius);
        }

        #right-results-panel {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(10, 14, 26, 0.2);
            border-radius: 0 var(--radius) var(--radius) 0;
        }

        .stages-container { display: flex; flex-direction: column; gap: 24px; padding-top: 24px; overflow-y: auto; padding-right: 12px; flex-grow: 1; }
        .stage-card {
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border-radius: var(--radius);
            padding: 24px;
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .stage-card:hover {
            transform: translateY(-4px) scale(1.01);
            box-shadow: var(--shadow-heavy);
            border-color: var(--accent-blue);
        }

        .stage-number {
            position: absolute;
            top: -12px;
            left: 12px;
            background: var(--primary-gradient);
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
            z-index: 1;
        }
        .stage-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .query-types {
            display: flex;
            gap: 10px;
            flex-wrap: nowrap; /* Ngăn không cho các nút xuống hàng */
            flex-grow: 1;     /* Yêu cầu nó chiếm hết không gian trống còn lại */
        }
        .type-btn {
            width: 44px;
            height: 44px;
            font-size: 1.1rem;
            background: var(--glass-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            position: relative;
            overflow: hidden;
        }

        .type-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: var(--primary-gradient);
            border-radius: 50%;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            z-index: -1;
        }

        .type-btn.active::before {
            width: 200%;
            height: 200%;
        }

        .type-btn.active {
            background: transparent;
            border-color: var(--accent-blue);
            color: var(--text-primary);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.3);
        }

        .type-btn[data-type="asr"].active,
        .type-btn[data-type="ocr"].active,
        .type-btn[data-type="gen_image"].active {
            border-color: var(--accent-pink);
            box-shadow: 0 8px 20px rgba(240, 147, 251, 0.3);
        }

        .type-btn[data-type="asr"].active::before,
        .type-btn[data-type="ocr"].active::before,
        .type-btn[data-type="gen_image"].active::before {
            background: var(--secondary-gradient);
        }

        .type-btn:hover:not(.active) {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            transform: translateY(-2px);
        }
        .delete-stage {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(244, 63, 94, 0.1);
            border: 1px solid rgba(244, 63, 94, 0.3);
            color: #f43f5e;
            width: 16px; /* Có thể giảm kích thước một chút cho gọn */
            height: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10; /* Đảm bảo nó nằm trên các phần tử khác */
        }
        .qa-answer-label {
            position: absolute;
            bottom: 6px;
            right: 6px;
            background: rgba(79, 172, 254, 0.85); /* Accent blue */
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            max-width: calc(100% - 20px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-left: 3px solid var(--accent-blue);
        }
        .delete-stage:hover { background: rgba(244, 63, 94, 0.2); transform: scale(1.1) rotate(5deg); box-shadow: 0 4px 15px rgba(244, 63, 94, 0.3); }
        .stage-options { display: flex; gap: 12px; margin-top: 20px; }
        .option-btn { background: var(--glass-bg); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 8px 16px; border-radius: 10px; font-size: 0.85rem; cursor: pointer; transition: all 0.3s ease; font-weight: 500; }
        .option-btn.active { background: var(--success-gradient); border-color: var(--accent-blue); color: var(--text-primary); font-weight: 600; box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3); }
        .option-btn:hover:not(.active) { border-color: var(--accent-blue); color: var(--accent-blue); transform: translateY(-1px); }
        .panel-controls { display: flex; justify-content: space-between; align-items: center; margin-top: auto; flex-shrink: 0; padding-top: 24px; border-top: 1px solid var(--border-color); }
        .stage-controls { display: flex; gap: 16px; }
        .control-btn { width: 54px; height: 54px; border-radius: 14px; border: 1px solid var(--border-color); background: var(--glass-bg); color: var(--text-secondary); font-size: 1.4rem; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .control-btn:hover { background: var(--primary-gradient); transform: scale(1.05) translateY(-2px); color: var(--text-primary); border-color: var(--accent-blue); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4); }
        .search-btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 14px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .search-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .search-btn:hover::before {
            left: 100%;
        }

        .search-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        .search-btn:active {
            transform: scale(0.98);
        }
        .query-input-area { margin-top: 15px; position: relative; }
        .stage-input { width: 100%; padding: 12px 16px; background: var(--glass-bg); backdrop-filter: blur(10px); border: 1px solid var(--border-color); border-radius: 12px; color: var(--text-primary); font-size: 1.0rem; line-height: 1.5; resize: vertical; transition: all 0.3s ease; font-family: inherit; }
        .main-query-input { min-height: 80px; }
        .stage-input:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2); background: rgba(79, 172, 254, 0.05); }
        .stage-input-file { display: none; }
        .image-upload-zone { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 160px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--glass-bg); color: var(--text-secondary); cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden; backdrop-filter: blur(10px); }
        .image-upload-zone.dragover { border-color: var(--accent-blue); background: rgba(79, 172, 254, 0.1); transform: scale(1.02); }
        .image-upload-zone:hover { border-color: var(--accent-purple); background: rgba(102, 126, 234, 0.05); }
        .image-upload-zone i { font-size: 2.5rem; margin-bottom: 10px; }
        .image-upload-zone p { font-size: 0.9rem; text-align: center; }
        .image-preview { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; }
        .remove-image-btn { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255, 255, 255, 0.3); color: #e2e8f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; z-index: 2; }
        .remove-image-btn:hover { background: #ef4444; color: white; border-color: transparent; }
        .model-dropdown-item { display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .model-dropdown-item:hover { background: var(--glass-bg); }
        .model-dropdown-item.focused { background: var(--glass-bg); outline: 2px solid var(--accent-blue); outline-offset: -2px; }
        .model-dropdown-item input[type="checkbox"] { margin-right: 10px; accent-color: var(--accent-blue); }
        .model-dropdown-item label { cursor: pointer; user-select: none; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; }
        .result-item { background: var(--card-bg); backdrop-filter: blur(15px); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); aspect-ratio: 16 / 9; cursor: pointer; position: relative; }
        .result-item:hover { transform: scale(1.03) translateY(-4px); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); border-color: var(--accent-blue); }
        /* ## LAZY LOADING STYLES ## */
        .result-item img { width: 100%; height: 100%; object-fit: cover; display: block; transition: transform 0.3s ease, opacity 0.4s ease-in-out; opacity: 0; }
        .result-item img.loaded { opacity: 1; }
        /* ######################## */
        .result-item:hover img { transform: scale(1.05); }
        .submit-btn { position: absolute; top: 8px; right: 8px; background: rgba(79, 172, 254, 0.8); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s; display: none; align-items: center; justify-content: center; z-index: 5; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); z-index: 1000; display: none; align-items: center; justify-content: center; }
        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            border-radius: 20px;
            box-shadow: var(--shadow-heavy);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--glass-bg);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--accent-blue);
            font-weight: 600;
        }

        .modal-close {
            font-size: 1.6rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .modal-close:hover {
            color: #ef4444;
            transform: rotate(90deg);
        }
        .modal-body { padding: 25px; display: flex; gap: 30px; overflow-y: auto; }
        .modal-body .filter-input { background: rgba(10, 14, 26, 0.8); border: 1px solid var(--border-color); color: white; border-radius: 6px; padding: 8px 10px; font-size: 0.95rem; width: 100%; }
        .modal-body .filter-input:focus { outline: none; border-color: var(--accent-blue); }
        .dres-status { margin-top: 15px; font-size: 0.9rem; color: var(--text-secondary); text-align: center; width: 100%; }
        .filter-section { flex: 1; display: flex; flex-direction: column; }
        .filter-section-header { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .filter-section-title { font-size: 1.2rem; color: var(--accent-blue); }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(22px); }
        .filter-controls-container { display: flex; flex-direction: column; gap: 15px; }
        .count-filter-row { display: grid; grid-template-columns: 30px 1fr 120px; align-items: center; gap: 10px; cursor: pointer; padding: 8px; border-radius: 8px; border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s; }
        .count-filter-row:hover { background-color: rgba(79, 172, 254, 0.1); }
        .count-filter-row.active-row { background-color: rgba(79, 172, 254, 0.15); border-color: rgba(79, 172, 254, 0.4); }
        .count-filter-row.custom { grid-template-columns: 30px 1fr 120px 30px; }
        .count-filter-row input[type=checkbox] { accent-color: var(--accent-blue); width: 18px; height: 18px; cursor: pointer; }
        .count-filter-row label { font-size: 1rem; color: var(--text-primary); }
        .add-custom-btn, .remove-custom-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary); width: 30px; height: 30px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .add-custom-btn:hover, .remove-custom-btn:hover { border-color: var(--accent-blue); color: var(--accent-blue); }
        #positioningCanvas { background: #1e293b; border-radius: 10px; cursor: crosshair; touch-action: none; }
        .drawn-boxes-list { max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .drawn-box-item { display: flex; align-items: center; justify-content: space-between; background: #1e293b; padding: 8px; border-radius: 6px; }
        .drawn-box-item.active { border-left: 3px solid var(--accent-blue); }
        .shortcuts-info { font-size: 0.8rem; color: var(--text-secondary); margin-top: 10px; line-height: 1.6; }
        .image-modal-overlay { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(20px); align-items: center; justify-content: center; }
        .image-modal-content { margin: auto; display: block; max-width: 90vw; max-height: 90vh; animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 12px; box-shadow: var(--shadow-heavy); }
        @keyframes modalZoom { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .image-modal-close { position: absolute; top: 20px; right: 40px; color: var(--text-primary); font-size: 24px; font-weight: bold; transition: all 0.3s ease; cursor: pointer; z-index: 2101; background: rgba(0, 0, 0, 0.5); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .image-modal-close:hover { color: var(--accent-pink); transform: scale(1.1) rotate(90deg); background: rgba(244, 63, 94, 0.2); }
        #temporalContextModal, #dresModal { z-index: 2000; }
        #imageModal, #videoPreviewModal { z-index: 2100; }
        #temporalContextModal .temporal-modal-content { background: var(--dark-bg); border: 1px solid var(--border-color); border-radius: 16px; width: 95%; max-width: 1600px; height: auto; max-height: 95vh; display: flex; flex-direction: column; box-shadow: var(--shadow-heavy); animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        #temporalContextModal .temporal-modal-header { padding: 16px 24px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        #temporalContextModal #temporalModalTitle { font-size: 1.2rem; font-weight: 600; color: var(--text-primary); }
        #temporalContextModal .image-modal-close { position: static; width: 36px; height: 36px; font-size: 1.2rem; }
        #temporalContextModal .temporal-modal-body { padding: 24px; overflow-y: auto; flex-grow: 1; }
        .temporal-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; }
        .temporal-grid-item { position: relative; background-color: var(--glass-bg); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; aspect-ratio: 16 / 9; cursor: pointer; transition: all 0.2s ease-in-out; }
        .temporal-grid-item:hover { transform: scale(1.05); border-color: var(--accent-blue); z-index: 10; }
        .temporal-grid-item.center-frame { border: 2px solid var(--accent-purple); box-shadow: 0 0 15px rgba(102, 126, 234, 0.6); }
        .temporal-grid-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .temporal-item-label { position: absolute; top: 4px; left: 4px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
        #temporalContextModal .temporal-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-color); text-align: center; font-size: 0.9rem; color: var(--text-secondary); flex-shrink: 0; }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-gradient);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-gradient);
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #loadingIndicator {
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--accent-blue);
            font-size: 1.1rem;  /* Giảm kích thước */
            padding: 20px 12px;
            gap: 8px;
            animation: pulse 1s infinite;  /* Nhanh hơn */
        }

        #loadingIndicator i {
            font-size: 1.5rem;  /* Giảm kích thước */
        }
        .processed-query-display-wrapper { display: none; margin-top: 10px; padding: 8px 12px; background: rgba(0,0,0,0.25); border-radius: 8px; border-left: 3px solid var(--accent-purple); align-items: center; gap: 10px; transition: all 0.3s ease; }
        .processed-query-display-wrapper i { color: var(--accent-purple); }
        .processed-query-display { font-size: 0.9rem; color: var(--text-secondary); font-style: italic; word-break: break-all; }
        .timing-info-container { display: none; flex-wrap: wrap; gap: 12px 20px; padding: 16px; background: var(--glass-bg); border: 1px solid var(--border-color); border-radius: 12px; backdrop-filter: blur(10px); margin: 24px; }
        .timing-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
        .timing-item .timing-label { color: var(--text-secondary); display: flex; align-items: center; gap: 6px; }
        .timing-item .timing-value { font-weight: 600; color: var(--text-primary); background-color: rgba(255, 255, 255, 0.1); padding: 3px 8px; border-radius: 6px; }
        .timing-item.total-time .timing-value { font-weight: 700; font-size: 1rem; }
        .timing-item.client-time .timing-value { background-color: rgba(240, 147, 251, 0.15); color: var(--accent-pink); }
        .timing-item.server-time .timing-value { background-color: rgba(79, 172, 254, 0.15); color: var(--accent-blue); }
        .cluster-separator { border: 0; height: 1px; background-image: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0)); margin: 40px 0; }
        .cluster-header { color: var(--accent-purple); font-size: 1.1rem; margin-bottom: 12px; padding-left: 8px; border-left: 3px solid var(--accent-purple); }
        .temporal-stage-grid-container { margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color); }
        .temporal-stage-grid-container:first-of-type { margin-top: 0; padding-top: 0; border-top: none; }
        #usernameModal { z-index: 3000; }
        #resultsContainer { padding: 0 24px 24px 24px; }

        /* ## START: Teamwork Panel CSS Changes ## */
        #teamworkPanelContainer {
            padding-top: 24px;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0; /* ## FIX: Stick flush to the top ## */
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(15px);
            z-index: 50;
        }
        #teamworkPanelContainer h3 {
            font-size: 1.3rem;
            color: var(--accent-purple);
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 0 24px;
        }
        #teamworkGrid {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 16px;
            padding: 0 24px 24px 24px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #teamworkGrid::-webkit-scrollbar { display: none; }
        #teamworkGrid .result-item {
            flex: 0 0 220px;
        }
        
        .teamwork-item {
            border: 3px solid var(--user-color, var(--accent-blue));
            border-radius: 12px;
            box-shadow: 0 0 12px var(--user-color, var(--accent-blue));
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .teamwork-item:hover {
            transform: scale(1.03) translateY(-4px);
            box-shadow: 0 12px 30px var(--user-color, var(--accent-blue));
        }

        .teamwork-item-user-label {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            border-left: 3px solid var(--user-color, var(--accent-blue));
        }

        /* ## START: CSS FIX FOR BLUE CIRCLE ## */
        .temporal-grid-item:hover .submit-btn,
        .teamwork-item:hover .submit-btn {
            display: flex;
        }
        /* ## END: CSS FIX FOR BLUE CIRCLE ## */

        .submit-btn:hover {
            background: var(--accent-blue);
            transform: scale(1.1);
        }
        /* ## END: Teamwork Panel CSS Changes ## */

        #google-image-search-container {
            padding-bottom: 24px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .google-search-header {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }
        .google-search-header .fa-google {
            color: var(--accent-blue);
        }
        .google-search-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #googleSearchInput {
            flex-grow: 1;
        }
        #googleSearchBtn {
            width: auto;
            height: 48px;
            padding: 0 16px;
        }
        #google-image-results-wrapper {
            margin-top: 16px;
        }
        #google-image-results {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 10px;
            background: var(--glass-bg);
            border-radius: 12px;
            min-height: 120px;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .google-image-item {
            flex: 0 0 160px;
            height: 90px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s ease, transform 0.2s ease;
        }

        .google-image-item:hover {
            border-color: var(--accent-blue);
            transform: scale(1.05);
        }
        .google-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .google-image-item .overlay-actions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .google-image-item:hover .overlay-actions {
            opacity: 1;
        }
        .google-image-item .overlay-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        .google-image-item .overlay-btn:hover {
            background: var(--accent-blue);
            transform: scale(1.1);
        }
    /* ## START: NEW CSS FOR VIDEO PREVIEW ENHANCEMENTS ## */
        .video-player-container {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-frame-info-display {
            position: absolute;
            bottom: 90px; /* Position it on top of the video player */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(5px);
            color: var(--text-secondary);
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 2101; /* Make sure it's on top of the video */
            pointer-events: none; /* Allows clicks to pass through to the video */
            border: 1px solid var(--border-color);
        }

        /* ## END: NEW CSS FOR VIDEO PREVIEW ENHANCEMENTS ## */
        
        /* === BƯỚC 2: CSS CHO NÚT MICRO === */
        .mic-btn.recording {
            background: transparent;
            border-color: #f43f5e; /* Màu đỏ */
            color: #f43f5e;
            box-shadow: 0 8px 20px rgba(244, 63, 94, 0.3);
        }

        .mic-btn.recording::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(135deg, #f5576c 0%, #f43f5e 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: -1;
            animation: pulse-red 1.5s infinite; /* Thêm hiệu ứng pulse */
        }
        @keyframes pulse-red {
            0% { transform: translate(-50%, -50%) scale(0.9); }
            70% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(0.9); }
        }
        /* === KẾT THÚC CSS CHO NÚT MICRO === */

        #correctSubmissionPanel {
            position: fixed; /* Hoặc 'sticky' nếu bạn muốn nó cuộn cùng một chút */
            top: 90px;
            right: 20px;
            width: 250px;
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border: 2px solid #4ade80; /* Màu xanh lá cây cho thành công */
            border-radius: var(--radius);
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.6);
            z-index: 150;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation: fadeInRight 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #correctSubmissionPanel h4 {
            color: #4ade80;
            text-align: center;
            font-size: 1.1rem;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #correctSubmissionImageContainer {
            width: 100%;
            aspect-ratio: 16 / 9;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        #correctSubmissionImageContainer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #correctSubmissionPanel .reset-note {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            margin: 0;
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        /* ## END: CORRECT SUBMISSION PANEL STYLES ## */

        /* ## START: SUBMISSION STATUS STYLES ## */
        .result-item.submitting {
            opacity: 0.6;
            pointer-events: none; /* Vô hiệu hóa click khi đang nộp */
        }

        .result-item.submitted-wrong .teamwork-item-user-label {
            background: #ef4444; /* Màu đỏ cho nộp sai */
            border-left-color: #f87171;
        }

        .result-item.submitted-wrong {
            border-color: #ef4444 !important;
            box-shadow: 0 0 12px #ef4444;
        }

        .result-item.submitted-duplicate .teamwork-item-user-label {
            background: #f59e0b; /* Màu vàng cho trùng lặp */
            border-left-color: #fbbf24;
        }

        .result-item.submitted-duplicate {
            border-color: #f59e0b !important;
            box-shadow: 0 0 12px #f59e0b;
        }

        #correctSubmissionImageContainer .result-item {
            /* Ép item lấp đầy container cha của nó */
            width: 100%;
            height: 100%;
            
            /* Ghi đè các thuộc tính có thể gây ra hiển thị sai */
            margin: 0;
            border: none; /* Container cha đã có border xanh */
            box-shadow: none !important; /* Vô hiệu hóa bóng đổ khi hover */
            transform: none !important; /* Vô hiệu hóa hiệu ứng 'nhấc' lên khi hover */
            cursor: default; /* Bỏ cursor pointer của chính item */
        }

        #correctSubmissionImageContainer .result-item img {
            cursor: pointer; /* Đặt lại cursor pointer cho ảnh bên trong */
        }

        /* Đảm bảo hiệu ứng hover scale trên ảnh vẫn hoạt động */
        #correctSubmissionImageContainer .result-item:hover img {
            transform: scale(1.05);
        }
        /* ## END: CSS FIX ## */

        /* ## START: SUBMISSION STATUS OVERLAY STYLES ## */
        .submission-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 26, 0.7);
            backdrop-filter: blur(5px);
            border-radius: inherit; /* Kế thừa bo góc của item cha */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: white;
            
            /* Hiệu ứng */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 5;
            pointer-events: none; /* Cho phép click xuyên qua nếu cần */
        }

        .submission-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .submission-overlay i {
            font-size: 2.2rem;
            margin-bottom: 5px;
        }

        /* Trạng thái: Đang xử lý */
        .submission-overlay.status-pending {
            color: var(--accent-blue);
        }

        /* Trạng thái: Đúng */
        .submission-overlay.status-correct {
            background: rgba(74, 222, 128, 0.7); /* Xanh lá */
            color: white;
        }

        /* Trạng thái: Sai */
        .submission-overlay.status-wrong {
            background: rgba(244, 63, 94, 0.7); /* Đỏ */
            color: white;
        }

        /* Trạng thái: Trùng lặp */
        .submission-overlay.status-duplicate {
            background: rgba(245, 158, 11, 0.7); /* Vàng */
            color: white;
        }
        /* ## END: SUBMISSION STATUS OVERLAY STYLES ## */
        .theme-btn-wrapper { position: relative; }
        .theme-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: var(--shadow-heavy);
            padding: 12px;
            z-index: 101;
            width: 220px;
        }
        .theme-dropdown-item {
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }
        .theme-dropdown-item:hover { background: var(--glass-bg); }
        .theme-color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }
        /* ## END: THEME SWITCHER STYLES ## */

        #submissionPanelContainer {
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(15px);
            z-index: 49; /* Below teamwork panel */
            }
        #submissionPanelContainer h3 {
            font-size: 1.3rem;
            color: var(--accent-pink);
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 24px 24px 0 24px;
            }
        #submissionGrid {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 16px;
            padding: 16px 24px 24px 24px;
            min-height: 150px; /* Ensure panel has height even when empty */
            }
        #submissionGrid .result-item {
            flex: 0 0 220px; /* Fixed width for submission items */
            border: 2px solid var(--accent-pink);
            cursor: grab;
            }
        #submissionGrid .result-item:active { cursor: grabbing; }
        .trake-item-actions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: flex-end;
            padding: 8px;
            gap: 6px;
        }
        .trake-action-btn {
            background: rgba(10, 14, 26, 0.8);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 6;
        }
        .result-item:hover .trake-action-btn { display: flex; }
        .trake-action-btn:hover {
            background: var(--primary-gradient);
            color: white;
            transform: scale(1.1);
        }
        /* Dragging ghost style */
        .ghost { opacity: 0.4; }
        /* Nearby frames list */
        .nearby-frames-container {
            position: absolute;
            bottom: 105%;
            left: 0;
            width: 100%;
            max-height: 200px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 20;
            padding: 8px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            animation: fadeIn 0.3s;
        }
        .nearby-frame-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .nearby-frame-item:hover { background-color: var(--glass-bg); }
        .nearby-frame-item img {
            width: 80px;
            height: 45px;
            object-fit: cover;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .nearby-frame-item .time-offset { font-weight: 600; }
        .nearby-frame-item.loading { justify-content: center; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
         /* ## START: NEARBY FRAMES SIDEBAR STYLES ## */
        .nearby-frames-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2500;
            display: flex;
            justify-content: flex-end;
        }
        .sidebar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
        }
        .sidebar-content {
            position: relative;
            width: 300px;
            height: 100%;
            background: var(--dark-bg);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-heavy);
            display: flex;
            flex-direction: column;
            animation: slideInFromRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .sidebar-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .sidebar-header h3 { color: var(--accent-blue); font-size: 1.2rem; }
        .sidebar-grid {
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-grow: 1;
        }
        .sidebar-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background: var(--glass-bg);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .sidebar-item:hover {
            border-color: var(--accent-blue);
            background: rgba(79, 172, 254, 0.1);
        }
        .sidebar-item img {
            width: 128px;
            height: 72px;
            object-fit: cover;
            border-radius: 6px;
            flex-shrink: 0;
        }
        .sidebar-item .time-offset { font-weight: 600; font-size: 1rem; }
        @keyframes slideInFromRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        /* ## END: NEARBY FRAMES SIDEBAR STYLES ## */
        body.video-modal-active.theme-gits-rain #digitalRainCanvas {
            display: none !important;
        }
        body.video-modal-active.theme-jujutsu-domain .stage-card,
        body.video-modal-active.theme-jujutsu-domain .modal-content,
        body.video-modal-active.theme-jujutsu-domain .result-item {
            filter: none !important;
        }
        body.video-modal-active.theme-akira-red {
            animation: none !important;
        }
    </style>
</head>
<body>
    <video autoplay loop muted playsinline id="cursedDomainVideo">
        <source src="/static/jujutsu_kaisen.mp4" type="video/mp4">
    </video>
    <canvas id="digitalRainCanvas"></canvas>

    <!-- SVG Filter cho hiệu ứng Cursed Energy của theme Jujutsu Kaisen -->
    <svg style="display:none">
        <filter id="cursed-energy-wobble">
            <feTurbulence baseFrequency="0.02 0.05" numOctaves="3" seed="2" type="fractalNoise" result="turbulence" />
            <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="5" xChannelSelector="R" yChannelSelector="G" />
            <animate attributeName="baseFrequency" dur="10s" keyTimes="0;0.5;1" values="0.02 0.05;0.03 0.08;0.02 0.05" repeatCount="indefinite" />
        </filter>
    </svg>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="app-title">
                <img src="/static/logo.png" alt="OpenCubee Logo" class="app-logo">
                <span>OpenCubee</span>
            </div>
            <div id="userInfo" style="color: var(--text-secondary);"></div>
        </div>
        <div class="toolbar-right">
            <div id="userInfo" style="color: var(--text-secondary);"></div>
            <!-- START: THEME SWITCHER -->
            <div class="theme-btn-wrapper">
                <button id="themeSwitcherBtn" class="toolbar-btn" title="Change Theme">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-palette"></i> Theme</span>
                </button>
                <div id="themeDropdown" class="theme-dropdown">
                    <!-- Theme options will be added by JS -->
                </div>
            </div>
            <!-- END: THEME SWITCHER -->
            <button class="toolbar-btn" id="dresBtn" title="DRES Submission"><div class="btn-hover-bg"></div><span><i class="fas fa-trophy"></i> DRES</span></button>
            <!-- START: NEW TASK MANAGEMENT UI -->
            <div class="toolbar-btn" style="padding: 0; background: none; border: none;">
                <select id="taskSelector" class="toolbar-btn" style="width: 150px; -webkit-appearance: none; appearance: none;" title="Select Active Task"></select>
            </div>
            <button class="toolbar-btn" id="addTaskBtn" title="Add New Task">
                <div class="btn-hover-bg"></div>
                <span><i class="fas fa-plus-circle"></i> New Task</span>
            </button>
            <!-- END: NEW TASK MANAGEMENT UI -->
            <!-- START: SUBMISSION PANEL BUTTON -->
            <button class="toolbar-btn" id="submissionBtn" title="Toggle Submission Panel"><div class="btn-hover-bg"></div><span><i class="fas fa-file-export"></i> Submit Panel</span></button>
            <!-- END: SUBMISSION PANEL BUTTON -->
            <div class="model-btn-wrapper">
                <button id="modelSelectBtn" class="toolbar-btn" title="Toggle Models (Ctrl+M)"><div class="btn-hover-bg"></div><span><i class="fas fa-layer-group"></i> Models</span></button>
                <div id="modelDropdown" class="model-dropdown">
                    <div class="model-dropdown-item"><input type="checkbox" id="model-beit3" value="beit3" checked><label for="model-beit3">BEiT-3</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-bge" value="bge" checked><label for="model-bge">BGE-VL</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-ops_mm" value="ops_mm" checked><label for="model-ops_mm">Ops-MM</label></div>
                </div>
            </div>
            <button class="toolbar-btn" id="objectFilterBtn" title="Object Filters (Ctrl+F)"><div class="btn-hover-bg"></div><span><i class="fas fa-shapes"></i> Filters</span></button>
            <button class="toolbar-btn" id="clusterBtn" title="Toggle Clustering (Ctrl+G)"><div class="btn-hover-bg"></div><span><i class="fas fa-object-group"></i> Cluster</span></button>
            <button class="toolbar-btn" id="ambiguousBtn" title="Toggle Ambiguous Temporal Search (Ctrl+Shift+G)"><div class="btn-hover-bg"></div><span><i class="fas fa-random"></i> Ambiguous</span></button>
            <button class="toolbar-btn" id="resetBtn" title="Reset Search (Ctrl+Shift+R)"><div class="btn-hover-bg"></div><span><i class="fas fa-redo"></i> Reset Search</span></button>
        </div>
    </div>
    <div class="main-content-wrapper">
        <div id="left-search-panel">
            <div id="google-image-search-container">
                <div class="google-search-header">
                </div>
                <div class="google-search-input-wrapper">
                    <input type="text" id="googleSearchInput" class="stage-input" placeholder="Tìm ảnh trên Google...">
                    <button id="googleSearchBtn" class="control-btn" title="Search"><i class="fas fa-search"></i></button>
                </div>
                <div id="google-image-results-wrapper" style="display: none;">
                    <div id="google-image-results">
                        <!-- Fetched images will appear here -->
                    </div>
                </div>
            </div>
            <div class="stages-container" id="stagesContainer"></div>
            <div class="panel-controls">
                <div class="stage-controls">
                    <button class="control-btn" id="addStageBtn" title="Add Stage to End (Ctrl+])"><i class="fas fa-plus"></i></button>
                    <button class="control-btn" id="removeStageBtn" title="Remove Last Stage (Ctrl+Shift+])"><i class="fas fa-minus"></i></button>
                </div>
                <button class="search-btn" id="searchBtn" title="Search (Enter)"><i class="fas fa-search"></i> Search</button>
            </div>
        </div>
        <div id="right-results-panel">
            <div id="correctSubmissionPanel" style="display: none;">
                <h4><i class="fas fa-check-circle"></i> Correct Submission</h4>
                <div id="correctSubmissionImageContainer">
                </div>
                <p class="reset-note">This will be cleared on 'Reset Search'.</p>
            </div>
            <div id="teamworkPanelContainer" style="display: none;">
                <h3><i class="fas fa-users"></i> Teamwork Submission Panel</h3>
                <div id="teamworkGrid"></div>
            </div>
             <div id="submissionPanelContainer" style="display: none;">
                <h3 style="display: flex; justify-content: space-between; align-items: center;">
                    <span><i class="fas fa-file-export"></i> Submission Panel</span>
                    <button id="submitPanelBtn" class="toolbar-btn" title="Submit all frames in this panel to the active task's CSV file (Ctrl+Shift+Space on panel)">
                        <div class="btn-hover-bg"></div>
                        <span><i class="fas fa-save"></i> Submit to CSV</span>
                    </button>
                </h3>
                <div id="submissionGrid"></div>
            </div>
            <div id="timingInfoDisplay" class="timing-info-container"></div>
            <div id="loadingIndicator" style="display: none; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Performing Search...</div>
            <div id="resultsContainer">
                <p style="text-align: center; color: var(--text-secondary); padding-top: 100px; font-size: 1.2rem;">Sử dụng bảng điều khiển bên trái để bắt đầu tìm kiếm.</p>
            </div>
        </div>
    </div>

    <div id="usernameModal" class="modal-overlay" style="display: flex; z-index: 3000;">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title" style="width: 100%; text-align: center; color: var(--text-primary); font-weight: 600;">Welcome to OpenCubee!</h2>
            </div>
            <div class="modal-body" style="flex-direction: column; gap: 20px;">
                <p style="color: var(--text-secondary);">Please enter your name to join the session.</p>
                <input type="text" id="usernameInput" class="filter-input" placeholder="Your Name...">
                <button id="usernameSubmitBtn" class="search-btn" style="width: 100%;">Join</button>
            </div>
        </div>
    </div>

    <div id="objectFilterModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 class="modal-title"><i class="fas fa-shapes"></i> Object Filters</h2><span class="modal-close" id="modalCloseBtn">&times;</span></div><div class="modal-body"><div class="filter-section"><div class="filter-section-header"><h3 class="filter-section-title">Object Counting</h3><label class="switch"><input type="checkbox" id="enableCountFilter"><span class="slider"></span></label></div><div id="countFilterControls" class="filter-controls-container"></div><button class="add-custom-btn" id="addCustomCountBtn" style="margin-top: 15px; width: 100%;"><i class="fas fa-plus"></i> Add Custom Object</button></div><div class="filter-section"><div class="filter-section-header"><h3 class="filter-section-title">Object Positioning</h3><label class="switch"><input type="checkbox" id="enablePositionFilter"><span class="slider"></span></label></div><div class="position-controls"><canvas id="positioningCanvas" width="640" height="360"></canvas><div id="drawnBoxesList" class="drawn-boxes-list"></div><p class="shortcuts-info"><b>Shortcuts:</b> Draw box with mouse. <br><b>1-6:</b> person, car, truck, dog, cat, toaster. <b>7:</b> Custom. <br><b>Backspace:</b> Delete last box. <b>C:</b> Clear all.</p></div></div></div></div></div>
    <div id="imageModal" class="image-modal-overlay"><span class="image-modal-close" title="Close (Esc)">&times;</span><img class="image-modal-content" id="zoomedImage"></div>
    <div id="temporalContextModal" class="image-modal-overlay"><div class="temporal-modal-content"><div class="temporal-modal-header"><h2 id="temporalModalTitle"></h2><span class="image-modal-close" id="closeTemporalModalBtn" title="Close (Esc)">&times;</span></div><div class="temporal-modal-body"><div class="temporal-grid" id="temporalGrid"></div></div><div class="temporal-modal-footer">Shortcuts: Click to zoom. Ctrl+Click/Space on button to Push. Ctrl+Shift+Click/Space on button to Submit Direct.</div></div></div>
    
    <!-- ## START: MODIFIED DRES MODAL WITH NEW FLOW ## -->
    <div id="dresModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-trophy"></i> DRES Submission</h2>
                <span class="modal-close" id="dresModalCloseBtn">&times;</span>
            </div>
            <div class="modal-body" style="flex-direction: column; gap: 20px;">
                
                <!-- View 1: Initial Login Button -->
                <div id="dresInitialView">
                    <button id="dresShowLoginBtn" class="search-btn" style="width: 100%;">Login to DRES</button>
                </div>
                
                <!-- View 2: Login Form (hidden by default) -->
                <div id="dresLoginView" style="display: none; flex-direction: column; gap: 20px;">
                    <div>
                        <label for="dresUsername">Username</label>
                        <input type="text" id="dresUsername" class="filter-input" placeholder="Enter your username...">
                    </div>
                    <div>
                        <label for="dresPassword">Password</label>
                        <input type="password" id="dresPassword" class="filter-input" placeholder="Enter your password...">
                    </div>
                    <button id="dresLoginBtn" class="search-btn" style="width: 100%;">Login & Get Evaluations</button>
                </div>
                
                <!-- View 3: Evaluation Selector (hidden by default) -->
                <div id="dresEvaluationView" style="display: none; width: 100%;">
                    <label for="dresEvaluationSelect">Select Evaluation</label>
                    <select id="dresEvaluationSelect" class="filter-input" disabled></select>
                </div>

                <!-- Status message is always visible -->
                <div id="dresStatus" class="dres-status">Status: Not logged in.</div>
            </div>
        </div>
    </div>
    <!-- ## END: MODIFIED DRES MODAL ## -->

    <!-- ## START: MODIFIED VIDEO PREVIEW MODAL ## -->
    <div id="videoPreviewModal" class="image-modal-overlay">
        <span class="image-modal-close" id="closeVideoModalBtn" title="Close (Esc)">&times;</span>
        <div class="video-player-container">
            <video id="videoPlayer" class="image-modal-content" controls autoplay style="background-color: #000;"></video>

            <!-- NEW: Frame and Time Display -->
            <div id="videoFrameInfo" class="video-frame-info-display">
                Frame: <span id="currentFrameDisplay">-</span> | Time: <span id="currentTimeDisplay">-</span>s
            </div>
            
            <!-- Container for the action buttons -->
            <div id="videoActionButtons" style="margin-top: 20px; display: flex; gap: 15px;">
                <button id="pushCurrentFrameBtn" class="toolbar-btn" title="Push to Team (Ctrl+Space in player)">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-users"></i> Team</span>
                </button>
                <button id="submitCurrentFrameBtn" class="search-btn" title="Push to Submission Panel (Ctrl+Shift+Space in player)">
                    <i class="fas fa-file-export"></i> Push to Panel
                </button>
            </div>
        </div>
    </div>
    <!-- ## END: MODIFIED VIDEO PREVIEW MODAL ## -->
     <div id="nearbyFramesSidebar" class="nearby-frames-sidebar" style="display: none;">
        <div class="sidebar-overlay"></div>
        <div class="sidebar-content">
            <div class="sidebar-header">
                <h3 id="sidebarTitle">Nearby Frames</h3>
                <span id="sidebarCloseBtn" class="modal-close">&times;</span>
            </div>
            <div id="sidebarGrid" class="sidebar-grid">
                <!-- Nearby frames will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ## MERGED & CORRECTED SCRIPT ##
        let ws;
        let username = '';
        let userColor = '';
        let currentlyHoveredItemData = null;
        let currentlyHoveredItemElement = null;
        let lastSuccessfulSubmission = null;
        let pushedFrames = new Set();
        let currentPage = 1;
        let totalResults = 0;
        let isLoadingMore = false;
        let lastSearchPayload = null;
        let currentVideoPreviewData = null; // <<< ADD THIS LINE
        let activeTaskName = null;
        let submittedFrames = new Map(); // Key: filepath, Value: 'CORRECT', 'WRONG', 'DUPLICATE', 'PENDING'
        let isMouseOverSubmissionPanel = false; // For bulk submission shortcut
        const THEMES = {
            'default': 'Default Dark',
            'theme-cyberpunk-neon': 'Cyberpunk Neon',
            'theme-cyberpunk-glitch': 'CP2077',
            'theme-gits-rain': 'GITS',
            'theme-jujutsu-domain': 'JJK',
        };
        const rainCanvas = document.getElementById('digitalRainCanvas');
        const cursedDomainVideo = document.getElementById('cursedDomainVideo');
        const rainCtx = rainCanvas.getContext('2d');
        let animationFrameId;
        let targetFrameTime = 0;
        let isScrubbing = false;
        let scrubbingTimeout = null;
        let scrubAnimationId = null;
        

        function startDigitalRain() {
            rainCanvas.style.display = 'block';
            
            rainCanvas.width = window.innerWidth;
            rainCanvas.height = window.innerHeight;

            const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
            const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const nums = '0123456789';
            const alphabet = katakana + latin + nums;

            const fontSize = 16;
            const columns = rainCanvas.width / fontSize;
            const rainDrops = [];

            for (let x = 0; x < columns; x++) {
                rainDrops[x] = 1;
            }

            const draw = () => {
                rainCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                rainCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height);

                rainCtx.fillStyle = '#00FF41';
                rainCtx.font = fontSize + 'px Share Tech Mono';

                for (let i = 0; i < rainDrops.length; i++) {
                    const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                    rainCtx.fillText(text, i * fontSize, rainDrops[i] * fontSize);

                    if (rainDrops[i] * fontSize > rainCanvas.height && Math.random() > 0.975) {
                        rainDrops[i] = 0;
                    }
                    rainDrops[i]++;
                }
                animationFrameId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopDigitalRain() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            rainCanvas.style.display = 'none';
        }

        const PAGE_SIZE = 30;

        // ## LAZY LOADING ##
        let imageObserver = null;
        // ##################

        function displayTimingInfo(serverTimings, clientStartTime) { const container = document.getElementById('timingInfoDisplay'); const clientTotalTime = (performance.now() - clientStartTime) / 1000; if ((!serverTimings || Object.keys(serverTimings).length === 0) && !clientTotalTime) { container.style.display = 'none'; return; } container.innerHTML = ''; const createTimingItem = (label, value, icon, extraClass = '') => { if (typeof value !== 'number') return ''; return `<div class="timing-item ${extraClass}"><span class="timing-label"><i class="${icon}"></i> ${label}:</span><span class="timing-value">${value.toFixed(3)} s</span></div>`; }; container.innerHTML += createTimingItem('Total User Time', clientTotalTime, 'fas fa-desktop', 'total-time client-time'); if (serverTimings && serverTimings.total_request_s) { container.innerHTML += createTimingItem('Total Server Time', serverTimings.total_request_s, 'fas fa-server', 'total-time server-time'); } if (serverTimings) { const timingLabels = {'query_processing_s': { label: 'Query Prep', icon: 'fas fa-cogs' }, 'ocr_asr_filtering_s': { label: 'Text Filter', icon: 'fas fa-filter' }, 'embedding_generation_s': { label: 'Embedding', icon: 'fas fa-brain' }, 'vector_search_s': { label: 'Vector Search', icon: 'fas fa-search-plus' }, 'post_processing_s': { label: 'Post-Process', icon: 'fas fa-sitemap' }, 'object_filter_precomputation_s': {label: 'Object Filter', icon: 'fas fa-th-large'}, 'stage_candidate_gathering_s': { label: 'Stage Search', icon: 'fas fa-tasks' }, 'sequence_assembly_s': { label: 'Sequence Assembly', icon: 'fas fa-link' }, 'final_processing_s': { label: 'Final Process', icon: 'fas fa-check-double' }}; const detailedKeys = Object.keys(serverTimings).filter(key => key !== 'total_request_s'); for (const key of detailedKeys) { if (timingLabels[key] && serverTimings[key] > 0) { const info = timingLabels[key]; container.innerHTML += createTimingItem(info.label, serverTimings[key], info.icon); } } } container.style.display = 'flex'; }
        function urlSafeB64Encode(str) { try { const utf8Bytes = new TextEncoder().encode(str); let binaryString = ''; utf8Bytes.forEach(byte => { binaryString += String.fromCharCode(byte); }); return btoa(binaryString).replace(/\+/g, '-').replace(/\//g, '_'); } catch (e) { console.error("Failed to encode string:", str, e); return ""; } }

        document.addEventListener('DOMContentLoaded', () => {
            // --- BƯỚC 3: KHỞI TẠO SPEECH RECOGNITION ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition;
            let activeSpeechInput = null;
            let isRecording = false;
            // ### FIX START: Thêm biến để lưu trữ văn bản đã được xác nhận ###
            let currentTranscriptBase = ''; 
            // ### FIX END ###

            if (!SpeechRecognition) {
                console.warn("Trình duyệt không hỗ trợ nhận dạng giọng nói.");
            } else {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'vi-VN';

                recognition.onstart = () => {
                    isRecording = true;
                    // ### FIX START: Reset transcript base khi bắt đầu ###
                    currentTranscriptBase = ''; 
                    // ### FIX END ###
                    if (activeSpeechInput) {
                        const stageCard = activeSpeechInput.closest('.stage-card');
                        stageCard.querySelector('.mic-btn')?.classList.add('recording');
                    }
                };
                
                recognition.onend = () => {
                    isRecording = false;
                    // ### FIX START: Dọn dẹp state khi kết thúc ###
                    activeSpeechInput = null; 
                    currentTranscriptBase = ''; 
                    // ### FIX END ###
                    document.querySelectorAll('.mic-btn.recording').forEach(btn => btn.classList.remove('recording'));
                };
                
                // ### FIX START: Sửa toàn bộ logic onresult ###
                recognition.onresult = (event) => {
                    if (!activeSpeechInput) return;

                    let interimTranscript = '';
                    // Lặp qua tất cả các kết quả từ lần cuối cùng
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        // Nếu kết quả là final, nối nó vào chuỗi base đã xác nhận
                        if (event.results[i].isFinal) {
                            currentTranscriptBase += event.results[i][0].transcript.trim() + ' ';
                        } else {
                        // Nếu không, nó là kết quả tạm thời
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    // Cập nhật giá trị của input bằng chuỗi base + chuỗi tạm thời
                    activeSpeechInput.value = (currentTranscriptBase + interimTranscript).trim();
                };
                // ### FIX END ###
            }
            // --- KẾT THÚC KHỞI TẠO ---
            
            const stagesContainer = document.getElementById('stagesContainer'); const addStageBtn = document.getElementById('addStageBtn'); const removeStageBtn = document.getElementById('removeStageBtn'); const searchBtn = document.getElementById('searchBtn'); const resultsContainer = document.getElementById('resultsContainer'); const loadingIndicator = document.getElementById('loadingIndicator'); const modelSelectBtn = document.getElementById('modelSelectBtn'); const modelDropdown = document.getElementById('modelDropdown'); const clusterBtn = document.getElementById('clusterBtn'); const ambiguousBtn = document.getElementById('ambiguousBtn'); const objectFilterBtn = document.getElementById('objectFilterBtn'); const objectFilterModal = document.getElementById('objectFilterModal'); const modalCloseBtn = document.getElementById('modalCloseBtn'); const imageModal = document.getElementById('imageModal'); const zoomedImage = document.getElementById('zoomedImage'); const closeImageModalBtn = document.querySelector('#imageModal .image-modal-close'); const temporalContextModal = document.getElementById('temporalContextModal'); const temporalGrid = document.getElementById('temporalGrid'); const temporalModalTitle = document.getElementById('temporalModalTitle'); const closeTemporalModalBtn = document.getElementById('closeTemporalModalBtn'); const enableCountFilter = document.getElementById('enableCountFilter'); const enablePositionFilter = document.getElementById('enablePositionFilter'); const countFilterControls = document.getElementById('countFilterControls'); const addCustomCountBtn = document.getElementById('addCustomCountBtn'); const posCanvas = document.getElementById('positioningCanvas'); const drawnBoxesList = document.getElementById('drawnBoxesList'); const posCtx = posCanvas.getContext('2d');
            
            const dresBtn = document.getElementById('dresBtn'); 
            const dresModal = document.getElementById('dresModal');
            const dresModalCloseBtn = document.getElementById('dresModalCloseBtn');
            const dresInitialView = document.getElementById('dresInitialView');
            const dresShowLoginBtn = document.getElementById('dresShowLoginBtn');
            const dresLoginView = document.getElementById('dresLoginView');
            const dresUsername = document.getElementById('dresUsername');
            const dresPassword = document.getElementById('dresPassword');
            const dresLoginBtn = document.getElementById('dresLoginBtn'); 
            const dresEvaluationView = document.getElementById('dresEvaluationView');
            const dresEvaluationSelect = document.getElementById('dresEvaluationSelect');
            const dresStatus = document.getElementById('dresStatus');

            const googleSearchInput = document.getElementById('googleSearchInput');
            const googleSearchBtn = document.getElementById('googleSearchBtn');
            const googleResultsWrapper = document.getElementById('google-image-results-wrapper');
            const googleResultsContainer = document.getElementById('google-image-results');
            const rightResultsPanel = document.getElementById('right-results-panel');
            const videoPreviewModal = document.getElementById('videoPreviewModal');
            const videoPlayer = document.getElementById('videoPlayer');
            const closeVideoModalBtn = document.getElementById('closeVideoModalBtn');
            const submitCurrentFrameBtn = document.getElementById('submitCurrentFrameBtn');
            const pushCurrentFrameBtn = document.getElementById('pushCurrentFrameBtn');

            const frameInfoDisplay = document.getElementById('videoFrameInfo');
            const currentFrameSpan = document.getElementById('currentFrameDisplay');
            const currentTimeSpan = document.getElementById('currentTimeDisplay');
            const themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
            const themeDropdown = document.getElementById('themeDropdown');
            const submissionBtn = document.getElementById('submissionBtn');
            const submissionPanelContainer = document.getElementById('submissionPanelContainer');
            const submissionGrid = document.getElementById('submissionGrid');
            const nearbyFramesSidebar = document.getElementById('nearbyFramesSidebar');
            const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
            const sidebarGrid = document.getElementById('sidebarGrid');
            const sidebarOverlay = document.querySelector('.sidebar-overlay');
            const sidebarTitle = document.getElementById('sidebarTitle');
            let activeTrakeItemForSidebar = null; // To track which trake item is being edited

            function updateFrameDisplay() {
                if (!videoPlayer.paused && document.activeElement !== videoPlayer) {
                    // Don't update while video is playing normally to save performance,
                    // unless the video element itself is focused.
                }

                if (currentVideoPreviewData && currentVideoPreviewData.fps) {
                    const currentTime = videoPlayer.currentTime;
                    const currentFrame = Math.round(currentTime * currentVideoPreviewData.fps);
                    
                    currentFrameSpan.textContent = currentFrame;
                    currentTimeSpan.textContent = currentTime.toFixed(3);
                } else {
                    currentFrameSpan.textContent = '-';
                    currentTimeSpan.textContent = '-';
                }
            }
            function scrubUpdateLoop() {
                if (!isScrubbing) {
                    cancelAnimationFrame(scrubAnimationId);
                    scrubAnimationId = null;
                    return;
                }
                // Chỉ gửi lệnh seek nếu có sự chênh lệch đáng kể
                if (Math.abs(videoPlayer.currentTime - targetFrameTime) > 0.01) {
                    videoPlayer.currentTime = targetFrameTime;
                }
                // CẬP NHẬT MỚI: Cập nhật hiển thị số frame/giây MỌI LÚC trong vòng lặp
                // Điều này tạo ra cảm giác phản hồi tức thì khi scroll.
                updateFrameDisplay();
                
                scrubAnimationId = requestAnimationFrame(scrubUpdateLoop);
            }
            function handleScrub(direction) {
                if (!currentVideoPreviewData || !currentVideoPreviewData.fps) return;

                videoPlayer.pause();
                const frameTime = 1 / currentVideoPreviewData.fps;
                
                // Update the target time based on input direction
                targetFrameTime += direction * frameTime;
                // Clamp the target time within the video's duration
                targetFrameTime = Math.max(0, Math.min(videoPlayer.duration, targetFrameTime));

                // Start the animation loop if it's not already running
                if (!isScrubbing) {
                    isScrubbing = true;
                    if (!scrubAnimationId) {
                        scrubAnimationId = requestAnimationFrame(scrubUpdateLoop);
                    }
                }

                // Reset the timeout. This ensures the loop keeps running as long
                // as the user is actively scrubbing.
                clearTimeout(scrubbingTimeout);
                scrubbingTimeout = setTimeout(() => {
                    isScrubbing = false; // Stop the loop when user is idle for 250ms
                }, 250); 
            }

            // Listen for the 'wheel' event (mouse scroll) on the video player
            videoPlayer.addEventListener('wheel', (event) => {
                event.preventDefault();
                // Determine direction: negative deltaY is scroll up (forward), positive is scroll down (backward)
                const direction = event.deltaY < 0 ? 1 : -1;
                handleScrub(direction);
            });
            videoPlayer.addEventListener('seeked', () => {
                // Chỉ cập nhật nếu chúng ta không đang ở giữa một thao tác scroll tùy chỉnh.
                // Điều này ngăn xung đột giữa hai cơ chế.
                if (!isScrubbing) {
                    targetFrameTime = videoPlayer.currentTime;
                    console.log(`Seeked manually. Synced targetFrameTime to: ${targetFrameTime.toFixed(3)}s`);
                }
                // Cập nhật hiển thị số frame/giây ngay lập tức
                updateFrameDisplay(); 
            });

            // Update the display whenever the video time changes
            // This covers playback, seeking, and our custom scrolling
            videoPlayer.addEventListener('timeupdate', () => {
                if (!isScrubbing && !videoPlayer.paused) {
                    targetFrameTime = videoPlayer.currentTime;
                }
                updateFrameDisplay();
            });

            
            const usernameModal = document.getElementById('usernameModal'); const usernameInput = document.getElementById('usernameInput'); const usernameSubmitBtn = document.getElementById('usernameSubmitBtn'); const userInfoDisplay = document.getElementById('userInfo'); const teamworkPanelContainer = document.getElementById('teamworkPanelContainer'); const teamworkGrid = document.getElementById('teamworkGrid');
            let dresSessionId = sessionStorage.getItem('dresSessionId'); let dresEvaluationId = sessionStorage.getItem('dresEvaluationId'); let currentResponse = {}; let drawnBoxes = []; let isDrawing = false; let startX, startY, currentX, currentY; const PREDEFINED_OBJECTS = ['person', 'car', 'truck', 'dog', 'cat', 'cow', 'toaster']; const LABEL_SHORTCUTS = { '1': 'person', '2': 'car', '3': 'truck', '4': 'dog', '5': 'cat', '6': 'toaster'}; let focusedModelIndex = -1;

            function setupImageObserver() {
                if (imageObserver) {
                    imageObserver.disconnect();
                }
                const options = {
                    root: rightResultsPanel, 
                    rootMargin: '0px 0px 500px 0px', 
                    threshold: 0.01
                };
                imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target.querySelector('img.lazy-load');
                            if (img && img.dataset.src) {
                                img.src = img.dataset.src;
                                img.onload = () => img.classList.add('loaded');
                                observer.unobserve(entry.target);
                            }
                        }
                    });
                }, options);
            }
            
            // --- BƯỚC 4: THÊM EVENT DELEGATION CHO NÚT MICRO ---
            stagesContainer.addEventListener('click', (e) => {
                const micBtn = e.target.closest('.mic-btn');
                if (micBtn && recognition) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const stageCard = micBtn.closest('.stage-card');
                    
                    // ## BẮT ĐẦU SỬA ĐIỀU 2: LOGIC NHẬP LIỆU GIỌNG NÓI ##

                    // 1. Xác định ô input mục tiêu một cách thông minh.
                    // Ưu tiên ô đang được focus trong stage hiện tại.
                    let targetInput = stageCard.querySelector('.main-query-input'); // Mặc định
                    const activeEl = document.activeElement;
                    // Kiểm tra xem có phần tử nào đang được focus không, và nó có nằm trong stage card này không
                    if (activeEl && stageCard.contains(activeEl) && (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT')) {
                        targetInput = activeEl; // Nếu có, đó chính là mục tiêu của chúng ta
                    }

                    // 2. Xóa bỏ logic cũ tự động chuyển sang tab "Text".
                    // Điều này cho phép ghi âm vào các ô filter như OCR, ASR.
                    /* 
                    // ĐOẠN CODE CŨ BỊ XÓA:
                    const textTypeBtn = stageCard.querySelector('.type-btn[data-type="text"]');
                    if (!textTypeBtn.classList.contains('active')) {
                        textTypeBtn.click();
                    }
                    */

                    // 3. Sử dụng `targetInput` đã được xác định chính xác để xử lý ghi âm.
                    if (isRecording) {
                        if (activeSpeechInput === targetInput) {
                            // Nếu đang ghi âm đúng ô này thì dừng lại
                            recognition.stop();
                        } else { 
                            // Nếu đang ghi âm ở ô khác, dừng cái cũ và bắt đầu cái mới
                            recognition.stop();
                            setTimeout(() => {
                                activeSpeechInput = targetInput;
                                targetInput.value = ''; // Xóa sạch ô input khi chuyển đổi
                                recognition.start();
                            }, 250); // Đợi một chút để recognition dừng hẳn
                        }
                    } else {
                        // Nếu chưa ghi âm, bắt đầu ghi âm vào ô mục tiêu
                        activeSpeechInput = targetInput;
                        targetInput.value = ''; 
                        targetInput.focus();
                        recognition.start();
                    }
                    // ## KẾT THÚC SỬA ĐIỀU 2 ##
                }
            });
            // --- KẾT THÚC EVENT DELEGATION ---
            
            submitCurrentFrameBtn.addEventListener('click', () => {
                if (videoPreviewModal.style.display === 'flex' && currentVideoPreviewData) {
                    const currentTime = videoPlayer.currentTime;
                    const frameId = Math.round(currentTime * currentVideoPreviewData.fps);
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                    
                    const shotData = {
                        video_id: currentVideoPreviewData.videoId,
                        frame_id: frameId,
                        fps: currentVideoPreviewData.fps,
                        filepath: `dynamic-frame-${currentVideoPreviewData.videoId}-${frameId}`,
                        url: thumbnailUrl,
                        is_dynamic: true
                    };
                    pushToSubmissionPanel(shotData);
                } else {
                    alert("No active video context to push from.");
                }
            });

            pushCurrentFrameBtn.addEventListener('click', () => {
                if (videoPreviewModal.style.display === 'flex' && currentVideoPreviewData) {
                    const currentTime = videoPlayer.currentTime;
                    const frameId = Math.round(currentTime * currentVideoPreviewData.fps);
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                    const shotData = {
                        video_id: currentVideoPreviewData.videoId,
                        frame_id: frameId,
                        fps: currentVideoPreviewData.fps,
                        filepath: `dynamic-frame-${currentVideoPreviewData.videoId}-${frameId}`,
                        url: thumbnailUrl,
                        is_dynamic: true
                    };
                    console.log("--- [Video Player Push to Teamwork] ---");
                    console.log(`Video ID: ${shotData.video_id}`);
                    console.log(`Current Time: ${currentTime.toFixed(4)}s`);
                    console.log(`Video FPS: ${shotData.fps}`);
                    console.log(`Calculated Frame ID: ${shotData.frame_id}`);
                    console.log("Pushing shotData object:", shotData);
                    console.log("---------------------------------------");
                    pushToTeamworkPanel(shotData);
                } else {
                    alert("No active video context to push from. Please open a video preview first.");
                    console.error("Push button clicked, but 'currentVideoPreviewData' is missing.");
                }
            });

            rightResultsPanel.addEventListener('scroll', () => {
                if (rightResultsPanel.scrollTop + rightResultsPanel.clientHeight >= rightResultsPanel.scrollHeight - 500) {
                    loadMoreResults();
                }
            });

            async function handleGoogleImageAction(url, action, buttonEl) {
                if (!url || !action) return;
                const originalIcon = buttonEl.innerHTML;
                buttonEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                buttonEl.disabled = true;

                try {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to download image');
                    }
                    const imageData = await downloadResponse.json();
                    
                    if (action === 'search') {
                        addStageToStart();
                        const newStage = stagesContainer.querySelector('.stage-card');
                        if (newStage) {
                            newStage.querySelector('.type-btn[data-type="image"]')?.click();
                            const previewImage = newStage.querySelector('.image-preview');
                            const uploadInstructions = newStage.querySelector('.upload-instructions');
                            const removeImageBtn = newStage.querySelector('.remove-image-btn');
                            
                            newStage.tempImageName = imageData.temp_image_name;
                            previewImage.src = imageData.url;
                            previewImage.style.display = 'block';
                            uploadInstructions.style.display = 'none';
                            removeImageBtn.style.display = 'flex';
                            handleSearch();
                        }
                    } else if (action === 'push') {
                        const shotData = {
                            filepath: imageData.filepath,
                            url: imageData.url,
                            video_id: 'N/A',
                            shot_id: 'N/A',
                            frame_id: 'N/A'
                        };
                        pushToTeamworkPanel(shotData);
                    }

                } catch (error) {
                    console.error(`Google Image Action [${action}] failed:`, error);
                    alert(`Error: ${error.message}`);
                } finally {
                    buttonEl.innerHTML = originalIcon;
                    buttonEl.disabled = false;
                }
            }

            function displayGoogleImages(urls) {
                googleResultsContainer.innerHTML = '';
                if (urls.length === 0) {
                    googleResultsContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9rem;">No images found.</p>';
                    return;
                }
                urls.forEach(url => {
                    const item = document.createElement('div');
                    item.className = 'google-image-item';
                    item.innerHTML = `<img src="${url}" loading="lazy" onerror="this.parentElement.style.display='none'">`;
                    item.title = "Click: Zoom\nCtrl+Shift+Click: Similarity Search";

                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (e.ctrlKey && e.shiftKey) {
                            const fakeShotData = {
                                url: url,
                                filepath: `google-image-${Date.now()}.jpg`,
                                is_external: true
                            };
                            performImageSearchFromClick(fakeShotData);
                        } else {
                            handleGoogleImageAction(url, 'zoom', item);
                        }
                    });

                    item.addEventListener("mouseenter", () => {
                        currentlyHoveredItemData = { external_url: url };
                        currentlyHoveredItemElement = item;
                    });
                    item.addEventListener("mouseleave", () => {
                        currentlyHoveredItemData = null;
                        currentlyHoveredItemElement = null;
                    });

                    googleResultsContainer.appendChild(item);
                });
            }

            async function fetchGoogleImages() {
                const query = googleSearchInput.value.trim();
                if (!query) return;

                googleResultsWrapper.style.display = 'block';
                googleResultsContainer.innerHTML = '<i class="fas fa-spinner fa-spin" style="font-size: 1.5rem; margin: auto;"></i>';
                
                try {
                    const response = await fetch('/google_image_search', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ query })
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Search failed');
                    }
                    const data = await response.json();
                    displayGoogleImages(data.image_urls || []);
                } catch (error) {
                    googleResultsContainer.innerHTML = `<p style="color: #ef4444;">Error: ${error.message}</p>`;
                }
            }

            googleSearchBtn.addEventListener('click', fetchGoogleImages);
            googleSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation(); 
                    fetchGoogleImages();
                }
            });
            
            function djb2(str) { let hash = 5381; for (let i = 0; i < str.length; i++) { hash = ((hash << 5) + hash) + str.charCodeAt(i); } return hash; }
            function generateColor(str) { const hash = djb2(str); const h = hash % 360; const s = ((hash >> 8) % 31) + 70; const l = ((hash >> 16) % 21) + 50; return `hsl(${h}, ${s}%, ${l}%)`; }
            function createResultItem(data, source = 'main') {
                const isTeamworkItem = source === 'teamwork';
                const isSubmissionItem = source === 'trake' || source === 'submission';
                
                const shot = data.shot ? data.shot : data;
                const user = data.user ? data.user : null;
                if (!shot || !shot.url) return null;

                const item = document.createElement('div');
                item.className = 'result-item';
                item.dataset.source = source;
                item.dataset.filepath = shot.filepath;
                item.dataset.videoId = shot.video_id;
                item.dataset.shotId = shot.shot_id;
                item.dataset.frameId = shot.frame_id;

                const isLazy = source === 'main';
                const srcAttribute = isLazy ? `data-src="${shot.url}"` : `src="${shot.url}"`;
                const imgClass = isLazy ? 'lazy-load' : 'loaded';

                let title = '';
                let itemHTML = `<img class="${imgClass}" ${srcAttribute} alt="Frame" loading="lazy" decoding="async" />`;
                let actionsHTML = '';
                let answerHTML = '';
                if (isSubmissionItem && shot.answer != null && shot.answer !== '') {
                    // Using encodeURIComponent to prevent issues with quotes in the title attribute
                    const encodedAnswer = shot.answer.replace(/"/g, '&quot;');
                    answerHTML = `<div class="qa-answer-label" title="Answer: ${encodedAnswer}">${shot.answer}</div>`;
                }

                if (isTeamworkItem) {
                    item.classList.add('teamwork-item');
                    item.style.setProperty('--user-color', user.color);
                    title = `Pushed by: ${user.name}\nClick: Submit | Ctrl+Click: Submit Direct`;
                    actionsHTML = `
                        <button class="submit-btn" title="Click: Submit | Ctrl+Click: Submit Direct"><i class="fas fa-paper-plane"></i></button>
                        <div class="teamwork-item-user-label">${user.name}</div>
                    `;
                } else if (isSubmissionItem) {
                    item.draggable = true;
                    item.shotData = shot; 
                    title = `Video: ${shot.video_id}\nFrame: ${shot.frame_id}\nDrag to reorder.`;
                    actionsHTML = `
                        <div class="trake-item-actions">
                            <button class="trake-action-btn nearby-frames-btn" title="Show Nearby Frames"><i class="fas fa-layer-group"></i></button>
                            <button class="trake-action-btn remove-trake-btn" title="Remove from Trake"><i class="fas fa-times"></i></button>
                        </div>`;
                } else { // This 'else' now ONLY applies to 'main' results
                    title = `Click: Zoom\nRight-Click: Video Preview\nCtrl+Click: View Context`;
                    const score = shot.rrf_score || shot.cluster_score || shot.score || shot.average_rff_score || shot.combined_score;
                    if (score) title += `\nScore: ${score.toFixed(4)}`;
                    
                }

                item.innerHTML = itemHTML + actionsHTML + answerHTML;
                item.querySelector('img').title = title;

                item.addEventListener("click", e => handleBaseItemClick(e, shot, source));
                item.addEventListener("contextmenu", e => handleBaseItemClick(e, shot, source));

                const submitBtn = item.querySelector(".submit-btn");
                if (submitBtn) submitBtn.addEventListener("click", e => handleFrameInteraction(e, shot, source));

                const removesubmissionBtn = item.querySelector(".remove-trake-btn");
                    if(removesubmissionBtn) removesubmissionBtn.addEventListener("click", e => {
                        e.stopPropagation();
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'submission_panel_remove', // <-- CORRECTED
                                data: {
                                    filepath: item.dataset.filepath,
                                    task_name: activeTaskName
                                }
                            }));
                        }
                    });
                
                const nearbyFramesBtn = item.querySelector(".nearby-frames-btn");
                if(nearbyFramesBtn) nearbyFramesBtn.addEventListener("click", handleNearbyFramesClick);

                item.addEventListener("mouseenter", () => { currentlyHoveredItemData = shot; currentlyHoveredItemElement = item; });
                item.addEventListener("mouseleave", () => { currentlyHoveredItemData = null; currentlyHoveredItemElement = null; });

                return item;
            }
            function createContextItem(shotData) {
                // This function is ONLY for the context view.
                // It creates the simple, original HTML structure with NO buttons.
                const item = document.createElement('div');
                item.className = 'result-item temporal-grid-item'; // Add both classes for correct styling
                
                item.dataset.filepath = shotData.filepath;
                item.dataset.videoId = shotData.video_id;
                item.dataset.shotId = shotData.shot_id; // Added for consistency
                item.dataset.frameId = shotData.frame_id;

                // The original simple HTML structure.
                item.innerHTML = `<img class="loaded" src="${shotData.url}" alt="Context Frame" loading="lazy" decoding="async" />`;
                
                // --- THIS IS THE KEY ---
                // We re-add the standard event listeners that make the shortcuts work.
                // These were missing or incorrectly implemented in my previous attempts.
                item.addEventListener("mouseenter", () => {
                    currentlyHoveredItemData = shotData;
                    currentlyHoveredItemElement = item;
                });
                item.addEventListener("mouseleave", () => {
                    currentlyHoveredItemData = null;
                    currentlyHoveredItemElement = null;
                });

                // Attach the original event handlers for zoom and video preview
                item.addEventListener("click", e => handleBaseItemClick(e, shotData, 'context'));
                item.addEventListener("contextmenu", e => handleBaseItemClick(e, shotData, 'context'));

                return item;
            }

            function initWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

                let reconnectDelay = 1000;

                ws.onopen = () => {
                    console.log('WebSocket connection established.');
                    teamworkPanelContainer.style.display = 'block';
                    reconnectDelay = 1000;
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    const type = message.type;
                    const data = message.data;

                    // --- Teamwork Panel ---
                    if (type === 'new_frame') {
                        const newItem = createResultItem(data, 'teamwork');
                        if (newItem) teamworkGrid.prepend(newItem);
                    } else if (type === 'remove_frame') {
                        const itemToRemove = teamworkGrid.querySelector(`.result-item[data-filepath="${data.filepath}"]`);
                        if (itemToRemove) itemToRemove.remove();
                    } else if (type === 'clear_panel') {
                        teamworkGrid.innerHTML = '';
                        pushedFrames.clear();
                        if (message.status === 'success' && lastSuccessfulSubmission) {
                            pushToTeamworkPanel(lastSuccessfulSubmission);
                            lastSuccessfulSubmission = null;
                        }
                    }
                    // --- START: NEW SUBMISSION PANEL LOGIC ---
                    else if (type === 'submission_panel_clear') {
                        const submissionGrid = document.getElementById('submissionGrid');
                        // When the server tells us to clear, we do, and we show a spinner.
                        submissionGrid.innerHTML = '<i class="fas fa-spinner fa-spin" style="font-size: 1.5rem; margin: auto;"></i>';
                    
                    } else if (type === 'submission_panel_chunk_load') {
                        const submissionGrid = document.getElementById('submissionGrid');
                        
                        // If the grid contains the spinner, remove it before adding the first chunk.
                        if (submissionGrid.querySelector('.fa-spinner')) {
                            submissionGrid.innerHTML = '';
                        }

                        const fragment = document.createDocumentFragment();
                        data.forEach(shot => {
                            const submissionItem = createResultItem(shot, 'submission');
                            if (submissionItem) fragment.appendChild(submissionItem);
                        });
                        submissionGrid.appendChild(fragment); // Append the new chunk of items

                    } else if (type === 'submission_panel_add') {
                        // This handles adding a SINGLE item pushed by any user in real-time.
                        const submissionGrid = document.getElementById('submissionGrid');
                        const shot_data = message.data.shot; // Correct JavaScript syntax
                        
                        // Double-check for duplicates on the client side
                        if (shot_data && !submissionGrid.querySelector(`.result-item[data-filepath="${shot_data.filepath}"]`)) {
                            const submissionItem = createResultItem(shot_data, 'submission');
                            if (submissionItem) submissionGrid.appendChild(submissionItem);
                        }

                    } else if (type === 'submission_panel_remove') {
                        const submissionGrid = document.getElementById('submissionGrid');
                        const itemToRemove = submissionGrid.querySelector(`.result-item[data-filepath="${data.filepath}"]`);
                        if (itemToRemove) itemToRemove.remove();

                    } else if (type === 'submission_panel_sync') {
                        const updatedTaskName = message.task_name;
                        if (updatedTaskName === activeTaskName) {
                            const submissionGrid = document.getElementById('submissionGrid');
                            submissionGrid.innerHTML = '';
                            if (message.data && message.data.length > 0) {
                                message.data.forEach(shot => {
                                    const submissionItem = createResultItem(shot, 'submission');
                                    if (submissionItem) submissionGrid.appendChild(submissionItem);
                                });
                            } else {
                                // --- NEW: Show a helpful message for empty panels ---
                                submissionGrid.innerHTML = `<p style="color: var(--text-secondary); margin: auto; font-style: italic;">Panel is empty. Push frames using Ctrl+Shift+Space.</p>`;
                            }
                        }

                    } else if (type === 'submission_panel_submission_status') {
                        showToast(data.message, 3000, data.status);
                    }
                }
                    // --- END: NEW SUBMISSION PANEL LOGIC ---
                ws.onclose = () => {
                    console.log('WebSocket connection closed. Retrying in', reconnectDelay, 'ms');
                    setTimeout(() => {
                        reconnectDelay = Math.min(reconnectDelay * 2, 30000); // Exponential backoff
                        initWebSocket();
                    }, reconnectDelay);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            
            function setupUser() {
                username = sessionStorage.getItem('username');
                userColor = sessionStorage.getItem('userColor');
                if (!username) {
                    usernameModal.style.display = 'flex';
                    usernameInput.focus();
                } else {
                    usernameModal.style.display = 'none';
                    userInfoDisplay.textContent = `User: ${username}`;
                    userInfoDisplay.style.color = userColor;
                    initWebSocket();
                }
            }
            usernameSubmitBtn.addEventListener('click', () => { const name = usernameInput.value.trim(); if (name) { sessionStorage.setItem('username', name); sessionStorage.setItem('userColor', generateColor(name)); setupUser(); } });
            usernameInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') usernameSubmitBtn.click(); });
            function pushToTeamworkPanel(shotData) {
                if (!shotData || !shotData.filepath) { console.error("Attempted to push invalid shot data:", shotData); return; }
                if (pushedFrames.has(shotData.filepath)) { console.log("This frame has already been pushed."); return; }
                if (!ws || ws.readyState !== WebSocket.OPEN) { alert("Teamwork connection is not available."); return; }
                pushedFrames.add(shotData.filepath);
                const payload = { type: 'new_frame', data: { shot: shotData, user: { name: username, color: userColor } } };
                ws.send(JSON.stringify(payload));
                console.log("Pushed to teamwork panel:", shotData.filepath);
            }

        async function handleSubmitToDRES(shot, bypassConfirmation = false) {
            // === PHASE 1: PRE-SUBMISSION VALIDATION ===

            // 1. Check DRES login status.
            if (!dresSessionId || !dresEvaluationId) {
                showToast("Please log in to DRES first!", 3000, 'error');
                dresModal.style.display = 'flex';
                return;
            }

            // 2. Validate the incoming shot data.
            if (!shot || shot.frame_id === undefined || !shot.video_id || !shot.url) {
                console.error("Invalid or incomplete shot data for submission.", shot);
                showToast("Error: Invalid data for submission.", 4000, 'error');
                return;
            }

            // 3. Create a reliable, unique key for the frame to track its submission status.
            const submissionKey = `${shot.video_id}-${shot.frame_id}`;

            // 4. Prevent re-submission if the frame has already been processed.
            const submissionStatus = submittedFrames.get(submissionKey);
            if (submissionStatus && submissionStatus !== 'PENDING') {
                showToast(`Already submitted! Status: ${submissionStatus}`, 3000, 'warning');
                return;
            }
            if (submissionStatus === 'PENDING') {
                showToast("Submission for this frame is already in progress...", 2000, 'info');
                return;
            }

            // === PHASE 2: SUBMISSION EXECUTION & UI FEEDBACK ===

            // Find the corresponding UI element (this will be null for video player submissions, which is expected).
            const itemElement = document.querySelector(`.result-item[data-filepath="${shot.filepath}"]`);

            try {
                // Set state to 'PENDING' to prevent race conditions and provide immediate feedback.
                submittedFrames.set(submissionKey, 'PENDING');
                showSubmissionStatusOnItem(itemElement, 'pending', 'Submitting...');

                // Perform the API call to the DRES server.
                const response = await fetch('/dres/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: dresSessionId,
                        evaluationId: dresEvaluationId,
                        video_id: shot.video_id,
                        filepath: shot.filepath,
                        frame_id: shot.frame_id
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.detail || 'Submission request failed');
                }

                // === PHASE 3: PROCESS RESULT & FINALIZE UI ===
                
                const resultText = result.description.toUpperCase();
                let finalStatus = 'UNKNOWN';

                if (resultText.includes('CORRECT')) {
                    finalStatus = 'CORRECT';
                    submittedFrames.set(submissionKey, finalStatus);
                    
                    showSubmissionStatusOnItem(itemElement, 'correct', 'CORRECT');
                    showToast('CORRECT! Great find!', 3000, 'success');

                    // === PHẦN SỬA LỖI LOGIC HIỂN THỊ ===
                    // 1. Lấy tham chiếu đến cả panel LỚN và container BÊN TRONG
                    const correctSubmissionPanel = document.getElementById('correctSubmissionPanel');
                    const correctSubmissionContainer = document.getElementById('correctSubmissionImageContainer');
                    
                    // 2. Dọn dẹp container và tạo item ảnh mới
                    correctSubmissionContainer.innerHTML = '';
                    const correctItem = createResultItem(shot, 'correct-submission');

                    // 3. Kiểm tra mọi thứ tồn tại trước khi hành động
                    if (correctItem && correctSubmissionContainer && correctSubmissionPanel) {
                        // Đặt ảnh vào container
                        correctSubmissionContainer.appendChild(correctItem);
                        
                        // **DÒNG QUAN TRỌNG NHẤT:** Bật hiển thị cho cả panel lớn
                        correctSubmissionPanel.style.display = 'flex'; 
                    }
                    // === KẾT THÚC PHẦN SỬA LỖI ===

                    // Lưu lại lượt nộp thành công để có thể push lại sau khi reset
                    lastSuccessfulSubmission = shot;

                    // Xóa panel teamwork cho tất cả user
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Gửi thông điệp kèm theo trạng thái thành công để server có thể xử lý logic push lại
                        ws.send(JSON.stringify({"type": "clear_panel", "status": "success"}));
                    }

                } else if (resultText.includes('WRONG')) {
                    finalStatus = 'WRONG';
                    submittedFrames.set(submissionKey, finalStatus);
                    
                    showSubmissionStatusOnItem(itemElement, 'wrong', 'WRONG');
                    showToast('Wrong submission. Keep trying!', 3000, 'error');
                    if (itemElement) itemElement.classList.add('submitted-wrong');

                } else if (resultText.includes('DUPLICATE')) {
                    finalStatus = 'DUPLICATE';
                    submittedFrames.set(submissionKey, finalStatus);

                    showSubmissionStatusOnItem(itemElement, 'duplicate', 'DUPLICATE');
                    showToast('Duplicate submission. Already noted.', 3000, 'warning');
                    if (itemElement) itemElement.classList.add('submitted-duplicate');
                
                } else {
                    // Handle any other response from DRES.
                    finalStatus = result.description;
                    showToast(`Status: ${result.description}`, 3000, 'info');
                }

            } catch (error) {
                // === PHASE 4: ERROR HANDLING ===
                
                // Provide clear feedback to the user about the failure.
                showSubmissionStatusOnItem(itemElement, 'wrong', 'Error');
                showToast(error.message, 4000, 'error');
                
                // CRITICAL: Reset the submission state on failure to allow the user to retry.
                submittedFrames.delete(submissionKey);
                
                console.error("DRES Submission failed:", error);

            } finally {
                // === PHASE 5: CLEANUP ===
                
                // The overlay logic now handles hiding itself, but this class could be used for other effects.
                if (itemElement) {
                    itemElement.classList.remove('submitting');
                }
            }
        }

            function showToast(message, duration = 3000, type = 'info') {
                const toast = document.createElement('div');
                
                let backgroundStyle = '';
                let iconHTML = '';

                switch (type) {
                    case 'success':
                        backgroundStyle = 'linear-gradient(135deg, #28a745 0%, #218838 100%)';
                        iconHTML = '<i class="fas fa-check-circle" style="margin-right: 10px;"></i>';
                        break;
                    case 'error':
                        backgroundStyle = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                        iconHTML = '<i class="fas fa-times-circle" style="margin-right: 10px;"></i>';
                        break;
                    case 'warning':
                        backgroundStyle = 'linear-gradient(135deg, #ffc107 0%, #e0a800 100%)';
                        iconHTML = '<i class="fas fa-exclamation-triangle" style="margin-right: 10px;"></i>';
                        break;
                    default: // 'info'
                        backgroundStyle = 'var(--primary-gradient)';
                        iconHTML = '<i class="fas fa-info-circle" style="margin-right: 10px;"></i>';
                        break;
                }

                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${backgroundStyle};
                    color: white;
                    padding: 14px 22px;
                    border-radius: 8px;
                    box-shadow: var(--shadow-heavy);
                    z-index: 10000;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                `;
                
                toast.innerHTML = `${iconHTML}<span>${message}</span>`;
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards';
                    toast.addEventListener('animationend', () => toast.remove());
                }, duration);
            }

            function showSubmissionStatusOnItem(itemElement, status, message) {
                if (!itemElement) return;

                // Tìm hoặc tạo overlay
                let overlay = itemElement.querySelector('.submission-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'submission-overlay';
                    itemElement.appendChild(overlay);
                }

                // Thiết lập icon và nội dung dựa trên trạng thái
                let iconClass = '';
                switch (status) {
                    case 'pending':   iconClass = 'fas fa-spinner fa-spin'; break;
                    case 'correct':   iconClass = 'fas fa-check-circle'; break;
                    case 'wrong':     iconClass = 'fas fa-times-circle'; break;
                    case 'duplicate': iconClass = 'fas fa-exclamation-triangle'; break;
                }
                
                overlay.innerHTML = `<i class="${iconClass}"></i><span>${message}</span>`;

                // Cập nhật class để thay đổi màu sắc và hiển thị
                overlay.className = 'submission-overlay'; // Reset class
                overlay.classList.add(`status-${status}`);
                overlay.classList.add('visible');

                // Tự động ẩn đi sau một khoảng thời gian (trừ trạng thái pending)
                if (status !== 'pending') {
                    setTimeout(() => {
                        overlay.classList.remove('visible');
                    }, 2500); // Overlay sẽ hiển thị trong 2.5 giây
                }
            }

            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);

            async function handleGoogleImageAction(url, action, element) {
                if (!url || !action) return;

                if (action === 'zoom') {
                    imageModal.style.display = "flex";
                    zoomedImage.src = url;
                    return;
                }
                
                element.style.cursor = 'wait';
                try {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to prepare image');
                    }
                    const imageData = await downloadResponse.json();
                    
                    const shotData = {
                        filepath: imageData.filepath,
                        url: imageData.url,
                        video_id: 'N/A',
                        shot_id: 'N/A',
                        frame_id: 'N/A',
                        external_url: url
                    };

                    if (action === 'search') {
                        addStageToStart();
                        const newStage = stagesContainer.querySelector('.stage-card');
                        if (newStage) {
                            newStage.querySelector('.type-btn[data-type="image"]')?.click();
                            const previewImage = newStage.querySelector('.image-preview');
                            const uploadInstructions = newStage.querySelector('.upload-instructions');
                            const removeImageBtn = newStage.querySelector('.remove-image-btn');
                            newStage.tempImageName = imageData.temp_image_name;
                            previewImage.src = imageData.url;
                            previewImage.style.display = 'block';
                            uploadInstructions.style.display = 'none';
                            removeImageBtn.style.display = 'flex';
                            handleSearch();
                        }
                    } else if (action === 'push') {
                        pushToTeamworkPanel(shotData);
                    } else if (action === 'submit') {
                        handleSubmitToDRES(shotData, true);
                    }

                } catch (error) {
                    console.error(`Google Image Action [${action}] failed:`, error);
                    alert(`Error: ${error.message}`);
                } finally {
                    element.style.cursor = 'pointer';
                }
            }
            function handleFrameInteraction(event, shotData, source) {
                event.preventDefault();
                event.stopPropagation();
                if (source === 'teamwork') {
                    const isCtrl = event.ctrlKey || event.metaKey;
                    handleSubmitToDRES(shotData, isCtrl);
                }
            }
            function handleBaseItemClick(event, shotData, source) {
                event.preventDefault();
                event.stopPropagation();
                
                if (event.ctrlKey && event.shiftKey) {
                    performImageSearchFromClick(shotData);
                } 
                else if (event.type === 'contextmenu') {
                    openVideoPreview(shotData); 
                } 
                else if (event.ctrlKey || event.metaKey) {
                    openTemporalContextView(shotData);
                }
                else {
                    imageModal.style.display = "flex";
                    zoomedImage.src = shotData.url;
                }
            }
            let fpsCache = new Map(); 

            async function openVideoPreview(shotData) {
                if (!shotData || !shotData.video_id || !shotData.filepath) {
                    alert("Error: Invalid data for video preview (missing video_id or filepath).");
                    return;
                }
                const frameId = shotData.frame_id;
                if (frameId === null || frameId === undefined) {
                    alert(`Error: Frame ID is missing for this result.`);
                    return;
                }
                
                document.body.classList.add('video-modal-active'); // THÊM DÒNG NÀY

                videoPreviewModal.style.display = "flex";
                videoPlayer.pause();
                videoPlayer.src = "";
                currentVideoPreviewData = null;
                //... (phần còn lại của hàm giữ nguyên)
                try {
                    let fps = fpsCache.get(shotData.video_id);
                    if (!fps) {
                        const infoResponse = await fetch(`/video_info/${shotData.video_id}`);
                        if (!infoResponse.ok) throw new Error(`Could not fetch video info (status: ${infoResponse.status})`);
                        const videoInfo = await infoResponse.json();
                        fps = videoInfo.fps;
                        fpsCache.set(shotData.video_id, fps);
                    }
                    currentVideoPreviewData = { videoId: shotData.video_id, fps };
                    const startTime = frameId / fps;
                    targetFrameTime = startTime;
                    const videoUrl = `/videos/${shotData.video_id}`;
                    videoPlayer.src = videoUrl;
                    videoPlayer.addEventListener('loadedmetadata', () => {
                        if (isFinite(startTime) && startTime < videoPlayer.duration) {
                            videoPlayer.currentTime = startTime;
                            // QUAN TRỌNG: Đồng bộ target time khi mở video lần đầu
                            targetFrameTime = startTime; 
                        }
                        updateFrameDisplay();
                    }, { once: true });
                    videoPlayer.load();
                } catch (error) {
                    console.error("Error setting up video preview:", error);
                    alert("Error loading video preview: " + error.message);
                    currentVideoPreviewData = null;
                }
            }

            async function openTemporalContextView(e){
                if(!e||!e.filepath)return void alert("Error: Invalid data for context view.");
                if (e.is_dynamic) { alert("Temporal context view is not available for frames pushed directly from the video player."); return; }
                temporalModalTitle.textContent=`Loading context for Video: ${e.video_id}, Frame: ${e.frame_id}...`;
                temporalGrid.innerHTML='<p style="color: white; text-align: center; padding: 20px;">Checking available frames...</p>';
                temporalContextModal.style.display="flex";
                try{
                    const t=await fetch("/check_temporal_frames",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({base_filepath:e.filepath})});
                    if(!t.ok){const o=await t.json();throw new Error(o.detail||"Failed to check frames.")}
                    const o=await t.json();
                    if(0===o.length)return void(temporalGrid.innerHTML='<p style="color: #ffcccc; text-align: center;">No context frames found.</p>');
                    temporalModalTitle.textContent=`Frame Context – Video: ${e.video_id||"N/A"}, Frame: ${e.frame_id||"N/A"}`;
                    temporalGrid.innerHTML="";
                    const r=e.filepath.match(/_(\d+)\./),s=r?parseInt(r[1],10):null;
                    o.forEach(t=>{
                        const frame_id_match = t.match(/_(\d+)\.[^.]+$/);
                        const temporalShotItem = createContextItem({
                            url: `/images/${urlSafeB64Encode(t)}`,
                            filepath: t,
                            video_id: e.video_id,
                            shot_id: e.shot_id,
                            frame_id: frame_id_match ? parseInt(frame_id_match[1], 10) : null
                        }, 'context');
                        if(temporalShotItem) {
                            temporalShotItem.classList.add('temporal-grid-item');
                            const label = document.createElement('div');
                            label.className = 'temporal-item-label';
                            const a = t.match(/_(\d+)\./);
                            if (a && s !== null) {
                                const l = parseInt(a[1], 10) - s;
                                label.textContent = l > 0 ? `+${l}` : `${l}`;
                                if (l === 0) temporalShotItem.classList.add("center-frame");
                            }
                            temporalShotItem.prepend(label);
                            temporalGrid.appendChild(temporalShotItem);
                        }
                    })
                } catch(t) { console.error("Error loading context view:",t),temporalGrid.innerHTML=`<p style="color: #ffcccc; text-align: center;">Error: ${t.message}</p>` }
            }
            
            function displayResults(data, append = false) {
                const fragment = document.createDocumentFragment();

                if (!append) {
                    resultsContainer.innerHTML = "";
                    if (imageObserver) imageObserver.disconnect();
                    setupImageObserver();
                }

                const moreLoader = document.getElementById('moreLoader');
                if (moreLoader) moreLoader.remove();

                if (!Array.isArray(data) || data.length === 0) {
                    if (!append) resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Không tìm thấy kết quả.</p>';
                    return;
                }

                const isClusteredMode = clusterBtn.classList.contains("active");
                const createGridWithItems = (items) => {
                    const gridFragment = document.createDocumentFragment();
                    const grid = document.createElement('div');
                    grid.className = 'results-grid';
                    items.forEach(shot => {
                        const itemElement = createResultItem(shot, 'main');
                        if (itemElement) {
                            grid.appendChild(itemElement);
                            if (imageObserver) imageObserver.observe(itemElement);
                        }
                    });
                    gridFragment.appendChild(grid);
                    return gridFragment;
                };

                const isTemporalSearch = currentResponse.is_temporal_search;
                const isAmbiguousSearch = currentResponse.is_ambiguous_search;

                if (isTemporalSearch || isAmbiguousSearch) {
                    data.forEach((sequence, seqIndex) => {
                        const sequenceContainer = document.createElement('div');
                        const sequenceHeader = document.createElement("div");
                        sequenceHeader.className = "sequence-header";
                        const headerText = isAmbiguousSearch ? `Ambiguous Match in Video: ${sequence.video_id || "N/A"}` : `Sequence ${seqIndex + 1 + ((currentPage - 1) * PAGE_SIZE)} (Video: ${sequence.video_id || "N/A"})`;
                        sequenceHeader.innerHTML = `<i class="fas fa-stream"></i> ${headerText}`;
                        sequenceContainer.appendChild(sequenceHeader);

                        if (isClusteredMode) {
                            (sequence.clusters || []).forEach((cluster) => {
                                const stageContainer = document.createElement('div');
                                const sortedShots = [...(cluster.shots || [])].sort((a, b) => (a.shot_id_int || 0) - (b.shot_id_int || 0) || (a.frame_id || 0) - (b.frame_id || 0));
                                stageContainer.appendChild(createGridWithItems(sortedShots));
                                sequenceContainer.appendChild(stageContainer);
                            });
                        } else {
                            sequenceContainer.appendChild(createGridWithItems(sequence.shots || []));
                        }
                        fragment.appendChild(sequenceContainer);
                        if (seqIndex < data.length - 1) {
                            const separator = document.createElement('hr');
                            separator.className = 'cluster-separator';
                            fragment.appendChild(separator);
                        }
                    });
                } else { 
                    if (isClusteredMode) {
                        data.forEach((cluster, index) => {
                            const newClusterContainer = document.createElement('div');
                            if (cluster.shots && cluster.shots.length > 0) {
                                const clusterHeader = document.createElement('h3');
                                clusterHeader.className = 'cluster-header';
                                clusterHeader.textContent = `Cluster from Video: ${cluster.shots[0].video_id}`;
                                newClusterContainer.appendChild(clusterHeader);
                            }
                            const sortedShots = [...(cluster.shots || [])].sort((a, b) => (a.shot_id_int || 0) - (b.shot_id_int || 0) || (a.frame_id || 0) - (b.frame_id || 0));
                            newClusterContainer.appendChild(createGridWithItems(sortedShots));
                            fragment.appendChild(newClusterContainer);
                            if (index < data.length - 1) {
                                const separator = document.createElement('hr');
                                separator.className = 'cluster-separator';
                                fragment.appendChild(separator);
                            }
                        });
                    } else {
                        const allShots = data.flatMap(item => item.shots ? item.shots : (item.best_shot ? [item.best_shot] : (item.filepath ? [item] : [])));
                        allShots.sort((a, b) => (b.rrf_score || 0) - (a.rrf_score || 0));
                        const uniqueShots = Array.from(new Map(allShots.filter(Boolean).map(shot => [shot.filepath, shot])).values());
                        
                        if (append) {
                            const grid = resultsContainer.querySelector('.results-grid');
                            if(grid) {
                                uniqueShots.forEach(shot => {
                                    const itemElement = createResultItem(shot, 'main');
                                    if (itemElement) {
                                        grid.appendChild(itemElement);
                                        if (imageObserver) imageObserver.observe(itemElement);
                                    }
                                });
                            }
                        } else {
                            fragment.appendChild(createGridWithItems(uniqueShots));
                        }
                    }
                }
                resultsContainer.appendChild(fragment);
            }

        async function performImageSearchFromClick(shot) {
            if (!shot || !shot.url || !shot.filepath) {
                alert("Dữ liệu không hợp lệ để tìm kiếm bằng hình ảnh.");
                return;
            }
            if (temporalContextModal.style.display === "flex") { temporalContextModal.style.display = "none"; }
            if (imageModal.style.display === "flex") { imageModal.style.display = "none"; }

            loadingIndicator.style.display = 'block';
            resultsContainer.innerHTML = '';
            
            try {
                let imageBlob;
                
                if (shot.is_external) {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url: shot.url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to prepare external image');
                    }
                    const imageData = await downloadResponse.json();
                    const localImageResponse = await fetch(imageData.url);
                    if (!localImageResponse.ok) {
                        throw new Error(`Không thể tải ảnh đã xử lý: ${localImageResponse.statusText}`);
                    }
                    imageBlob = await localImageResponse.blob();
                } else {
                    const response = await fetch(shot.url);
                    if (!response.ok) {
                        throw new Error(`Không thể tải ảnh: ${response.statusText}`);
                    }
                    imageBlob = await response.blob();
                }

                const filename = shot.filepath.split("/").pop() || "clicked-image.jpg";
                const imageFile = new File([imageBlob], filename, { type: imageBlob.type });
                await handleSearch(imageFile);

            } catch (error) {
                console.error("Lỗi khi tìm kiếm bằng ảnh từ click:", error);
                alert(`Đã xảy ra lỗi: ${error.message}`);
                loadingIndicator.style.display = 'none';
            }
        }
            function clearModelFocus() { modelDropdown.querySelectorAll('.model-dropdown-item').forEach(item => item.classList.remove('focused')); focusedModelIndex = -1; }
            function updateModelFocus() { const items = modelDropdown.querySelectorAll('.model-dropdown-item'); items.forEach((item, index) => { item.classList.toggle('focused', index === focusedModelIndex); }); }
            function focusOnStageInput(stageElement) { if (!stageElement) return; const input = stageElement.querySelector('.main-query-input'); if (input) { input.focus(); input.setSelectionRange(input.value.length, input.value.length); } }
            
            function createStageCard(number) {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                stageCard.dataset.stageNumber = number;
                const queryTypes = [{ id: 'text', icon: 'fas fa-font', label: 'Text (Ctrl+Alt+U)', type: 'primary' }, { id: 'image', icon: 'fas fa-image', label: 'Image (Ctrl+Alt+I)', type: 'primary' }, { id: 'ocr', icon: 'fas fa-text-height', label: 'OCR Filter (Ctrl+Alt+O)', type: 'filter' }, { id: 'asr', icon: 'fas fa-microphone', label: 'ASR Filter (Ctrl+Alt+P)', type: 'filter' }];
                
                // ## BẮT ĐẦU SỬA ĐIỀU 1: ĐỔI ICON ##
                // Đã đổi icon từ "fa-microphone" thành "fa-microphone-lines" để trực quan hơn.
                let typesHTML = queryTypes.map(type => `<button class="type-btn ${type.id === 'text' ? 'active' : ''}" data-type="${type.id}" data-basetype="${type.type}" title="${type.label}"><i class="${type.icon}"></i></button>`).join('') +
                                `<button class="type-btn mic-btn" title="Ghi âm giọng nói (Ctrl+Alt+M)"><i class="fas fa-headphones"></i></button>`;
                // ## KẾT THÚC SỬA ĐIỀU 1 ##
                
                stageCard.innerHTML = `
                    <div class="stage-number">${number}</div>
                    <button class="delete-stage" title="Delete Stage" style="display: ${stagesContainer.children.length > 0 ? 'flex' : 'none'}"><i class="fas fa-times"></i></button>
                    <div class="stage-header"><div class="query-types">${typesHTML}</div></div>
                    <div class="query-input-area">
                        <textarea class="stage-input main-query-input" placeholder="Nhập truy vấn tiếng Việt..." rows="3"></textarea>
                        <div class="processed-query-display-wrapper main-processed-query-wrapper">
                            <i class="fas fa-cogs" title="Processed Query"></i>
                            <span class="processed-query-display"></span>
                        </div>
                        <div class="image-search-container" style="display: none;">
                            <label for="file-input-${number}" class="image-upload-zone">
                                <div class="upload-instructions"><i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p></div>
                                <img class="image-preview" style="display: none;">
                                <button class="remove-image-btn" style="display: none;" title="Xóa ảnh"><i class="fas fa-times"></i></button>
                            </label>
                            <input type="file" id="file-input-${number}" class="stage-input-file" accept="image/*">
                            <input type="text" class="stage-input image-search-text-input" placeholder="Thêm mô tả văn bản cho ảnh (tùy chọn)..." style="margin-top: 10px;">
                            <div class="processed-query-display-wrapper image-processed-query-wrapper">
                                <i class="fas fa-cogs" title="Processed Image Text"></i>
                                <span class="processed-query-display"></span>
                            </div>
                        </div>
                        <div class="filter-input-wrapper" data-filter-type="ocr" style="display: none; margin-top: 10px;">
                            <input type="text" class="stage-input ocr-filter-input" placeholder="Lọc theo từ khóa OCR...">
                        </div>
                        <div class="filter-input-wrapper" data-filter-type="asr" style="display: none; margin-top: 10px;">
                            <input type="text" class="stage-input asr-filter-input" placeholder="Lọc theo từ khóa ASR...">
                        </div>
                    </div>
                    <div class="stage-options">
                        <button class="option-btn" data-option="enhance" title="Enhance Query (Ctrl+Q)">Enhance</button>
                        <button class="option-btn" data-option="bge_caption" title="Use BGE Caption Search (Ctrl+U)">Caption</button>
                    </div>`;

                const mainTextInput = stageCard.querySelector('.main-query-input');
                const imageSearchContainer = stageCard.querySelector('.image-search-container');
                const stageOptions = stageCard.querySelector('.stage-options');
                const imageUploadZone = stageCard.querySelector('.image-upload-zone');
                const mainProcessedWrapper = stageCard.querySelector('.main-processed-query-wrapper');
                
                stageCard.querySelectorAll('.type-btn:not(.mic-btn)').forEach(button => {
                    button.addEventListener('click', () => {
                        const type = button.dataset.type;
                        const baseType = button.dataset.basetype;

                        if (baseType === 'primary') {
                            stageCard.querySelectorAll('.type-btn[data-basetype="primary"]').forEach(btn => { if (btn !== button) btn.classList.remove('active'); });
                            button.classList.add('active');
                            
                            const isTextMode = type === 'text';
                            mainTextInput.style.display = isTextMode ? 'block' : 'none';
                            mainProcessedWrapper.style.display = isTextMode ? 'flex' : 'none';
                            imageSearchContainer.style.display = isTextMode ? 'none' : 'block';
                            stageOptions.style.display = isTextMode ? 'flex' : 'none';

                        } else {
                            button.classList.toggle('active');
                            const filterWrapper = stageCard.querySelector(`.filter-input-wrapper[data-filter-type="${type}"]`);
                            if (filterWrapper) {
                                filterWrapper.style.display = button.classList.contains('active') ? 'block' : 'none';
                                if (button.classList.contains('active')) { filterWrapper.querySelector('input').focus(); }
                            }
                        }
                        
                        const genImageBtn = stageCard.querySelector('.type-btn[data-type="gen_image"]');
                        if (genImageBtn && genImageBtn.classList.contains('active')) {
                            const textBtn = stageCard.querySelector('.type-btn[data-type="text"]');
                            if (!textBtn.classList.contains('active')) {
                                textBtn.click();
                            }
                        }
                    });
                });

                const handleFileSelect = async (file) => {
                    if (!file || !file.type.startsWith('image/')) return;
                    const previewImage = stageCard.querySelector('.image-preview');
                    const uploadInstructions = stageCard.querySelector('.upload-instructions');
                    const removeImageBtn = stageCard.querySelector('.remove-image-btn');

                    previewImage.src = URL.createObjectURL(file);
                    previewImage.style.display = 'block';
                    uploadInstructions.style.display = 'none';
                    removeImageBtn.style.display = 'none';

                    const formData = new FormData();
                    formData.append('image', file);

                    try {
                        const response = await fetch('/upload_image', { method: 'POST', body: formData });
                        if (!response.ok) throw new Error(`Upload failed: ${response.statusText}`);
                        const data = await response.json();
                        stageCard.tempImageName = data.temp_image_name;
                        removeImageBtn.style.display = 'flex';
                    } catch (error) {
                        console.error("Image upload error:", error);
                        alert("Lỗi upload ảnh. Vui lòng thử lại.");
                        previewImage.style.display = 'none';
                        uploadInstructions.innerHTML = `<i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p>`;
                        uploadInstructions.style.display = 'block';
                        removeImageBtn.style.display = 'none';
                        delete stageCard.tempImageName;
                    }
                };

                
                stageCard.querySelector('.remove-image-btn').addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); stageCard.querySelector('.stage-input-file').value = ''; const previewImage = stageCard.querySelector('.image-preview'); const uploadInstructions = stageCard.querySelector('.upload-instructions'); const removeImageBtn = stageCard.querySelector('.remove-image-btn'); previewImage.src = ''; previewImage.style.display = 'none'; uploadInstructions.innerHTML = `<i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p>`; uploadInstructions.style.display = 'block'; removeImageBtn.style.display = 'none'; delete stageCard.tempImageName; });
                stageCard.querySelector('.stage-input-file').addEventListener('change', e => handleFileSelect(e.target.files[0]));
                imageUploadZone.addEventListener('dragover', e => { e.preventDefault(); imageUploadZone.classList.add('dragover'); });
                imageUploadZone.addEventListener('dragleave', e => { e.preventDefault(); imageUploadZone.classList.remove('dragover'); });
                imageUploadZone.addEventListener('drop', e => { e.preventDefault(); imageUploadZone.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files[0]); });
                stageCard.querySelector('.delete-stage')?.addEventListener('click', () => { stageCard.remove(); renumberStages(); });
                stageCard.querySelectorAll('.option-btn').forEach(button => {
                    if (button.dataset.option !== 'expand') {
                        button.addEventListener('click', () => {
                            button.classList.toggle('active');
                        });
                    }
                });
                return stageCard;
            }

            async function handleSearch(imageFileFromClick = null) {
                const clientStartTime = performance.now();
                currentPage = 1;
                isLoadingMore = false;
                lastSearchPayload = null;

                loadingIndicator.style.display = 'block';
                resultsContainer.innerHTML = '';
                document.getElementById('timingInfoDisplay').style.display = 'none';
                currentResponse = {};
                pushedFrames.clear();

                const allStages = Array.from(stagesContainer.querySelectorAll('.stage-card'));

                allStages.forEach(stage => {
                    const displayWrapper = stage.querySelector('.main-processed-query-wrapper');
                    if (displayWrapper) {
                        displayWrapper.style.display = 'none';
                        displayWrapper.querySelector('.processed-query-display').textContent = '';
                    }
                });
                
                try {
                    const precomputationPromises = allStages.map(async (stage) => {
                        const genImageBtn = stage.querySelector('.type-btn[data-type="gen_image"]');
                    });

                    await Promise.all(precomputationPromises);
                
                    const objectFilters = getObjectFilterData();
                    let response;
                    let searchEndpoint;
                    let requestBody;

                    if (imageFileFromClick) {
                        searchEndpoint = '/search';
                        const searchData = { models: ["bge"], filters: objectFilters, image_search_text: "", page: 1, page_size: PAGE_SIZE };
                        lastSearchPayload = searchData;
                        const formData = new FormData();
                        formData.append('query_image', imageFileFromClick, imageFileFromClick.name);
                        formData.append('search_data', JSON.stringify(searchData));
                        requestBody = formData;
                    } else if (allStages.length === 1) {
                        searchEndpoint = '/search';
                        const firstStage = allStages[0];
                        const useBgeCaption = firstStage.querySelector('.option-btn[data-option="bge_caption"]').classList.contains('active');
                        const searchData = { filters: objectFilters, page: 1, page_size: PAGE_SIZE, use_bge_caption: useBgeCaption };
                        let hasPrimaryQuery = false;

                        if (firstStage.querySelector('.type-btn[data-type="gen_image"]')?.classList.contains('active')) {
                            const mainInput = firstStage.querySelector('.main-query-input');
                            searchData.query_text = mainInput.value.trim();
                            searchData.generated_image_name = firstStage.generatedImageName;
                            searchData.models = ["unite"];
                            if (searchData.query_text) hasPrimaryQuery = true;
                        } else if (firstStage.querySelector('.type-btn[data-type="image"].active')) {
                            const imageTextInput = firstStage.querySelector('.image-search-text-input');
                            if (firstStage.tempImageName) {
                                searchData.query_image_name = firstStage.tempImageName;
                                searchData.image_search_text = imageTextInput.value.trim();
                                searchData.models = ["bge"];
                                hasPrimaryQuery = true;
                            }
                        } else {
                            const mainInput = firstStage.querySelector('.main-query-input');
                            searchData.query_text = mainInput.value.trim();
                            searchData.models = Array.from(document.querySelectorAll('#modelDropdown input:checked')).map(cb => cb.value);
                            searchData.enhance = firstStage.querySelector('.option-btn[data-option="enhance"]').classList.contains('active');
                            if (searchData.query_text) hasPrimaryQuery = true;
                        }

                        if (firstStage.querySelector('.type-btn[data-type="ocr"].active')) searchData.ocr_query = firstStage.querySelector('.ocr-filter-input').value.trim();
                        if (firstStage.querySelector('.type-btn[data-type="asr"].active')) searchData.asr_query = firstStage.querySelector('.asr-filter-input').value.trim();
                        if (!hasPrimaryQuery && !searchData.ocr_query && !searchData.asr_query) throw new Error("Please provide a main query or a filter.");
                        if (hasPrimaryQuery && searchData.models && searchData.models.length === 0) throw new Error("Please select at least one model.");
                        
                        lastSearchPayload = searchData;
                        const formData = new FormData();
                        formData.append('search_data', JSON.stringify(searchData));
                        requestBody = formData;
                    } else {
                        searchEndpoint = '/temporal_search';
                        const stagesData = allStages.map(stage => {
                            const mainInput = stage.querySelector('.main-query-input');
                            
                            // ## BẮT ĐẦU SỬA LỖI TEMPORAL SEARCH ##
                            // Sử dụng Optional Chaining (?.) để kiểm tra sự tồn tại của element trước khi truy cập classList.
                            // Điều này ngăn lỗi "Cannot read properties of null" khi querySelector không tìm thấy element (ví dụ: data-option="expand").
                            const stageDatum = {
                                query: mainInput.value.trim(),
                                query_image_name: stage.tempImageName || null,
                                generated_image_name: stage.generatedImageName || null,
                                enhance: stage.querySelector('.option-btn[data-option="enhance"]')?.classList.contains('active') || false,
                                expand: stage.querySelector('.option-btn[data-option="expand"]')?.classList.contains('active') || false, // Dòng này là nguyên nhân chính gây lỗi
                                use_bge_caption: stage.querySelector('.option-btn[data-option="bge_caption"]')?.classList.contains('active') || false,
                                ocr_query: stage.querySelector('.type-btn[data-type="ocr"].active') ? stage.querySelector('.ocr-filter-input').value.trim() : null,
                                asr_query: stage.querySelector('.type-btn[data-type="asr"].active') ? stage.querySelector('.asr-filter-input').value.trim() : null,
                            };
                            // ## KẾT THÚC SỬA LỖI ##

                            return stageDatum;
                        });
                        
                        const payload = { stages: stagesData, models: Array.from(document.querySelectorAll('#modelDropdown input:checked')).map(cb => cb.value), filters: objectFilters, ambiguous: ambiguousBtn.classList.contains('active'), page: 1, page_size: PAGE_SIZE };
                        lastSearchPayload = payload;
                        requestBody = JSON.stringify(payload);
                    }
                    
                    const fetchOptions = { method: 'POST' };
                    if (requestBody instanceof FormData) {
                        fetchOptions.body = requestBody;
                    } else {
                        fetchOptions.headers = { 'Content-Type': 'application/json' };
                        fetchOptions.body = requestBody;
                    }
                    
                    response = await fetch(searchEndpoint, fetchOptions);
                    if (!response.ok) { const err = await response.json(); throw new Error(err.detail || 'Unknown error from server.'); }
                    currentResponse = await response.json();

                    if (currentResponse.processed_query) {
                        const firstStage = allStages[0];
                        if (firstStage) {
                            const displayWrapper = firstStage.querySelector('.main-processed-query-wrapper');
                            const displaySpan = displayWrapper.querySelector('.processed-query-display');
                            displaySpan.textContent = currentResponse.processed_query;
                            displayWrapper.style.display = 'flex';
                        }
                    }
                    if (currentResponse.processed_queries && Array.isArray(currentResponse.processed_queries)) {
                        allStages.forEach((stage, index) => {
                            const processedQueryText = currentResponse.processed_queries[index];
                            if (processedQueryText) {
                                const displayWrapper = stage.querySelector('.main-processed-query-wrapper');
                                if (displayWrapper) {
                                    const displaySpan = displayWrapper.querySelector('.processed-query-display');
                                    displaySpan.textContent = processedQueryText;
                                    displayWrapper.style.display = 'flex';
                                }
                            }
                        });
                    }

                    totalResults = currentResponse.total_results || 0;
                    displayTimingInfo(currentResponse.timing_info, clientStartTime);
                    displayResults(currentResponse.results, false);

                } catch (error) {
                    console.error("[ERROR] Search failed:", error);
                    resultsContainer.innerHTML = `<p style="color: #ef4444; font-size: 1.1rem; text-align: center;"><strong>Error:</strong> ${error.message}</p>`;
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }
            
            let debounceTimer = null;
            function loadMoreResults() {
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(async () => {
                    const resultsCount = resultsContainer.querySelectorAll('.result-item, .sequence-result-container').length;
                    if (isLoadingMore || !lastSearchPayload || (totalResults > 0 && resultsCount >= totalResults)) {
                        return;
                    }

                    isLoadingMore = true;
                    currentPage++;

                    const loader = document.createElement('div');
                    loader.id = 'moreLoader';
                    loader.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading more...';
                    loader.style.textAlign = 'center';
                    loader.style.padding = '20px';
                    loader.style.fontSize = '1.2rem';
                    resultsContainer.appendChild(loader);

                    try {
                        let response;
                        let searchEndpoint;
                        let requestBody;
                        lastSearchPayload.page = currentPage;

                        if (lastSearchPayload.stages) {
                            searchEndpoint = '/temporal_search';
                            requestBody = JSON.stringify(lastSearchPayload);
                        } else {
                            searchEndpoint = '/search';
                            const formData = new FormData();
                            formData.append('search_data', JSON.stringify(lastSearchPayload));
                            requestBody = formData;
                        }

                        const fetchOptions = { method: 'POST' };
                        if (requestBody instanceof FormData) {
                            fetchOptions.body = requestBody;
                        } else {
                            fetchOptions.headers = { 'Content-Type': 'application/json' };
                            fetchOptions.body = requestBody;
                        }

                        response = await fetch(searchEndpoint, fetchOptions);
                        if (!response.ok) {
                            const err = await response.json();
                            throw new Error(err.detail || 'Failed to load more results.');
                        }
                        const data = await response.json();
                        displayResults(data.results, true);
                    } catch (error) {
                        console.error("Error loading more results:", error);
                        loader.textContent = `Error: ${error.message}`;
                    } finally {
                        isLoadingMore = false;
                        const existingLoader = document.getElementById('moreLoader');
                        if (existingLoader) existingLoader.remove();
                        debounceTimer = null;
                    }
                }, 300); // debounce 300ms
            }
            
            function getObjectFilterData(){const e={};if(enableCountFilter.checked){const t={};countFilterControls.querySelectorAll(".count-filter-row").forEach(e=>{const o=e.querySelector(".count-checkbox");if(o.checked){const r=e.querySelector(".condition-input").value.trim();if(r){let s=e.classList.contains("custom")?e.querySelector(".custom-object-name").value.trim().toLowerCase():o.dataset.object;s&&(t[s]=r)}}}),Object.keys(t).length>0&&(e.counting={conditions:t})}if(enablePositionFilter.checked&&drawnBoxes.length>0){const o=drawnBoxes.filter(e=>e.label).map(e=>({label:e.label,box:[e.x/posCanvas.width,e.y/posCanvas.height,(e.x+e.w)/posCanvas.width,(e.y+e.h)/posCanvas.height]}));o.length>0&&(e.positioning={boxes:o})}return objectFilterBtn.classList.toggle("active",enableCountFilter.checked||enablePositionFilter.checked),(enableCountFilter.checked||enablePositionFilter.checked)&&Object.keys(e).length>0?e:null}

            function createCountRow(e = "", t = !1) { const o = document.createElement("div"); o.className = "count-filter-row" + (t ? " custom" : ""); const r = `<input type="checkbox" class="count-checkbox" data-object="${e || "custom"}">`, s = t ? `<input type="text" class="filter-input custom-object-name" placeholder="object name">` : `<label>${e}</label>`, n = `<input type="text" class="filter-input condition-input" placeholder="e.g., >=1">`, i = t ? `<button class="remove-custom-btn">&times;</button>` : ""; o.innerHTML = `${r}${s}${n}${i}`; const a = o.querySelector(".count-checkbox"); const l = () => o.classList.toggle("active-row", a.checked); o.addEventListener("click", e => { e.target.tagName !== "INPUT" && e.target.tagName !== "BUTTON" && (a.checked = !a.checked, l()) }); a.addEventListener("change", l); const conditionInput = o.querySelector('.condition-input'); conditionInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); if (conditionInput.value.trim() !== '') { a.checked = true; l(); } conditionInput.blur(); } }); t && o.querySelector(".remove-custom-btn").addEventListener("click", () => o.remove()); l(); return o; }
            PREDEFINED_OBJECTS.forEach(e=>countFilterControls.appendChild(createCountRow(e))),addCustomCountBtn.addEventListener("click",()=>countFilterControls.appendChild(createCountRow("",!0)));
            function redrawCanvas(){if(!posCtx)return;posCtx.clearRect(0,0,posCanvas.width,posCanvas.height),posCtx.strokeStyle="#FFD700",posCtx.lineWidth=2,drawnBoxes.forEach((e,t)=>{posCtx.strokeRect(e.x,e.y,e.w,e.h),posCtx.font="14px 'Poppins'",posCtx.fillStyle="#FFD700",posCtx.fillText(`${t+1}: ${e.label||"no label"}`,e.x+5,e.y+16)}),isDrawing&&(posCtx.strokeStyle="var(--accent-pink)",posCtx.strokeRect(startX,startY,currentX-startX,currentY-startY))}
            function updateDrawnBoxesList(){drawnBoxesList.innerHTML="",drawnBoxes.forEach((e,t)=>{const o=document.createElement("div");o.className="drawn-box-item",o.textContent=`Box ${t+1}: ${e.label||"(unlabeled)"}`,drawnBoxesList.appendChild(o)})}posCanvas.addEventListener("pointerdown",e=>{isDrawing=!0,startX=e.offsetX,startY=e.offsetY}),posCanvas.addEventListener("pointermove",e=>{isDrawing&&(currentX=e.offsetX,currentY=e.offsetY,redrawCanvas())}),posCanvas.addEventListener("pointerup",e=>{if(!isDrawing)return;isDrawing=!1;const t=e.offsetX,o=e.offsetY,r={x:Math.min(startX,t),y:Math.min(startY,o),w:Math.abs(t-startX),h:Math.abs(o-startY),label:""};r.w>5&&r.h>5&&drawnBoxes.push(r),redrawCanvas(),updateDrawnBoxesList()});

            function renumberStages() {
                stagesContainer.querySelectorAll('.stage-card').forEach((card, index) => {
                    const stageNumberEl = card.querySelector('.stage-number');
                    if (stageNumberEl) stageNumberEl.textContent = index + 1;
                    const deleteBtn = card.querySelector('.delete-stage');
                    if (deleteBtn) {
                        deleteBtn.style.display = stagesContainer.children.length > 1 ? 'flex' : 'none';
                    }
                });
            }
            function addStageToEnd() {
                const newStage = createStageCard(0);
                stagesContainer.appendChild(newStage);
                renumberStages();
                focusOnStageInput(newStage);
            }
            function addStageToStart() {
                const newStage = createStageCard(0);
                stagesContainer.insertAdjacentElement('afterbegin', newStage);
                renumberStages();
                focusOnStageInput(newStage);
            }
            function removeStageFromEnd() {
                if (stagesContainer.children.length > 1) {
                    stagesContainer.lastChild.remove();
                    renumberStages();
                    focusOnStageInput(stagesContainer.lastChild);
                }
            }
            function removeStageFromStart() {
                if (stagesContainer.children.length > 1) {
                    stagesContainer.firstChild.remove();
                    renumberStages();
                    focusOnStageInput(stagesContainer.firstChild);
                }
            }
            const addTaskBtn = document.getElementById('addTaskBtn');
            const taskSelector = document.getElementById('taskSelector');
            const submitPanelBtn = document.getElementById('submitPanelBtn');
            submitPanelBtn.addEventListener('click', submitPanelToCSV);

            // START: NEW TASK MANAGEMENT FUNCTIONS
            async function loadTasks() {
                try {
                    const response = await fetch('/tasks');
                    if (!response.ok) throw new Error('Failed to fetch tasks');
                    const data = await response.json();

                    taskSelector.innerHTML = '<option value="">-- Select a Task --</option>';
                    data.tasks.forEach(taskName => {
                        const option = document.createElement('option');
                        option.value = option.textContent = taskName;
                        taskSelector.appendChild(option);
                    });

                    const savedTask = sessionStorage.getItem('activeTaskName');
                    if (savedTask && data.tasks.includes(savedTask)) {
                        taskSelector.value = savedTask;
                        activeTaskName = savedTask;
                    } else {
                        activeTaskName = null;
                    }
                } catch (error) {
                    console.error("Error loading tasks:", error);
                    showToast(error.message, 3000, 'error');
                }
            }

            async function handleCreateTask() {
                const taskName = prompt("Enter a name for the new task (e.g., query-p1-4 or query-p1-5-qa):");
                if (!taskName || taskName.trim() === '') return;

                try {
                    const response = await fetch('/tasks/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ task_name: taskName.trim() })
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail || 'Failed to create task');

                    showToast(`Task '${result.task_name}' created!`, 3000, 'success');
                    await loadTasks();
                    taskSelector.value = result.task_name;
                    activeTaskName = result.task_name;
                    sessionStorage.setItem('activeTaskName', activeTaskName);

                    // --- NEW: Manually trigger panel reload for the new (empty) task ---
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'load_submission_panel',
                            data: { task_name: activeTaskName }
                        }));
                    }
                    // --- END NEW ---

                } catch (error) {
                    console.error("Error creating task:", error);
                    showToast(error.message, 4000, 'error');
                }
            }

            async function handleSubmitToCSV(shotData) {
                if (!activeTaskName) {
                    showToast("Please select a task from the dropdown first!", 3000, 'warning');
                    taskSelector.focus();
                    return;
                }

                const payload = {
                    task_name: activeTaskName,
                    video_id: shotData.video_id,
                    frame_id: shotData.frame_id,
                    answer: null
                };

                if (activeTaskName.toLowerCase().includes("qa")) {
                    const answer = prompt(`This is a QA task.\n\nEnter the answer for:\nVideo: ${shotData.video_id}, Frame: ${shotData.frame_id}`);
                    if (answer === null) { // User clicked Cancel
                        showToast("Submission cancelled.", 2000, 'info');
                        return;
                    }
                    payload.answer = answer; // Can be an empty string if user clicks OK without typing
                }

                try {
                    const response = await fetch('/submit/csv/frame', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail || 'Failed to submit');
                    
                    const qaInfo = payload.answer !== null ? ` with answer.` : '.';
                    showToast(`Frame submitted to '${activeTaskName}'${qaInfo}`, 2500, 'success');

                } catch (error) {
                    console.error("CSV Submission Error:", error);
                    showToast(`Error: ${error.message}`, 4000, 'error');
                }
            }
            addTaskBtn.addEventListener('click', handleCreateTask);
            taskSelector.addEventListener('change', () => {
                activeTaskName = taskSelector.value || null;
                if (activeTaskName) {
                    sessionStorage.setItem('activeTaskName', activeTaskName);
                } else {
                    sessionStorage.removeItem('activeTaskName');
                }
                
                // --- NEW: Tell the backend to load the panel for this task ---
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const submissionGrid = document.getElementById('submissionGrid');
                    submissionGrid.innerHTML = '<i class="fas fa-spinner fa-spin" style="font-size: 1.5rem; margin: auto;"></i>';
                    ws.send(JSON.stringify({
                        type: 'load_submission_panel',
                        data: { task_name: activeTaskName }
                    }));
                }
                // --- END NEW ---
            });
            
            setupImageObserver();
            setupUser();
            loadTasks().then(() => {
                if (activeTaskName && ws && ws.readyState === WebSocket.OPEN) {
                    console.log(`Active task '${activeTaskName}' found on reload. Triggering panel load.`);
                    taskSelector.dispatchEvent(new Event('change'));

                    if (sessionStorage.getItem('submissionPanelOpen') === 'true') {
                        submissionBtn.classList.add('active');
                        submissionPanelContainer.style.display = 'block';
                    }
                }
            });
            initializeDresState();
            function applyTheme(themeName) {
                document.body.className = themeName === 'default' ? '' : themeName;
                localStorage.setItem('videoSearchTheme', themeName);
                
                const themeLabel = THEMES[themeName] || 'Default Dark';
                themeSwitcherBtn.querySelector('span').innerHTML = `<i class="fas fa-palette"></i> ${themeLabel}`;

                // --- Logic bật/tắt hiệu ứng đặc biệt ---

                // Digital Rain
                if (themeName === 'theme-gits-rain') {
                    cursedDomainVideo.style.display = 'none'; // Tắt video JJK
                    cursedDomainVideo.pause();
                    startDigitalRain();
                } 
                // Cursed Domain Video
                else if (themeName === 'theme-jujutsu-domain') {
                    stopDigitalRain(); // Tắt Digital Rain
                    cursedDomainVideo.style.display = 'block';
                    cursedDomainVideo.play().catch(e => console.error("Video autoplay failed:", e));
                } 
                // Các theme khác
                else {
                    stopDigitalRain();
                    cursedDomainVideo.style.display = 'none';
                    cursedDomainVideo.pause();
                }
            }

            function initTheme() {
                // Populate dropdown
                const fragment = document.createDocumentFragment();
                for (const [className, name] of Object.entries(THEMES)) {
                    const item = document.createElement('div');
                    item.className = 'theme-dropdown-item';
                    item.dataset.theme = className;
                    const swatch = document.createElement('div');
                    swatch.className = 'theme-color-swatch';
                    
                    // Create a dummy div to get theme colors
                    const dummy = document.createElement('div');
                    dummy.style.display = 'none';
                    document.body.appendChild(dummy);
                    const originalClass = document.body.className;
                    document.body.className = className === 'default' ? '' : className;
                    const primaryGradient = getComputedStyle(dummy).getPropertyValue('--primary-gradient');
                    swatch.style.background = primaryGradient;
                    document.body.className = originalClass;
                    dummy.remove();
                    
                    item.appendChild(swatch);
                    item.append(name);
                    item.addEventListener('click', () => {
                        applyTheme(className);
                        themeDropdown.style.display = 'none';
                    });
                    fragment.appendChild(item);
                }
                themeDropdown.appendChild(fragment);

                // Apply saved theme
                const savedTheme = localStorage.getItem('videoSearchTheme') || 'default';
                applyTheme(savedTheme);
            }

            initTheme();
            function closeSidebar() {
                nearbyFramesSidebar.style.display = 'none';
                activeTrakeItemForSidebar = null;
            }
            sidebarCloseBtn.addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);

            themeSwitcherBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                themeDropdown.style.display = themeDropdown.style.display === 'block' ? 'none' : 'block';
            });
            // ############ END: THEME SWITCHER LOGIC ############


            // ############ START: TRAKE PANEL LOGIC ############
            submissionBtn.addEventListener('click', () => {
                const isActive = submissionBtn.classList.toggle('active');
                submissionPanelContainer.style.display = isActive ? 'block' : 'none';
                sessionStorage.setItem('submissionPanelOpen', isActive);
            });

            function pushToSubmissionPanel(shotData) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showToast("Real-time connection not active.", 3000, 'error');
                    return;
                }
                if (!shotData || !shotData.filepath) return;

                // Check for duplicates locally first for better UX
                const submissionGrid = document.getElementById('submissionGrid');
                if (submissionGrid.querySelector(`.result-item[data-filepath="${shotData.filepath}"]`)) {
                    showToast("Frame is already in the Submission Panel.", 2000, 'warning');
                    return;
                }

                // --- NEW LOGIC FOR QA TASKS ---
                let answer = null;
                if (activeTaskName && activeTaskName.toLowerCase().includes('qa')) {
                    answer = prompt(`QA Task: Enter the answer for this frame (Video: ${shotData.video_id}, Frame: ${shotData.frame_id})`);
                    if (answer === null) { // User clicked "Cancel"
                        showToast("Push to panel cancelled.", 2000, 'info');
                        return;
                    }
                }
                // --- END NEW LOGIC ---

                ws.send(JSON.stringify({
                    type: 'submission_panel_add',
                    data: { 
                        shot: shotData,
                        answer: answer, // Send the answer along with the shot data
                        task_name: activeTaskName
                    }
                }));

                const submissionBtn = document.getElementById('submissionBtn');
                if (!submissionBtn.classList.contains('active')) {
                    submissionBtn.click();
                }
            }

            // --- Drag & Drop for Trake Panel ---
            let draggedItem = null;
            submissionGrid.addEventListener('dragstart', e => {
                draggedItem = e.target.closest('.result-item');
                setTimeout(() => {
                    if(draggedItem) draggedItem.classList.add('ghost');
                }, 0);
            });
            submissionGrid.addEventListener('dragend', e => {
                if(draggedItem) {
                    draggedItem.classList.remove('ghost');
                    draggedItem = null;

                    const newOrder = [...submissionGrid.querySelectorAll('.result-item')].map(item => item.dataset.filepath);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'submission_panel_reorder', // <-- CORRECTED
                            data: { order: newOrder, task_name: activeTaskName }
                        }));
                    }
                }
            });
            submissionGrid.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(submissionGrid, e.clientX);
                const dragging = document.querySelector('.ghost');
                if (dragging) {
                    if (afterElement == null) {
                        submissionGrid.appendChild(dragging);
                    } else {
                        submissionGrid.insertBefore(dragging, afterElement);
                    }
                }
            });

            function getDragAfterElement(container, x) {
                const draggableElements = [...container.querySelectorAll('.result-item:not(.ghost)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            function handleNearbyFramesClick(event) {
                event.stopPropagation();
                const itemElement = event.target.closest('.result-item');
                if (itemElement && itemElement.shotData) {
                    toggleNearbyFrames(itemElement, itemElement.shotData);
                } else {
                    console.error("Could not find shot data for nearby frames button.", itemElement);
                    showToast("Error: Data for this frame is missing.", 3000, 'error');
                }
            }

            // --- Nearby Frames Logic ---
            async function toggleNearbyFrames(trakeItemElement, shotData) {
                // This function now opens the sidebar
                activeTrakeItemForSidebar = trakeItemElement;
                sidebarGrid.innerHTML = '<div class="sidebar-item loading" style="justify-content: center;"><i class="fas fa-spinner fa-spin"></i></div>';
                sidebarTitle.textContent = `Nearby: V${shotData.video_id}, F${shotData.frame_id}`;
                nearbyFramesSidebar.style.display = 'flex';

                let currentShotData = { ...shotData };

                if (!currentShotData.fps) {
                    try {
                        if (!currentShotData.video_id) throw new Error("Missing video_id");
                        const infoResponse = await fetch(`/video_info/${currentShotData.video_id}`);
                        if (!infoResponse.ok) throw new Error(`Server error ${infoResponse.status}`);
                        const videoInfo = await infoResponse.json();
                        currentShotData.fps = videoInfo.fps;
                        trakeItemElement.shotData.fps = videoInfo.fps; // Persist it
                    } catch (error) {
                        sidebarGrid.innerHTML = `<div style="color: #ef4444;">Error: ${error.message}</div>`;
                        return;
                    }
                }
                
                try {
                    const originalTime = currentShotData.frame_id / currentShotData.fps;
                    const timeOffsets = [-1.0, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1.0];
                    const framePromises = timeOffsets.map(offset => fetchFrameAtTime(currentShotData.video_id, originalTime + offset));
                    const frameResults = await Promise.all(framePromises);
                    
                    sidebarGrid.innerHTML = ''; // Clear loading spinner
                    frameResults.forEach((result, index) => {
                        if (result.success) {
                            const offset = timeOffsets[index];
                            const newItem = document.createElement('div');
                            newItem.className = 'sidebar-item';
                            newItem.innerHTML = `
                                <img src="${result.imageData}" />
                                <span class="time-offset">${offset === 0 ? 'Original' : (offset > 0 ? `+${offset.toFixed(1)}s` : `${offset.toFixed(1)}s`)}</span>
                            `;
                            
                            newItem.addEventListener('click', () => {
                                const newFrameId = Math.round((originalTime + offset) * currentShotData.fps);
                                const newShotData = { ...currentShotData, frame_id: newFrameId, url: result.imageData };
                                
                                if (activeTrakeItemForSidebar && ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({
                                        type: 'submission_panel_replace', // <-- CORRECTED
                                        data: {
                                            filepath: activeTrakeItemForSidebar.dataset.filepath,
                                            newShot: newShotData
                                        }
                                    }));
                                }
                                closeSidebar();
                            });
                            sidebarGrid.appendChild(newItem);
                        }
                    });
                } catch (error) {
                    sidebarGrid.innerHTML = `<div style="color: #ef4444;">Error loading frames: ${error.message}</div>`;
                }
            }

            async function fetchFrameAtTime(videoId, timestamp) {
                try {
                    const formData = new FormData();
                    formData.append('video_id', videoId);
                    formData.append('timestamp', timestamp);

                    const response = await fetch('/get_frame_at_timestamp', { method: 'POST', body: formData });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Server error');
                    }
                    const data = await response.json();
                    return { success: true, imageData: data.image_data };
                } catch (error) {
                    console.error(`Failed to fetch frame for ${videoId} at ${timestamp}s:`, error);
                    return { success: false, error: error.message };
                }
            }
            
            function submitPanelToCSV() {
                const submissionGrid = document.getElementById('submissionGrid');
                const items = Array.from(submissionGrid.querySelectorAll('.result-item'));
                if (!activeTaskName) {
                    showToast("Please select a task first!", 3000, 'warning');
                    return;
                }

                if (items.length === 0) {
                    showToast("Submission Panel is empty.", 2000, 'info');
                    return;
                }

                if (ws && ws.readyState === WebSocket.OPEN) {
                    // We just need to tell the server to submit its current state for the active task.
                    ws.send(JSON.stringify({
                        type: 'submit_panel_to_csv',
                        data: { task_name: activeTaskName }
                    }));
                }
            }
            const initialStage = createStageCard(1);
            stagesContainer.appendChild(initialStage);
            focusOnStageInput(initialStage);

            addStageBtn.addEventListener('click', addStageToEnd);
            removeStageBtn.addEventListener('click', removeStageFromEnd);
            searchBtn.addEventListener('click', () => handleSearch(null));
            document.getElementById('resetBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the search panel?')) {
                    stagesContainer.innerHTML = '';
                    addStageToStart();
                    currentResponse = {};
                    resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding-top: 100px; font-size: 1.5rem;">Sử dụng bảng điều khiển bên trái để bắt đầu tìm kiếm.</p>';
                    document.getElementById('timingInfoDisplay').style.display = 'none';
                    teamworkGrid.innerHTML = '';
                    pushedFrames.clear();
                    submittedFrames.clear(); // Xóa lịch sử các lượt nộp
                    document.getElementById('correctSubmissionPanel').style.display = 'none'; // Ẩn panel nộp đúng
                    googleSearchInput.value = '';
                    googleResultsContainer.innerHTML = '';
                    googleResultsWrapper.style.display = 'none';
                }
            });            
            clusterBtn.addEventListener('click', () => {
                clusterBtn.classList.toggle('active');
                if (currentResponse.results && !isLoadingMore) {
                    currentPage = 1; 
                    const allData = currentResponse.results;
                    displayResults(allData, false);
                }
            });
            ambiguousBtn.addEventListener('click', () => { ambiguousBtn.classList.toggle('active'); });
            modelSelectBtn.addEventListener('click', (event) => { event.stopPropagation(); const isOpening = modelDropdown.style.display !== 'block'; modelDropdown.style.display = isOpening ? 'block' : 'none'; if (isOpening) { focusedModelIndex = 0; updateModelFocus(); } else { clearModelFocus(); } });
            window.addEventListener('click', (e) => { if (!modelDropdown.contains(e.target) && !modelSelectBtn.contains(e.target)) { if (modelDropdown.style.display === 'block') { modelDropdown.style.display = 'none'; clearModelFocus(); } } });
            closeImageModalBtn.addEventListener('click', () => { imageModal.style.display = "none"; });
            imageModal.addEventListener('click', (e) => { if (e.target === imageModal) { imageModal.style.display = "none"; } });
            closeTemporalModalBtn.addEventListener('click', () => { temporalContextModal.style.display = "none"; });
            temporalContextModal.addEventListener('click', (e) => { if (e.target === temporalContextModal) { temporalContextModal.style.display = "none"; } });
            
            function closeVideoModal() {
                document.body.classList.remove('video-modal-active'); // THÊM DÒNG NÀY
                videoPreviewModal.style.display = "none";
                videoPlayer.pause();
                videoPlayer.src = "";
                currentVideoPreviewData = null;
            }

            closeVideoModalBtn.addEventListener('click', closeVideoModal);
            videoPreviewModal.addEventListener('click', (e) => { 
                if (e.target === videoPreviewModal) { 
                    closeVideoModal(); 
                } 
            });
            modalCloseBtn.addEventListener('click', () => objectFilterModal.style.display = 'none');

            function resetDresState() {
                dresSessionId = null;
                dresEvaluationId = null;
                sessionStorage.removeItem('dresSessionId');
                sessionStorage.removeItem('dresEvaluationId');
                
                dresStatus.textContent = 'Status: Not logged in.';
                dresStatus.style.color = 'var(--text-secondary)';
                dresEvaluationSelect.innerHTML = '';
                dresEvaluationSelect.disabled = true;
            }

            /**
             * Fetches evaluations for a given session, populates the dropdown,
             * and updates the UI to the logged-in state.
             */
            async function revalidateAndFetchEvaluations() {
                if (!dresSessionId) return;

                dresStatus.textContent = 'Validating session & fetching evaluations...';
                dresStatus.style.color = 'var(--text-secondary)';
                
                try {
                    const evalResponse = await fetch(`/dres/list_evaluations?session=${dresSessionId}`);
                    if (!evalResponse.ok) {
                        // This likely means the session ID has expired.
                        throw new Error('Session invalid or expired. Please log in again.');
                    }
                    const evaluations = await evalResponse.json();
                    
                    dresEvaluationSelect.innerHTML = '';
                    evaluations.forEach(ev => {
                        if (ev.status === 'ACTIVE') {
                            const option = document.createElement('option');
                            option.value = ev.id;
                            option.textContent = ev.name;
                            dresEvaluationSelect.appendChild(option);
                        }
                    });

                    if (dresEvaluationSelect.options.length > 0) {
                        // Try to restore the previously selected evaluation
                        const storedEvalId = sessionStorage.getItem('dresEvaluationId');
                        if (storedEvalId && dresEvaluationSelect.querySelector(`option[value="${storedEvalId}"]`)) {
                            dresEvaluationSelect.value = storedEvalId;
                        }
                        dresEvaluationId = dresEvaluationSelect.value;
                        sessionStorage.setItem('dresEvaluationId', dresEvaluationId);
                        
                        dresStatus.textContent = `Ready to submit to: ${dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex].text}`;
                        dresStatus.style.color = 'var(--accent-blue)';
                    } else {
                        dresStatus.textContent = 'Logged in, but no active evaluations found.';
                        dresStatus.style.color = 'var(--text-secondary)';
                    }
                    dresEvaluationSelect.disabled = false;

                } catch (error) {
                    console.error("DRES Re-validation Error:", error.message);
                    showToast(error.message, 4000, 'error');
                    resetDresState(); // Critical: Clear bad session data
                }
            }
            
            /**
             * Checks sessionStorage on page load to restore DRES login state.
             */
            function initializeDresState() {
                dresSessionId = sessionStorage.getItem('dresSessionId');
                if (dresSessionId) {
                    revalidateAndFetchEvaluations();
                }
            }
            
            dresModalCloseBtn.addEventListener('click', () => dresModal.style.display = 'none');

            dresBtn.addEventListener('click', () => {
                if (dresSessionId) {
                    dresInitialView.style.display = 'none';
                    dresLoginView.style.display = 'none';
                    dresEvaluationView.style.display = 'block';
                    
                    const selectedOption = dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex];
                    dresStatus.textContent = selectedOption ? `Ready to submit to: ${selectedOption.text}` : 'Logged in, please select an evaluation.';
                    dresStatus.style.color = 'var(--accent-blue)';
                } else {
                    dresInitialView.style.display = 'block';
                    dresLoginView.style.display = 'none';
                    dresEvaluationView.style.display = 'none';
                    dresStatus.textContent = 'Status: Not logged in.';
                    dresStatus.style.color = 'var(--text-secondary)';
                }
                dresModal.style.display = 'flex';
            });

            dresShowLoginBtn.addEventListener('click', () => {
                dresInitialView.style.display = 'none';
                dresLoginView.style.display = 'flex';
                dresUsername.focus();
            });

            dresLoginBtn.addEventListener('click', async () => {
                const user = dresUsername.value;
                const pass = dresPassword.value;
                if (!user || !pass) {
                    alert('Please enter username and password.');
                    return;
                }
                dresStatus.textContent = 'Logging in...';
                dresStatus.style.color = 'var(--text-secondary)';
                try {
                    const response = await fetch('/dres/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username: user, password: pass })
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Login failed');
                    }
                    const data = await response.json();
                    dresSessionId = data.sessionId;
                    sessionStorage.setItem('dresSessionId', dresSessionId);
                    
                    // Now, just call our reusable function!
                    await revalidateAndFetchEvaluations();
                    
                    showToast('DRES Login successful!', 3000, 'success');
                    dresModal.style.display = 'none';

                } catch (error) {
                    dresStatus.textContent = `Error: ${error.message}`;
                    dresStatus.style.color = '#ef4444';
                    resetDresState(); // Reset on login failure
                }
            });

            dresEvaluationSelect.addEventListener('change', () => {
                dresEvaluationId = dresEvaluationSelect.value;
                sessionStorage.setItem('dresEvaluationId', dresEvaluationId);
                dresStatus.textContent = `Ready to submit to: ${dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex].text}`;
            });
            
            objectFilterBtn.addEventListener('click', () => {
                objectFilterModal.style.display = 'flex';
            });
            

            window.addEventListener('keydown', (event) => {
                const activeElement = document.activeElement;
                const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');

                if (videoPreviewModal.style.display === 'flex' && event.code === 'Space' && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault();
                    if (event.shiftKey) {
                        submitCurrentFrameBtn.click();
                    } else {
                        pushCurrentFrameBtn.click();
                    }
                    return;
                }

                if (event.key === 'Escape') {
                    event.preventDefault();
                    if (isTyping) { activeElement.blur(); return; }
                    if (videoPreviewModal.style.display === 'flex') { closeVideoModal(); return; }
                    if (imageModal.style.display === 'flex') { imageModal.style.display = 'none'; return; }
                    if (temporalContextModal.style.display === 'flex') { temporalContextModal.style.display = 'none'; return; }
                    if (objectFilterModal.style.display === 'flex') { objectFilterModal.style.display = 'none'; return; }
                    if (dresModal.style.display === 'flex') { dresModal.style.display = 'none'; return; }
                    if (modelDropdown.style.display === 'block') { modelDropdown.style.display = 'none'; clearModelFocus(); return; }
                }
                
                const isModalVisible = Array.from(document.querySelectorAll('.modal-overlay')).some(m => m.style.display === 'flex' || m.style.display === 'block');
                
                if ((event.ctrlKey || event.metaKey)) {
                    if (event.key.toLowerCase() === 'f' && !event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        if (objectFilterModal.style.display === 'flex') {
                            objectFilterModal.style.display = 'none';
                        } else {
                            objectFilterModal.style.display = 'flex';
                        }
                        return;
                    }
                    if (event.key.toLowerCase() === 'f' && event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        document.getElementById('enableCountFilter').click();
                        document.getElementById('enablePositionFilter').click();
                        objectFilterBtn.classList.toggle('active', document.getElementById('enableCountFilter').checked || document.getElementById('enablePositionFilter').checked);
                        return;
                    }
                    if (event.key.toLowerCase() === 'm' && !event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        modelSelectBtn.click();
                        return;
                    }
                }

                if (event.code === 'Space' && (event.ctrlKey || event.metaKey)) {
                    
                    // --- NEW LOGIC: Handles Ctrl + SHIFT + Space ---
                    if (event.shiftKey) {
                        event.preventDefault();

                        // Action 1: Submit the panel if hovering over it
                        const submissionPanel = document.getElementById('submissionPanelContainer');
                        if (submissionPanel.style.display !== 'none' && submissionPanel.matches(':hover')) {
                            document.getElementById('submitPanelBtn').click();
                            return; // Action complete
                        }

                        // Action 2: Push the hovered item to the Submission Panel
                        if (!isModalVisible && currentlyHoveredItemData && currentlyHoveredItemElement) {
                            pushToSubmissionPanel(currentlyHoveredItemData);
                            return; // Action complete
                        }
                    } 
                    
                    // --- PRESERVED LOGIC: Handles Ctrl + Space (NO Shift) for Teamwork Panel ---
                    else { 
                        if (!isModalVisible && currentlyHoveredItemData && currentlyHoveredItemElement) {
                            event.preventDefault();
                            const itemData = currentlyHoveredItemData;
                            const itemElement = currentlyHoveredItemElement;
                            const source = itemElement.dataset.source;

                            if (source === 'teamwork') {
                                if (!ws || ws.readyState !== WebSocket.OPEN) { alert("Teamwork connection is not available."); return; }
                                ws.send(JSON.stringify({ type: 'remove_frame', data: { filepath: itemData.filepath, user: { name: username } } }));
                            } else {
                                if (itemData.external_url) {
                                    handleGoogleImageAction(itemData.external_url, 'push', itemElement);
                                } else {
                                    pushToTeamworkPanel(itemData);
                                }
                            }
                        }
                    }
                }

                if (modelDropdown.style.display === 'block') {
                    event.preventDefault();
                    const items = modelDropdown.querySelectorAll('.model-dropdown-item');
                    if (items.length > 0) {
                        switch (event.key) {
                            case 'ArrowDown': focusedModelIndex = (focusedModelIndex + 1) % items.length; updateModelFocus(); break;
                            case 'ArrowUp': focusedModelIndex = (focusedModelIndex - 1 + items.length) % items.length; updateModelFocus(); break;
                            case 'Enter': case ' ': if (focusedModelIndex > -1) { items[focusedModelIndex].querySelector('input[type="checkbox"]')?.click(); } break;
                        }
                    }
                    return;
                }

                if (event.key === 'Enter') {
                    if (isTyping && event.shiftKey) { return; }
                    if (dresModal.style.display === 'flex') {
                        event.preventDefault();
                        if (dresLoginView.style.display === 'flex') {
                            dresLoginBtn.click();
                        } else if (dresInitialView.style.display === 'block') {
                            dresShowLoginBtn.click();
                        }
                        return;
                    }
                    if (usernameModal.style.display === 'flex') { event.preventDefault(); usernameSubmitBtn.click(); return; }
                    event.preventDefault();
                    searchBtn.click();
                    return;
                }
                
                if (isModalVisible) {
                    const isObjectFilterModalVisible = objectFilterModal.style.display === 'flex';
                    if (isObjectFilterModalVisible && !isTyping) {
                        if (event.key in LABEL_SHORTCUTS && drawnBoxes.length > 0) { event.preventDefault(); drawnBoxes[drawnBoxes.length - 1].label = LABEL_SHORTCUTS[event.key]; }
                        else if (event.key === '7' && drawnBoxes.length > 0) { event.preventDefault(); const customLabel = prompt("Enter custom object label:", "person"); if (customLabel) drawnBoxes[drawnBoxes.length - 1].label = customLabel.toLowerCase(); }
                        else if (event.key === 'Backspace' && drawnBoxes.length > 0) { event.preventDefault(); drawnBoxes.pop(); }
                        else if (event.key.toLowerCase() === 'c') { event.preventDefault(); if (confirm("Clear all drawn boxes?")) drawnBoxes = []; }
                        redrawCanvas(); updateDrawnBoxesList();
                    }
                    return;
                }

                const stageToModify = isTyping ? activeElement.closest('.stage-card') : stagesContainer.querySelector('.stage-card:last-child');

                if ((event.ctrlKey || event.metaKey) && event.altKey && !event.shiftKey) {
                    let handled = true;
                    if (stageToModify) {
                        switch(event.key.toLowerCase()) {
                            case 'u': stageToModify.querySelector('.type-btn[data-type="text"]')?.click(); break;
                            case 'i': stageToModify.querySelector('.type-btn[data-type="image"]')?.click(); break;
                            case 'o': stageToModify.querySelector('.type-btn[data-type="ocr"]')?.click(); break;
                            case 'p': stageToModify.querySelector('.type-btn[data-type="asr"]')?.click(); break;
                            case 'g': stageToModify.querySelector('.type-btn[data-type="gen_image"]')?.click(); break;
                            case 'm': stageToModify.querySelector('.mic-btn')?.click(); break;
                            default: handled = false;
                        }
                    } else { handled = false; }
                    if(handled) { event.preventDefault(); return; }
                }
                else if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                    let handled = true;
                    switch (event.code) {
                        case 'KeyR': document.getElementById('resetBtn')?.click(); break;
                        case 'KeyG': ambiguousBtn.click(); break;
                        case 'BracketRight': removeStageFromEnd(); break;
                        case 'BracketLeft': removeStageFromStart(); break;
                        default: handled = false;
                    }
                    if (handled) event.preventDefault();
                }
                else if ((event.ctrlKey || event.metaKey) && !event.altKey) {
                    const targetStageNum = parseInt(event.key);
                    if (!isNaN(targetStageNum) && targetStageNum >= 1 && targetStageNum <= 9) {
                        event.preventDefault();
                        const allStages = stagesContainer.querySelectorAll('.stage-card');
                        if (targetStageNum <= allStages.length) focusOnStageInput(allStages[targetStageNum - 1]);
                        return;
                    }

                    let handled = true;
                    switch (event.code) {
                        case 'BracketRight': addStageToEnd(); break;
                        case 'BracketLeft': addStageToStart(); break;
                        default:
                            switch (event.key.toLowerCase()) {
                                case 'g': clusterBtn.click(); break;
                                case 'q': stageToModify?.querySelector('.option-btn[data-option="enhance"]')?.click(); break;
                                case 'u': stageToModify?.querySelector('.option-btn[data-option="bge_caption"]')?.click(); break;
                                default: handled = false;
                            }
                    }
                    if (handled) event.preventDefault();
                }
                else if (isTyping && ['ArrowUp', 'ArrowDown'].includes(event.key)) {
                    const allStages = Array.from(stagesContainer.querySelectorAll('.stage-card'));
                    if (allStages.length > 1) {
                        const currentStage = activeElement.closest('.stage-card');
                        let currentIndex = currentStage ? allStages.indexOf(currentStage) : -1;
                        if (currentIndex !== -1) {
                            event.preventDefault();
                            if (event.key === 'ArrowUp') { currentIndex = (currentIndex - 1 + allStages.length) % allStages.length; }
                            else if (event.key === 'ArrowDown') { currentIndex = (currentIndex + 1) % allStages.length; }
                            focusOnStageInput(allStages[currentIndex]);
                        }
                    }
                }

                if (videoPreviewModal.style.display !== 'flex') {
                    return;
                }

                // ## START: REPLACEMENT LOGIC ##
                // This now handles keyboard scrubbing by calling our optimized function
                if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
                    event.preventDefault();
                    const direction = event.key === 'ArrowRight' ? 1 : -1;
                    handleScrub(direction);
                    // No more code is needed here for arrow keys.
                    // The old complex block has been removed.
                }
            });
        });
    </script>
</body>
</html>