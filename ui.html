<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCubee Video Search System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" as="style">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Bangers&family=Oswald:wght@400;500&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        #cursedDomainVideo {
            position: fixed;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translateX(-50%) translateY(-50%);
            z-index: -2; /* Nằm dưới cả canvas */
            display: none; /* Mặc định ẩn đi */
        }
        #digitalRainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Luôn nằm dưới cùng */
            display: none; /* Mặc định ẩn đi */
        }
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-bg: #0a0e1a;
            --card-bg: rgba(20, 25, 40, 0.6);
            --border-color: rgba(255, 255, 255, 0.15);
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --accent-blue: #4facfe;
            --accent-purple: #667eea;
            --accent-pink: #f093fb;
            --glass-bg: rgba(255, 255, 255, 0.08);
            --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.25);
            --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.45);
            --radius: 16px;
        }
        body.theme-cyberpunk-neon {
            --primary-gradient: linear-gradient(135deg, #00f2fe 0%, #f00c8b 100%);
            --secondary-gradient: linear-gradient(135deg, #7c4dff 0%, #00e5ff 100%);
            --dark-bg: #010114;
            --card-bg: rgba(10, 10, 30, 0.7);
            --border-color: rgba(0, 242, 254, 0.3);
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0c0;
            --accent-blue: #00f2fe;
            --accent-purple: #f00c8b;
            --glass-bg: rgba(0, 242, 254, 0.05);
            background-image:
                linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><g fill="%23f00c8b" fill-opacity="0.1"><rect x="0" y="0" width="100" height="1" /><rect x="0" y="0" width="1" height="100" /></g></svg>');
        }
        /* --- THEME HUYỀN THOẠI #1 (PERFECTED): Doraemon: 4D Pocket --- */
        @keyframes jingle-bell { 0%, 100% { transform: rotate(0) scale(1); } 25% { transform: rotate(10deg) scale(1.1); } 75% { transform: rotate(-10deg) scale(1.1); } }
        @keyframes door-open { 50% { transform: perspective(500px) rotateY(5deg); box-shadow: -4px 4px 15px rgba(0,0,0,0.3); } }
        body.theme-doraemon-pocket {
            --dora-blue: #00A0E9; --dora-red: #E60012; --dora-yellow: #FCEE0A; --dora-white: #FFFFFF;
            --primary-gradient: linear-gradient(135deg, var(--dora-blue) 0%, #007bb5 100%); --secondary-gradient: linear-gradient(135deg, var(--dora-yellow) 0%, #e6d609 100%); --dark-bg: #F0F8FF; --card-bg: var(--dora-blue); --border-color: var(--dora-white); --text-primary: #003366; /* Chữ màu xanh đen đậm */ --text-secondary: #FFFFFF; --accent-blue: var(--dora-yellow); --accent-purple: #FF69B4; /* Anywhere Door Pink */ font-family: 'Poppins', sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #F0F8FF);
        }
        /* Đột phá #1: Card hình chữ nhật, nền xanh, viền đỏ */
        body.theme-doraemon-pocket .stage-card {
            border: 3px solid var(--dora-red);
            border-radius: 20px;
            background-color: var(--dora-blue);
            position: relative;
            overflow: hidden;
        }
        /* Loại bỏ pseudo-element túi bán nguyệt không cần thiết */
        body.theme-doraemon-pocket .stage-card::before {
            content: none;
        }
        body.theme-doraemon-pocket .stage-card > * { position: relative; z-index: 1; }

        /* Đột phá #2: Ô nhập liệu biến thành "Túi Thần Kỳ" */
        body.theme-doraemon-pocket .stage-input {
            background-color: var(--dora-white);
            color: #333; /* Chữ bên trong túi màu đen */
            border: 3px solid #333;
            border-radius: 20px;
            /* Dùng clip-path để tạo hình bán nguyệt ở trên */
            clip-path: polygon(0 15px, 0 100%, 100% 100%, 100% 15px, 90% 15px, 80% 5px, 70% 0, 30% 0, 20% 5px, 10% 15px);
            padding-top: 25px !important; /* Thêm padding để chữ không bị che */
        }
        body.theme-doraemon-pocket .stage-input::placeholder {
            color: #888;
        }
        body.theme-doraemon-pocket .stage-input:focus {
            box-shadow: 0 0 10px var(--dora-yellow);
        }

        /* Tinh chỉnh: Chữ và icon màu tối để dễ đọc */
        body.theme-doraemon-pocket .type-btn,
        body.theme-doraemon-pocket .option-btn {
            background: rgba(255, 255, 255, 0.3);
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.5);
        }
        body.theme-doraemon-pocket .type-btn.active {
            background: var(--dora-white);
            color: var(--dora-blue);
        }
        body.theme-doraemon-pocket .option-btn.active {
            background: var(--dora-yellow);
            color: #333;
        }
        body.theme-doraemon-pocket .processed-query-display-wrapper i,
        body.theme-doraemon-pocket .processed-query-display {
            color: var(--dora-white);
        }


        /* Chuông Lắc Lư và Nút Cánh Cửa Thần Kỳ giữ nguyên */
        body.theme-doraemon-pocket .stage-number {
            background: var(--dora-yellow); width: 40px; height: 40px;
            border: 3px solid #333;
            border-bottom: 8px solid var(--dora-red);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
            color: #333; /* Chữ số màu đen */
        }
        body.theme-doraemon-pocket .stage-number:hover { animation: jingle-bell 0.5s; }
        body.theme-doraemon-pocket .stage-number::before {
            content: ''; position: absolute; top: 50%; left: 10%; right: 10%;
            height: 2px; background: #333; transform: translateY(-50%);
        }
        body.theme-doraemon-pocket .search-btn {
            background: var(--accent-purple); color: white;
            border: 3px solid #A020F0; border-radius: 8px;
            animation: door-open 2s infinite ease-in-out;
        }
        body.theme-doraemon-pocket .result-item {
            border-radius: 15px; border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s, transform 0.3s;
        }
        body.theme-doraemon-pocket .result-item:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--dora-yellow);
        }
        /* --- THEME HUYỀN THOẠI #1: Persona 5: All-Out Attack --- */
        @keyframes p5-bg-scroll { 0% { background-position: 0 0; } 100% { background-position: -200px -200px; } }
        body.theme-persona-5 {
            --p5-red: #E60012; --p5-black: #000000; --p5-white: #FFFFFF;
            --primary-gradient: linear-gradient(135deg, var(--p5-red) 0%, #a1000c 100%); --secondary-gradient: linear-gradient(135deg, var(--p5-white) 0%, #e0e0e0 100%); --dark-bg: var(--p5-black); --card-bg: var(--p5-black); --border-color: var(--p5-red); --text-primary: var(--p5-white); --text-secondary: #d0d0d0; --accent-blue: var(--p5-red); --accent-purple: var(--p5-red); font-family: 'Anton', sans-serif; letter-spacing: 1px;
            background-color: var(--dark-bg);
            /* Đột phá: Nền sao động như menu Persona 5 */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><path d="M25,0 L30,20 L50,25 L30,30 L25,50 L20,30 L0,25 L20,20 Z" fill="%23FFFFFF" fill-opacity="0.1"/></svg>');
            animation: p5-bg-scroll 10s linear infinite;
        }
        body.theme-persona-5 .stage-card, body.theme-persona-5 .modal-content {
            border: 3px solid var(--p5-white); border-radius: 0;
            clip-path: polygon(0 15px, 15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%);
        }
        /* Đột phá: Hiệu ứng 3D "All-Out Attack" khi hover */
        body.theme-persona-5 .result-item {
            border: 3px solid var(--p5-white); border-radius: 0; position: relative;
            transition: transform 0.3s ease; perspective: 1000px;
        }
        body.theme-persona-5 .result-item:hover {
            transform: translateZ(30px) rotateY(-10deg);
        }
        body.theme-persona-5 .result-item::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--p5-red); z-index: -1; opacity: 0;
            clip-path: polygon(0% 100%, 100% 0%, 100% 100%);
            transition: opacity 0.3s ease;
        }
        body.theme-persona-5 .result-item:hover::before { opacity: 1; }
        /* Đột phá: Nút Search "Take Your Heart" */
        body.theme-persona-5 .search-btn {
            background: var(--p5-white); color: var(--p5-black); font-size: 1.3rem !important;
            border: 3px solid var(--p5-black);
            clip-path: polygon(0% 0%, 100% 0%, 85% 100%, 15% 100%);
            transition: all 0.2s ease;
        }
        body.theme-persona-5 .search-btn:hover { background: var(--p5-red); color: var(--p5-white); }


        /* --- THEME HUYỀN THOẠI #2: JoJo's Bizarre Adventure: MENACING --- */
        @keyframes menacing-rumble { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 1px) rotate(-1deg); } 75% { transform: translate(1px, 1px) rotate(1deg); } }
        @keyframes menacing-fade-in { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        body.theme-jojo-menacing {
            --jojo-purple: #9400D3; --jojo-pink: #FF69B4; --jojo-green: #00FF7F;
            --primary-gradient: linear-gradient(135deg, var(--jojo-purple) 0%, var(--jojo-pink) 100%); --secondary-gradient: linear-gradient(135deg, var(--jojo-green) 0%, #ADFF2F 100%); --dark-bg: #4B0082; --card-bg: rgba(75, 0, 130, 0.8); --border-color: var(--jojo-green); --text-primary: #FFFF00; --text-secondary: #FFFFFF; --accent-blue: var(--jojo-pink); --accent-purple: var(--jojo-purple); font-family: 'Bangers', cursive;
            background-color: var(--dark-bg);
            /* Đột phá: Nền "MENACING" (ゴゴゴ) tinh tế, thay thế cho Rinnegan */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Ctext x='50%25' y='50%25' font-family='sans-serif' font-size='48' fill='rgba(255,255,255,0.05)' text-anchor='middle' dominant-baseline='middle'%3Eゴ%3C/text%3E%3C/svg%3E");
        }
        body.theme-jojo-menacing .stage-card, body.theme-jojo-menacing .modal-content {
            border: 4px solid black; border-radius: 4px; box-shadow: 4px 4px 0 var(--jojo-green);
        }
        body.theme-jojo-menacing .result-item {
            border: 4px solid black; border-radius: 4px;
            position: relative;
        }
        /* Hiệu ứng "MENACING" (ゴゴゴゴ) khi hover được giữ nguyên từ phiên bản gốc */
        body.theme-jojo-menacing .result-item::before, body.theme-jojo-menacing .result-item::after {
            position: absolute; color: white; font-size: 2rem; text-shadow: 2px 2px 0 black;
            opacity: 0; transition: opacity 0.3s ease;
            animation: menacing-rumble 0.2s infinite; pointer-events: none;
        }
        body.theme-jojo-menacing .result-item::before { content: 'ゴゴ'; top: 10px; left: 10px; animation-delay: 0.1s; }
        body.theme-jojo-menacing .result-item::after { content: 'ゴゴ'; bottom: 10px; right: 10px; }
        body.theme-jojo-menacing .result-item:hover::before, body.theme-jojo-menacing .result-item:hover::after {
            opacity: 1;
            animation-name: menacing-rumble, menacing-fade-in;
            animation-duration: 0.2s, 0.3s;
            animation-timing-function: linear, ease-out;
            animation-iteration-count: infinite, 1;
        }
        @keyframes rumbling-shake { 0%, 100% { transform: translate(0, 0); } 10% { transform: translate(-2px, -1px); } 20% { transform: translate(2px, 1px); } 30% { transform: translate(-1px, 2px); } 40% { transform: translate(1px, -2px); } 50% { transform: translate(0, 0); } }
        @keyframes crack-glow { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }
        body.theme-aot-rumbling {
            --titan-flesh: #ff4d4d; --survey-corps-green: #285430; --wall-stone: #A9A9A9; --rumbling-bg: #5d4954;
            --primary-gradient: linear-gradient(135deg, var(--titan-flesh) 0%, #b32d2d 100%); --secondary-gradient: linear-gradient(135deg, var(--survey-corps-green) 0%, #1a3821 100%); --dark-bg: var(--rumbling-bg); --card-bg: rgba(40, 30, 35, 0.8); --border-color: rgba(169, 169, 169, 0.4); --text-primary: #EAE0D5; --text-secondary: #C6C5B9; --accent-blue: var(--survey-corps-green); --accent-purple: var(--titan-flesh); font-family: 'Oswald', sans-serif;
            background-color: var(--dark-bg);
            /* Đột phá: Nền bụi đất cuồn cuộn */
            background: radial-gradient(ellipse at bottom, #8a6651 0%, transparent 80%), radial-gradient(ellipse at top, #3c4144 0%, transparent 60%), #5d4954;
            animation: rumbling-shake 10s infinite;
        }
        body.theme-aot-rumbling .stage-card, body.theme-aot-rumbling .modal-content {
            border: none; border-radius: 4px; position: relative;
            /* Đột phá: Viền nứt phát sáng như Titan Đại Hình */
            border-image-source: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="g" x1="0" x2="0" y1="0" y2="100%"><stop offset="0%" stop-color="%23ff4d4d"/><stop offset="100%" stop-color="%23b32d2d"/></linearGradient></defs><rect width="100" height="100" fill="none" stroke-width="6" stroke="url(%23g)"/></svg>');
            border-image-slice: 6; border-image-width: 6px;
            animation: crack-glow 3s infinite ease-in-out;
        }

        /* --- THEME #2: Chainsaw Man: Blood & Guts --- */
        @keyframes pull-cord-stretch { 0% { transform: scaleY(1); } 50% { transform: scaleY(1.2) rotate(2deg); } 100% { transform: scaleY(1); } }
        @keyframes blood-splatter { 0% { transform: scale(0); opacity: 1; } 100% { transform: scale(3); opacity: 0; } }
        /* Đột phá #1: Animation cho viền neon "thở" */
        @keyframes neon-orange-pulse {
            50% { box-shadow: 0 0 15px var(--pochita-orange), 0 0 5px var(--pochita-orange) inset; }
        }

        body.theme-chainsaw-man {
            --blood-red: #B31312; --saw-metal: #71797E; --denim-blue: #2B2A4C; --pochita-orange: #F97B22;
            --primary-gradient: linear-gradient(135deg, var(--pochita-orange) 0%, #F2BE22 100%); --secondary-gradient: linear-gradient(135deg, var(--saw-metal) 0%, #52595d 100%); --dark-bg: var(--denim-blue); --card-bg: rgba(30, 35, 40, 0.9); /* Nền tối hơn để tăng tương phản */ --border-color: rgba(113, 121, 126, 0.5); --text-primary: #ECECEC; --text-secondary: #A9A9A9; --accent-blue: var(--pochita-orange); --accent-purple: var(--blood-red); font-family: 'Poppins', sans-serif;
            background-color: var(--dark-bg);
            position: relative; overflow: hidden;
        }
        body.theme-chainsaw-man::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;
            background: radial-gradient(circle, var(--blood-red) 0%, #2B2A4C 70%);
        }
        body.theme-chainsaw-man::after {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            background: var(--dark-bg);
            clip-path: polygon(0 0, 100% 0, 100% 20%, 80% 25%, 100% 30%, 85% 40%, 100% 50%, 80% 55%, 100% 60%, 85% 70%, 100% 80%, 100% 100%, 0 100%, 15% 90%, 0 80%, 10% 70%, 0 60%, 15% 50%, 0 40%, 10% 30%, 0 20%);
        }

        /* Đột phá #2: Tách biệt nền tối và viền Neon */
        body.theme-chainsaw-man .stage-card, 
        body.theme-chainsaw-man .modal-content, 
        body.theme-chainsaw-man .result-item {
            background-color: var(--card-bg); /* Nền tối để chữ và icon nổi bật */
            border: 2px solid var(--pochita-orange); /* Đường viền cam sắc nét */
            border-radius: 6px;
            box-shadow: 0 0 8px var(--pochita-orange); /* Hiệu ứng neon phát sáng */
            animation: neon-orange-pulse 4s infinite ease-in-out;
            backdrop-filter: blur(3px);
        }
        /* Bỏ các pseudo-element phức tạp không cần thiết */
        body.theme-chainsaw-man .stage-card::before, body.theme-chainsaw-man .stage-card::after,
        body.theme-chainsaw-man .modal-content::before, body.theme-chainsaw-man .modal-content::after,
        body.theme-chainsaw-man .result-item::before, body.theme-chainsaw-man .result-item::after {
            content: none;
        }
        /* Tăng độ sáng khi hover */
        body.theme-chainsaw-man .result-item:hover {
            box-shadow: 0 0 20px var(--pochita-orange);
        }


        /* Nút Search và các hiệu ứng khác giữ nguyên */
        body.theme-chainsaw-man .search-btn {
            position: relative; background: var(--pochita-orange); border: 3px solid #2B2A4C; box-shadow: 0 5px 10px rgba(0,0,0,0.3);
            width: 150px !important; height: 56px !important; border-radius: 12px; padding: 0 !important;
            display: flex !important; justify-content: center !important; align-items: center !important;
            color: #2B2A4C; font-size: 1.2rem; font-weight: 700;
        }
        body.theme-chainsaw-man .search-btn::after {
            content: ''; position: absolute; top: -20px; left: 50%; transform-origin: bottom; transform: translateX(-50%); width: 5px; height: 30px; background: #fff; border-radius: 5px; transition: transform 0.1s ease;
        }
        body.theme-chainsaw-man .search-btn:hover::after { animation: pull-cord-stretch 0.5s infinite; }
        body.theme-chainsaw-man .search-btn .fa-search { display: none !important; }
        body.theme-chainsaw-man .search-btn::before {
            content: ''; position: absolute; top: 50%; left: 50%; width: 100%; height: 100%; background: radial-gradient(circle, var(--blood-red) 10%, transparent 70%); border-radius: 50%; transform-origin: center; transform: scale(0); opacity: 0;
        }
        body.theme-chainsaw-man .search-btn:active::before { animation: blood-splatter 0.3s ease-out; }
        body.theme-chainsaw-man #dresModal .modal-body { display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #dresModal .search-btn { display: flex; justify-content: center; align-items: center; }
        body.theme-chainsaw-man .app-title span {
            font-family: 'Creepster', cursive; color: var(--blood-red); font-size: 2.5rem; text-shadow: 2px 2px 3px rgba(0,0,0,0.5); background: none; -webkit-background-clip: unset; background-clip: unset;
        }

        /* --- THEME #3: Cyberpunk 2077: Netrunner Glitch --- */
        @keyframes text-glitch { 2%,64%{transform:translate(2px,0) skew(0deg)} 4%,60%{transform:translate(-2px,0) skew(0deg)} 62%{transform:translate(0,0) skew(5deg)} }
        @keyframes border-glitch { 0% { clip-path: inset(89% 0 1% 0); } 10% { clip-path: inset(23% 0 34% 0); } 20% { clip-path: inset(55% 0 3% 0); } 30% { clip-path: inset(77% 0 13% 0); } 40% { clip-path: inset(12% 0 81% 0); } 50% { clip-path: inset(90% 0 1% 0); } 60% { clip-path: inset(30% 0 30% 0); } 70% { clip-path: inset(10% 0 80% 0); } 80% { clip-path: inset(50% 0 45% 0); } 90% { clip-path: inset(20% 0 70% 0); } 100% { clip-path: inset(89% 0 1% 0); } }
        body.theme-cyberpunk-glitch {
            --cp-yellow: #fcee0a; --cp-cyan: #00f2fe; --cp-magenta: #f00c8b; --cp-bg: #0a0a0f;
            --primary-gradient: linear-gradient(135deg, var(--cp-yellow) 0%, #ffc107 100%); --secondary-gradient: linear-gradient(135deg, var(--cp-cyan) 0%, #00a2ff 100%); --dark-bg: var(--cp-bg); --card-bg: rgba(10, 10, 15, 0.8); --border-color: rgba(252, 238, 10, 0.5); --text-primary: #E0E0E0; --text-secondary: #A0A0A0; --accent-blue: var(--cp-cyan); --accent-purple: var(--cp-magenta); font-family: 'Share Tech Mono', monospace;
            background-color: var(--dark-bg);
        }
        /* Đột phá: Viền Glitch động và hiệu ứng chữ nhiễu */
        body.theme-cyberpunk-glitch .stage-card, body.theme-cyberpunk-glitch .modal-content {
            position: relative; border: 1px solid var(--border-color);
        }
        body.theme-cyberpunk-glitch .stage-card::before, body.theme-cyberpunk-glitch .modal-content::before { /* Lớp viền glitch màu xanh */
            content:''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border: 1px solid var(--cp-cyan);
            animation: border-glitch 2s infinite linear;
            transform: translateX(-2px);
        }
        body.theme-cyberpunk-glitch .stage-card::after, body.theme-cyberpunk-glitch .modal-content::after { /* Lớp viền glitch màu hồng */
            content:''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border: 1px solid var(--cp-magenta);
            animation: border-glitch 2s infinite linear reverse;
            transform: translateX(2px);
        }
        body.theme-cyberpunk-glitch .app-title {
            color: var(--cp-yellow); /* Đổi màu chữ thành vàng neon */
            text-shadow: 0 0 10px var(--cp-yellow), 0 0 5px rgba(252, 238, 10, 0.7); /* Thêm hiệu ứng phát sáng */
        }
        /* Bỏ hiệu ứng mix-blend-mode không cần thiết chỉ cho theme này */
        body.theme-cyberpunk-glitch .app-title::before {
            content: none;
        }

        /* --- THEME #4: Demon Slayer: Water Breathing --- */
        @keyframes water-flow { 0% { background-position: 0 0; } 100% { background-position: 1000px 0; } }
        body.theme-demon-slayer {
            --water-blue: #3E5F8A; --wave-crest: #FFFFFF; --night-sky: #03001C; --tanjiro-green: #355E3B;
            --primary-gradient: linear-gradient(135deg, var(--water-blue) 0%, #2a4b73 100%); --secondary-gradient: linear-gradient(135deg, var(--wave-crest) 0%, #d4f1f4 100%); --dark-bg: var(--night-sky); --card-bg: rgba(3, 0, 28, 0.8); --border-color: rgba(62, 95, 138, 0.6); --text-primary: #F0F8FF; --text-secondary: #B0C4DE; --accent-blue: var(--water-blue); --accent-purple: var(--tanjiro-green); font-family: 'Noto Serif JP', serif;
            background-color: var(--dark-bg);
            /* Đột phá: Nền tranh thủy mặc Ukiyo-e động */
            background-image: url('https://www.transparenttextures.com/patterns/wavecut.png');
            animation: water-flow 30s linear infinite;
        }
        body.theme-demon-slayer .stage-card, body.theme-demon-slayer .modal-content {
            border: 2px solid var(--border-color); border-radius: 8px;
            box-shadow: 0 0 15px rgba(62, 95, 138, 0.3);
        }
        /* Đột phá: Hiệu ứng nước vỡ ra khi hover */
        body.theme-demon-slayer .result-item {
            position: relative;
            border: 2px solid transparent; transition: border-color 0.3s;
        }
        body.theme-demon-slayer .result-item:hover {
            border-color: var(--wave-crest);
        }
        body.theme-demon-slayer .result-item::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M 0 50 Q 25 20, 50 50 T 100 50" stroke="%23FFFFFF" stroke-width="2" fill="none" opacity="0.7"/></svg>') 0 0 / 100% 100% no-repeat;
            transform: scale(0); opacity: 0;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        body.theme-demon-slayer .result-item:hover::after {
            transform: scale(1.2);
            opacity: 1;
        }
        /* --- THEME ĐỘT PHÁ #2: Ghost in the Shell: Digital Rain --- */
        body.theme-gits-rain {
            --gits-green: #00FF41;
            --gits-bg: #000000;
            --primary-gradient: linear-gradient(135deg, var(--gits-green) 0%, #00c732 100%);
            --secondary-gradient: linear-gradient(135deg, #CCCCCC 0%, #FFFFFF 100%);
            --dark-bg: var(--gits-bg);
            --card-bg: rgba(5, 20, 10, 0.7);
            --border-color: rgba(0, 255, 65, 0.4);
            --text-primary: #EAEAEA;
            --text-secondary: #999999;
            --accent-blue: var(--gits-green);
            --accent-purple: #B0B0B0;
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--gits-bg);
            background-image: none; /* Nền sẽ do canvas xử lý */
        }
        body.theme-gits-rain .main-content-wrapper,
        body.theme-gits-rain .top-toolbar {
            background-color: transparent !important; /* Cho phép nhìn thấy mưa mã hóa */
        }
        body.theme-gits-rain .stage-card,
        body.theme-gits-rain .modal-content {
            backdrop-filter: blur(3px);
            border-radius: 0;
            border: 1px solid var(--border-color);
        }
        body.theme-gits-rain .fas, 
        body.theme-gits-rain .app-title,
        body.theme-gits-rain h3 {
            text-shadow: 0 0 8px var(--gits-green);
        }

        /* --- THEME ĐỘT PHÁ #3: Jujutsu Kaisen: Cursed Domain --- */
        body.theme-jujutsu-domain {
            --cursed-purple: #4B0082; --cursed-red: #8B0000; --cursed-bg: #0d021f;
            --primary-gradient: linear-gradient(135deg, var(--cursed-purple) 0%, #2e0854 100%); --secondary-gradient: linear-gradient(135deg, var(--cursed-red) 0%, #6b0000 100%); --dark-bg: var(--cursed-bg); --card-bg: rgba(13, 2, 31, 0.8); --border-color: rgba(75, 0, 130, 0.5); --text-primary: #D8BFD8; --text-secondary: #9370DB; --accent-blue: var(--cursed-purple); --accent-purple: var(--cursed-red); font-family: 'Poppins', sans-serif;
            background: transparent;
        }
        body.theme-jujutsu-domain::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 2, 31, 0.6);
            z-index: -1;
        }
        /* Giữ hiệu ứng "bẻ cong" cho các card chính và modal */
        body.theme-jujutsu-domain .stage-card, 
        body.theme-jujutsu-domain .modal-content {
            filter: url(#cursed-energy-wobble);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 15px 2px rgba(75, 0, 130, 0.4);
            backdrop-filter: blur(4px);
        }
        body.theme-jujutsu-domain .stage-card:hover {
            box-shadow: 0 0 25px 5px rgba(139, 0, 0, 0.6);
        }

        /* Đột phá: Bỏ hiệu ứng bẻ cong ở ảnh, thay bằng viền neon tím */
        body.theme-jujutsu-domain .result-item {
            border: 2px solid var(--border-color); /* Viền tím nền */
            border-radius: 6px;
            box-shadow: 0 0 10px 2px rgba(75, 0, 130, 0.7); /* Hào quang neon tím */
            transition: box-shadow 0.3s ease, transform 0.3s ease;
            /* BỎ filter: url(#cursed-energy-wobble); */
        }
        body.theme-jujutsu-domain .result-item:hover {
            transform: scale(1.05); /* Phóng to nhẹ khi hover */
            box-shadow: 0 0 20px 5px rgba(139, 0, 0, 0.8); /* Hào quang chuyển sang màu đỏ mạnh hơn */
        }
        @keyframes rain-animation { 0% { background-position: 0% 0%; } 100% { background-position: 20% 100%; } }
        @keyframes neon-glow-red { 0%, 100% { box-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000, 0 0 15px #d10000; } 50% { box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #d10000; } }
        @keyframes scan-line-animation { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
        body.theme-akira-red { --akira-red: #d10000; --neo-tokyo-night: #0a0e1a; --cyber-cyan: #00e5ff; --hud-text: #f0f0f5; --hud-secondary-text: #8b9bb5; --primary-gradient: linear-gradient(135deg, var(--akira-red) 0%, #ff0000 100%); --secondary-gradient: linear-gradient(135deg, var(--cyber-cyan) 0%, #00a2ff 100%); --dark-bg: var(--neo-tokyo-night); --card-bg: rgba(10, 20, 40, 0.75); --border-color: rgba(209, 0, 0, 0.4); --text-primary: var(--hud-text); --text-secondary: var(--hud-secondary-text); --accent-blue: var(--cyber-cyan); --accent-purple: var(--akira-red); font-family: 'Orbitron', sans-serif; background-color: var(--dark-bg); background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAUCAYAAADGNvMAAAABvklEQVRIS+2VwY7EIAxEzT6P0PsZfgsvI3eAIN7jj7eA25rJpDQxUbrwY+0KIe10Ol1FkTQGgMXo/QGATgDgtpP4I9l223ZLnYdYBGADQADFQRB8PwDguY5nCILgGyH2APYA6AAsA+gC7JbL5RLPR9u2C0KIALStNwB2z7P98xsA7nkeIeQYgDNpmgYdxyGEzAAAAAD+59vtnxcA/D/P8w1A+jQARGtNSSnLspVlWfI8L4Q4AGfVarV83z8yAABmq1bZtm0I4R2ANU3TGNNaKaUymUwY4znnzk1grbUymYxarcY5Z5rG8zzfN0IIYWw2mwLAnHPG2GSzWeecYWzGGI7jvB4AgJRSKaW12g0AABKpbVtKqcVi0bZtpdQ0jQDAUmvNZrPZ7Xa1Wk3T6PV60zRmZgDA8zxSSrZt27ZtIYS11nmeGGMymcyyLOM4lmWl1Gq1LMsAAHa7XSwWAwD+bpo26+DxeBDGmMVi0W638zx/IIRSSpIkSZIky/OMMeccAGqtNdNa6/F4ZDabQggZZq11dXV1dHT09PS0Wq0yxhhjkiRarTYxBtba2u12pZTSNO04joQQYwzG2Gy28fHxs9lsjPFx//4/gplcjJGCi/gAAAAASUVORK5CYII="), radial-gradient(ellipse at center, rgba(10, 20, 40, 0.8) 0%, var(--dark-bg) 70%); animation: rain-animation 3s linear infinite; }
        body.theme-akira-red .stage-card, body.theme-akira-red .modal-content { border: 2px solid var(--border-color); border-radius: 4px; position: relative; overflow: hidden; animation: neon-glow-red 4s ease-in-out infinite; background-image: linear-gradient(var(--card-bg), var(--card-bg)), url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAJUlEQVR42u3NQQEAAAQEsJN/o3fYCaZXTAcSoECBAgQIECBAgAABfQIuAABgjp+2VgAAAABJRU5ErkJggg=="); backdrop-filter: blur(5px); }
        body.theme-akira-red .result-item::before, body.theme-akira-red .stage-card:hover::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, transparent, rgba(0, 229, 255, 0.5), transparent); animation: scan-line-animation 2s linear infinite; pointer-events: none; z-index: 2; }
        body.theme-akira-red .app-title span { color: var(--akira-red); text-shadow: 0 0 10px #ff0000, 0 0 20px #d10000; background: none; -webkit-background-clip: unset; background-clip: unset; }
        body.theme-akira-red .fas { color: var(--cyber-cyan); text-shadow: 0 0 10px var(--cyber-cyan); }
        @keyframes rasengan-spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        body.theme-naruto-leaf {
            --primary-gradient: linear-gradient(135deg, #FF8C00 0%, #FFA500 100%); --secondary-gradient: linear-gradient(135deg, #2E8B57 0%, #3CB371 100%); --dark-bg: #1a2a1a; --card-bg: rgba(10, 40, 30, 0.7); --border-color: rgba(46, 139, 87, 0.4); --text-primary: #F0F0E0; --text-secondary: #A0B0A0; --accent-blue: #FF8C00; --accent-purple: #4A90E2; font-family: 'Kalam', cursive;
        }
        /* == ĐẶC TRƯNG NARUTO: Hiệu ứng Rasengan khi hover == */
        body.theme-naruto-leaf .result-item {
            position: relative; overflow: hidden;
        }
        body.theme-naruto-leaf .result-item::before { /* Lõi Chakra */
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 200px; height: 200px;
            background: radial-gradient(circle, rgba(74, 144, 226, 0.8) 10%, rgba(74, 144, 226, 0) 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            opacity: 0;
        }
        body.theme-naruto-leaf .result-item:hover::before {
            transform: translate(-50%, -50%) scale(1.5);
            opacity: 1;
        }
        body.theme-naruto-leaf .result-item::after { /* Vòng xoáy Chakra */
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 250px; height: 250px;
            background: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><path d="M50,0 A50,50 0 0,1 100,50" fill="none" stroke="rgba(255,255,255,0.5)" stroke-width="2"/><path d="M0,50 A50,50 0 0,1 50,100" fill="none" stroke="rgba(255,255,255,0.5)" stroke-width="2"/></svg>');
            background-size: 50%;
            transform: translate(-50%, -50%) scale(0);
            border-radius: 50%;
            animation: rasengan-spin 2s linear infinite;
            transition: transform 0.3s ease-out;
            opacity: 0;
        }
        body.theme-naruto-leaf .result-item:hover::after {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 1;
            transition-delay: 0.1s;
        }

        /* --- THEME #2: BLEACH: GETSUGA TENSHOU --- */
        @keyframes getsuga-flash { 0% { opacity: 0; transform: scaleX(0.5); } 50% { opacity: 1; } 100% { opacity: 0; transform: scaleX(1.5); } }
        body.theme-bleach-soul {
            --primary-gradient: linear-gradient(135deg, #FFFFFF 0%, #D3D3D3 100%); --secondary-gradient: linear-gradient(135deg, #C50000 0%, #9D0000 100%); --dark-bg: #000000; --card-bg: rgba(15, 15, 15, 0.85); --border-color: rgba(255, 255, 255, 0.2); --text-primary: #FFFFFF; --text-secondary: #A0A0A0; --accent-blue: #00EEFF; --accent-purple: #C50000; font-family: 'Oswald', sans-serif;
            background-color: var(--dark-bg);
        }
        /* == ĐẶC TRƯNG BLEACH: Hiệu ứng nhát chém Getsuga Tenshou == */
        body.theme-bleach-soul .search-btn { position: relative; overflow: hidden; }
        body.theme-bleach-soul .search-btn:hover::before {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 300%; height: 10px;
            background: radial-gradient(ellipse, white, var(--accent-blue), transparent);
            transform: translate(-50%, -50%) rotate(-20deg);
            animation: getsuga-flash 0.5s ease-out forwards;
        }
        body.theme-bleach-soul .result-item {
            border: 1px solid var(--border-color);
            box-shadow: 0 0 8px 1px rgba(0, 238, 255, 0.1);
            transition: box-shadow 0.3s ease, transform 0.3s ease;
        }
        body.theme-bleach-soul .result-item:hover {
            transform: scale(1.03);
            box-shadow: 0 0 20px 5px rgba(0, 238, 255, 0.4);
        }

        /* --- THEME #3: ZERO TWO: KLAXOSAUR CORE & RETICLE --- */
        @keyframes core-pulse { 0%, 100% { transform: scale(0.95); box-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; } 50% { transform: scale(1.05); box-shadow: 0 0 30px #00a2ff, 0 0 50px #00a2ff; } }
        @keyframes reticle-fade-in { from { opacity: 0; } to { opacity: 1; } }
        body.theme-zero-two-franxx {
            --primary-gradient: linear-gradient(135deg, #F472B6 0%, #EC4899 100%); --secondary-gradient: linear-gradient(135deg, #FFFFFF 0%, #E5E7EB 100%); --dark-bg: #1A1B26; --card-bg: rgba(35, 37, 54, 0.7); --border-color: rgba(244, 114, 182, 0.3); --text-primary: #F5F3FF; --text-secondary: #A7A2C3; --accent-blue: #EC4899; --accent-purple: #EF4444; font-family: 'Orbitron', sans-serif;
            background-color: var(--dark-bg);
            background-image: repeating-linear-gradient(rgba(244, 114, 182, 0.05) 1px, transparent 1px, transparent 20px), repeating-linear-gradient(90deg, rgba(244, 114, 182, 0.05) 1px, transparent 1px, transparent 20px);
        }
        body.theme-zero-two-franxx .stage-card, body.theme-zero-two-franxx .modal-content { border: 1px solid var(--border-color); clip-path: polygon(0 10px, 10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%); border-radius: 0; }
        /* == ĐẶC TRƯNG ZERO TWO: Lõi Klaxosaur và Khung Ngắm Mục Tiêu == */
        body.theme-zero-two-franxx .app-logo {
            border-radius: 50%;
            animation: core-pulse 3s infinite ease-in-out;
        }
        body.theme-zero-two-franxx .result-item { position: relative; overflow: hidden; }
        body.theme-zero-two-franxx .result-item::after { /* Khung ngắm mục tiêu (reticle) */
            content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M50,10 V30 M50,70 V90 M10,50 H30 M70,50 H90" stroke="%23EC4899" stroke-width="2"/><circle cx="50" cy="50" r="15" stroke="%23EC4899" stroke-width="2" fill="none"/></svg>');
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; transition: opacity 0.3s ease;
            animation: reticle-fade-in 0.5s;
            transform: scale(0.8);
        }
        body.theme-zero-two-franxx .result-item:hover::after {
            opacity: 1;
        }

        /* --- THEME #4: EVANGELION: LCL & NERV UI (Cải tiến) --- */
        @keyframes lcl-bubbles {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100vh); }
        }
        body.theme-eva-nerv {
            --eva-purple: #8A2BE2; --eva-green: #00FF00; --eva-red-alert: #FF3131; --nerv-bg: #1a1a2d; --hud-text: #E0E0E0;
            --primary-gradient: linear-gradient(135deg, var(--eva-purple) 0%, #6a0dad 100%); --secondary-gradient: linear-gradient(135deg, var(--eva-green) 0%, #00c700 100%); --dark-bg: var(--nerv-bg); --card-bg: rgba(26, 26, 45, 0.8); --border-color: rgba(0, 255, 0, 0.3); --text-primary: var(--hud-text); --text-secondary: #a0a0c8; --accent-blue: var(--eva-green); --accent-purple: var(--eva-red-alert); font-family: 'Oswald', sans-serif;
            background-color: #ff8c00; /* LCL Orange */
            overflow: hidden; /* Quan trọng để bong bóng không tràn ra ngoài */
            position: relative;
        }
        /* == ĐẶC TRƯNG EVA: Nền Bong Bóng LCL động == */
        body.theme-eva-nerv::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;
            background-color: var(--nerv-bg);
        }
        body.theme-eva-nerv::after {
            content: ''; position: fixed; top: 100%; left: 0; width: 300%; height: 100vh;
            background-image: radial-gradient(circle, rgba(255, 165, 0, 0.3) 10%, transparent 11%),
                            radial-gradient(circle, rgba(255, 165, 0, 0.2) 20%, transparent 21%);
            background-size: 50px 50px, 80px 80px;
            animation: lcl-bubbles 25s linear infinite;
            z-index: -1;
        }
        body.theme-eva-nerv .stage-card, body.theme-eva-nerv .modal-content, body.theme-eva-nerv .result-item {
            border-radius: 0; clip-path: polygon(0 8px, 8px 0, calc(100% - 8px) 0, 100% 8px, 100% calc(100% - 8px), calc(100% - 8px) 100%, 8px 100%, 0 calc(100% - 8px)); border: 1px solid var(--border-color); box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(2px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        body {
            background: var(--dark-bg);
            background-image:
                radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 80% 80%, rgba(240, 147, 251, 0.2) 0%, transparent 60%);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .top-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(10, 14, 26, 0.7);
            backdrop-filter: blur(30px);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: var(--shadow-light);
            height: 76px;
        }
        .toolbar-left, .toolbar-right { display: flex; gap: 24px; align-items: center; }
        .app-title {
            font-size: 1.7rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .app-logo {
            height: 54px;
            width: 54px;
            border-radius: 0;
            object-fit: cover;
        }
        .model-btn-wrapper { position: relative; }
        .toolbar-btn {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 10px 18px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        .toolbar-btn .btn-hover-bg { position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: var(--primary-gradient); transition: left 0.3s ease; z-index: 0; }
        .toolbar-btn > span { position: relative; z-index: 1; display: flex; align-items: center; gap: 10px; }
        .toolbar-btn:hover .btn-hover-bg { left: 0; }
        .toolbar-btn:hover {
            transform: translateY(-2px) scale(1.03);
            border-color: var(--accent-blue);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.35);
            color: var(--text-primary);
        }

        .toolbar-btn.active {
            background: var(--success-gradient);
            border-color: var(--accent-blue);
            color: var(--text-primary);
            font-weight: 600;
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.4);
        }

        .model-dropdown { display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: var(--card-bg); backdrop-filter: blur(20px); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow-heavy); padding: 12px; z-index: 101; width: 220px; }
        .main-content-wrapper {
            display: flex;
            flex-grow: 1;
            padding-top: 76px;
            height: 100vh;
            gap: 4px;
        }

        #left-search-panel {
            width: 380px;
            flex-shrink: 0;
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-light);
            border-radius: var(--radius) 0 0 var(--radius);
        }

        #right-results-panel {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(10, 14, 26, 0.2);
            border-radius: 0 var(--radius) var(--radius) 0;
        }

        .stages-container { display: flex; flex-direction: column; gap: 24px; padding-top: 24px; overflow-y: auto; padding-right: 12px; flex-grow: 1; }
        .stage-card {
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border-radius: var(--radius);
            padding: 24px;
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .stage-card:hover {
            transform: translateY(-4px) scale(1.01);
            box-shadow: var(--shadow-heavy);
            border-color: var(--accent-blue);
        }

        .stage-number {
            position: absolute;
            top: -12px;
            left: 12px;
            background: var(--primary-gradient);
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
            z-index: 1;
        }
        .stage-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .query-types {
            display: flex;
            gap: 10px;
            flex-wrap: nowrap; /* Ngăn không cho các nút xuống hàng */
            flex-grow: 1;     /* Yêu cầu nó chiếm hết không gian trống còn lại */
        }
        .type-btn {
            width: 44px;
            height: 44px;
            font-size: 1.1rem;
            background: var(--glass-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            position: relative;
            overflow: hidden;
        }

        .type-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: var(--primary-gradient);
            border-radius: 50%;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            z-index: -1;
        }

        .type-btn.active::before {
            width: 200%;
            height: 200%;
        }

        .type-btn.active {
            background: transparent;
            border-color: var(--accent-blue);
            color: var(--text-primary);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.3);
        }

        .type-btn[data-type="asr"].active,
        .type-btn[data-type="ocr"].active,
        .type-btn[data-type="gen_image"].active {
            border-color: var(--accent-pink);
            box-shadow: 0 8px 20px rgba(240, 147, 251, 0.3);
        }

        .type-btn[data-type="asr"].active::before,
        .type-btn[data-type="ocr"].active::before,
        .type-btn[data-type="gen_image"].active::before {
            background: var(--secondary-gradient);
        }

        .type-btn:hover:not(.active) {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            transform: translateY(-2px);
        }
        .delete-stage {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(244, 63, 94, 0.1);
            border: 1px solid rgba(244, 63, 94, 0.3);
            color: #f43f5e;
            width: 16px; /* Có thể giảm kích thước một chút cho gọn */
            height: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10; /* Đảm bảo nó nằm trên các phần tử khác */
        }
        .delete-stage:hover { background: rgba(244, 63, 94, 0.2); transform: scale(1.1) rotate(5deg); box-shadow: 0 4px 15px rgba(244, 63, 94, 0.3); }
        .stage-options { display: flex; gap: 12px; margin-top: 20px; }
        .option-btn { background: var(--glass-bg); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 8px 16px; border-radius: 10px; font-size: 0.85rem; cursor: pointer; transition: all 0.3s ease; font-weight: 500; }
        .option-btn.active { background: var(--success-gradient); border-color: var(--accent-blue); color: var(--text-primary); font-weight: 600; box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3); }
        .option-btn:hover:not(.active) { border-color: var(--accent-blue); color: var(--accent-blue); transform: translateY(-1px); }
        .panel-controls { display: flex; justify-content: space-between; align-items: center; margin-top: auto; flex-shrink: 0; padding-top: 24px; border-top: 1px solid var(--border-color); }
        .stage-controls { display: flex; gap: 16px; }
        .control-btn { width: 54px; height: 54px; border-radius: 14px; border: 1px solid var(--border-color); background: var(--glass-bg); color: var(--text-secondary); font-size: 1.4rem; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .control-btn:hover { background: var(--primary-gradient); transform: scale(1.05) translateY(-2px); color: var(--text-primary); border-color: var(--accent-blue); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4); }
        .search-btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 14px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .search-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .search-btn:hover::before {
            left: 100%;
        }

        .search-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        .search-btn:active {
            transform: scale(0.98);
        }
        .query-input-area { margin-top: 15px; position: relative; }
        .stage-input { width: 100%; padding: 12px 16px; background: var(--glass-bg); backdrop-filter: blur(10px); border: 1px solid var(--border-color); border-radius: 12px; color: var(--text-primary); font-size: 1.0rem; line-height: 1.5; resize: vertical; transition: all 0.3s ease; font-family: inherit; }
        .main-query-input { min-height: 80px; }
        .stage-input:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2); background: rgba(79, 172, 254, 0.05); }
        .stage-input-file { display: none; }
        .image-upload-zone { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 160px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--glass-bg); color: var(--text-secondary); cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden; backdrop-filter: blur(10px); }
        .image-upload-zone.dragover { border-color: var(--accent-blue); background: rgba(79, 172, 254, 0.1); transform: scale(1.02); }
        .image-upload-zone:hover { border-color: var(--accent-purple); background: rgba(102, 126, 234, 0.05); }
        .image-upload-zone i { font-size: 2.5rem; margin-bottom: 10px; }
        .image-upload-zone p { font-size: 0.9rem; text-align: center; }
        .image-preview { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; }
        .remove-image-btn { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255, 255, 255, 0.3); color: #e2e8f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; z-index: 2; }
        .remove-image-btn:hover { background: #ef4444; color: white; border-color: transparent; }
        .model-dropdown-item { display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .model-dropdown-item:hover { background: var(--glass-bg); }
        .model-dropdown-item.focused { background: var(--glass-bg); outline: 2px solid var(--accent-blue); outline-offset: -2px; }
        .model-dropdown-item input[type="checkbox"] { margin-right: 10px; accent-color: var(--accent-blue); }
        .model-dropdown-item label { cursor: pointer; user-select: none; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; }
        .result-item { background: var(--card-bg); backdrop-filter: blur(15px); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); aspect-ratio: 16 / 9; cursor: pointer; position: relative; }
        .result-item:hover { transform: scale(1.03) translateY(-4px); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); border-color: var(--accent-blue); }
        /* ## LAZY LOADING STYLES ## */
        .result-item img { width: 100%; height: 100%; object-fit: cover; display: block; transition: transform 0.3s ease, opacity 0.4s ease-in-out; opacity: 0; }
        .result-item img.loaded { opacity: 1; }
        /* ######################## */
        .result-item:hover img { transform: scale(1.05); }
        .submit-btn { position: absolute; top: 8px; right: 8px; background: rgba(79, 172, 254, 0.8); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s; display: none; align-items: center; justify-content: center; z-index: 5; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); z-index: 1000; display: none; align-items: center; justify-content: center; }
        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            border-radius: 20px;
            box-shadow: var(--shadow-heavy);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--glass-bg);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--accent-blue);
            font-weight: 600;
        }

        .modal-close {
            font-size: 1.6rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .modal-close:hover {
            color: #ef4444;
            transform: rotate(90deg);
        }
        .modal-body { padding: 25px; display: flex; gap: 30px; overflow-y: auto; }
        .modal-body .filter-input { background: rgba(10, 14, 26, 0.8); border: 1px solid var(--border-color); color: white; border-radius: 6px; padding: 8px 10px; font-size: 0.95rem; width: 100%; }
        .modal-body .filter-input:focus { outline: none; border-color: var(--accent-blue); }
        .dres-status { margin-top: 15px; font-size: 0.9rem; color: var(--text-secondary); text-align: center; width: 100%; }
        .filter-section { flex: 1; display: flex; flex-direction: column; }
        .filter-section-header { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .filter-section-title { font-size: 1.2rem; color: var(--accent-blue); }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(22px); }
        .filter-controls-container { display: flex; flex-direction: column; gap: 15px; }
        .count-filter-row { display: grid; grid-template-columns: 30px 1fr 120px; align-items: center; gap: 10px; cursor: pointer; padding: 8px; border-radius: 8px; border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s; }
        .count-filter-row:hover { background-color: rgba(79, 172, 254, 0.1); }
        .count-filter-row.active-row { background-color: rgba(79, 172, 254, 0.15); border-color: rgba(79, 172, 254, 0.4); }
        .count-filter-row.custom { grid-template-columns: 30px 1fr 120px 30px; }
        .count-filter-row input[type=checkbox] { accent-color: var(--accent-blue); width: 18px; height: 18px; cursor: pointer; }
        .count-filter-row label { font-size: 1rem; color: var(--text-primary); }
        .add-custom-btn, .remove-custom-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary); width: 30px; height: 30px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .add-custom-btn:hover, .remove-custom-btn:hover { border-color: var(--accent-blue); color: var(--accent-blue); }
        #positioningCanvas { background: #1e293b; border-radius: 10px; cursor: crosshair; touch-action: none; }
        .drawn-boxes-list { max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .drawn-box-item { display: flex; align-items: center; justify-content: space-between; background: #1e293b; padding: 8px; border-radius: 6px; }
        .drawn-box-item.active { border-left: 3px solid var(--accent-blue); }
        .shortcuts-info { font-size: 0.8rem; color: var(--text-secondary); margin-top: 10px; line-height: 1.6; }
        .image-modal-overlay { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(20px); align-items: center; justify-content: center; }
        .image-modal-content { margin: auto; display: block; max-width: 90vw; max-height: 90vh; animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 12px; box-shadow: var(--shadow-heavy); }
        @keyframes modalZoom { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .image-modal-close { position: absolute; top: 20px; right: 40px; color: var(--text-primary); font-size: 24px; font-weight: bold; transition: all 0.3s ease; cursor: pointer; z-index: 2101; background: rgba(0, 0, 0, 0.5); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .image-modal-close:hover { color: var(--accent-pink); transform: scale(1.1) rotate(90deg); background: rgba(244, 63, 94, 0.2); }
        #temporalContextModal, #dresModal { z-index: 2000; }
        #imageModal, #videoPreviewModal { z-index: 2100; }
        #temporalContextModal .temporal-modal-content { background: var(--dark-bg); border: 1px solid var(--border-color); border-radius: 16px; width: 95%; max-width: 1600px; height: auto; max-height: 95vh; display: flex; flex-direction: column; box-shadow: var(--shadow-heavy); animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        #temporalContextModal .temporal-modal-header { padding: 16px 24px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        #temporalContextModal #temporalModalTitle { font-size: 1.2rem; font-weight: 600; color: var(--text-primary); }
        #temporalContextModal .image-modal-close { position: static; width: 36px; height: 36px; font-size: 1.2rem; }
        #temporalContextModal .temporal-modal-body { padding: 24px; overflow-y: auto; flex-grow: 1; }
        .temporal-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; }
        .temporal-grid-item { position: relative; background-color: var(--glass-bg); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; aspect-ratio: 16 / 9; cursor: pointer; transition: all 0.2s ease-in-out; }
        .temporal-grid-item:hover { transform: scale(1.05); border-color: var(--accent-blue); z-index: 10; }
        .temporal-grid-item.center-frame { border: 2px solid var(--accent-purple); box-shadow: 0 0 15px rgba(102, 126, 234, 0.6); }
        .temporal-grid-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .temporal-item-label { position: absolute; top: 4px; left: 4px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
        #temporalContextModal .temporal-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-color); text-align: center; font-size: 0.9rem; color: var(--text-secondary); flex-shrink: 0; }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-gradient);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-gradient);
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #loadingIndicator {
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--accent-blue);
            font-size: 1.1rem;  /* Giảm kích thước */
            padding: 20px 12px;
            gap: 8px;
            animation: pulse 1s infinite;  /* Nhanh hơn */
        }

        #loadingIndicator i {
            font-size: 1.5rem;  /* Giảm kích thước */
        }
        .processed-query-display-wrapper { display: none; margin-top: 10px; padding: 8px 12px; background: rgba(0,0,0,0.25); border-radius: 8px; border-left: 3px solid var(--accent-purple); align-items: center; gap: 10px; transition: all 0.3s ease; }
        .processed-query-display-wrapper i { color: var(--accent-purple); }
        .processed-query-display { font-size: 0.9rem; color: var(--text-secondary); font-style: italic; word-break: break-all; }
        .timing-info-container { display: none; flex-wrap: wrap; gap: 12px 20px; padding: 16px; background: var(--glass-bg); border: 1px solid var(--border-color); border-radius: 12px; backdrop-filter: blur(10px); margin: 24px; }
        .timing-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
        .timing-item .timing-label { color: var(--text-secondary); display: flex; align-items: center; gap: 6px; }
        .timing-item .timing-value { font-weight: 600; color: var(--text-primary); background-color: rgba(255, 255, 255, 0.1); padding: 3px 8px; border-radius: 6px; }
        .timing-item.total-time .timing-value { font-weight: 700; font-size: 1rem; }
        .timing-item.client-time .timing-value { background-color: rgba(240, 147, 251, 0.15); color: var(--accent-pink); }
        .timing-item.server-time .timing-value { background-color: rgba(79, 172, 254, 0.15); color: var(--accent-blue); }
        .cluster-separator { border: 0; height: 1px; background-image: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0)); margin: 40px 0; }
        .cluster-header { color: var(--accent-purple); font-size: 1.1rem; margin-bottom: 12px; padding-left: 8px; border-left: 3px solid var(--accent-purple); }
        .temporal-stage-grid-container { margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color); }
        .temporal-stage-grid-container:first-of-type { margin-top: 0; padding-top: 0; border-top: none; }
        #usernameModal { z-index: 3000; }
        #resultsContainer { padding: 0 24px 24px 24px; }

        /* ## START: Teamwork Panel CSS Changes ## */
        #teamworkPanelContainer {
            padding-top: 24px;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0; /* ## FIX: Stick flush to the top ## */
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(15px);
            z-index: 50;
        }
        #teamworkPanelContainer h3 {
            font-size: 1.3rem;
            color: var(--accent-purple);
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 0 24px;
        }
        #teamworkGrid {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 16px;
            padding: 0 24px 24px 24px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #teamworkGrid::-webkit-scrollbar { display: none; }
        #teamworkGrid .result-item {
            flex: 0 0 220px;
        }
        
        .teamwork-item {
            border: 3px solid var(--user-color, var(--accent-blue));
            border-radius: 12px;
            box-shadow: 0 0 12px var(--user-color, var(--accent-blue));
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .teamwork-item:hover {
            transform: scale(1.03) translateY(-4px);
            box-shadow: 0 12px 30px var(--user-color, var(--accent-blue));
        }

        .teamwork-item-user-label {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            border-left: 3px solid var(--user-color, var(--accent-blue));
        }

        /* ## START: CSS FIX FOR BLUE CIRCLE ## */
        .temporal-grid-item:hover .submit-btn,
        .teamwork-item:hover .submit-btn {
            display: flex;
        }
        /* ## END: CSS FIX FOR BLUE CIRCLE ## */

        .submit-btn:hover {
            background: var(--accent-blue);
            transform: scale(1.1);
        }
        /* ## END: Teamwork Panel CSS Changes ## */

        #google-image-search-container {
            padding-bottom: 24px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .google-search-header {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }
        .google-search-header .fa-google {
            color: var(--accent-blue);
        }
        .google-search-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #googleSearchInput {
            flex-grow: 1;
        }
        #googleSearchBtn {
            width: auto;
            height: 48px;
            padding: 0 16px;
        }
        #google-image-results-wrapper {
            margin-top: 16px;
        }
        #google-image-results {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 10px;
            background: var(--glass-bg);
            border-radius: 12px;
            min-height: 120px;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .google-image-item {
            flex: 0 0 160px;
            height: 90px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s ease, transform 0.2s ease;
        }

        .google-image-item:hover {
            border-color: var(--accent-blue);
            transform: scale(1.05);
        }
        .google-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .google-image-item .overlay-actions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .google-image-item:hover .overlay-actions {
            opacity: 1;
        }
        .google-image-item .overlay-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        .google-image-item .overlay-btn:hover {
            background: var(--accent-blue);
            transform: scale(1.1);
        }
    /* ## START: NEW CSS FOR VIDEO PREVIEW ENHANCEMENTS ## */
        .video-player-container {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-frame-info-display {
            position: absolute;
            bottom: -5px; /* Position it on top of the video player */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(5px);
            color: var(--text-secondary);
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 2101; /* Make sure it's on top of the video */
            pointer-events: none; /* Allows clicks to pass through to the video */
            border: 1px solid var(--border-color);
        }

        /* ## END: NEW CSS FOR VIDEO PREVIEW ENHANCEMENTS ## */
        
        /* === BƯỚC 2: CSS CHO NÚT MICRO === */
        .mic-btn.recording {
            background: transparent;
            border-color: #f43f5e; /* Màu đỏ */
            color: #f43f5e;
            box-shadow: 0 8px 20px rgba(244, 63, 94, 0.3);
        }

        .mic-btn.recording::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(135deg, #f5576c 0%, #f43f5e 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: -1;
            animation: pulse-red 1.5s infinite; /* Thêm hiệu ứng pulse */
        }
        @keyframes pulse-red {
            0% { transform: translate(-50%, -50%) scale(0.9); }
            70% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(0.9); }
        }
        /* === KẾT THÚC CSS CHO NÚT MICRO === */

        #correctSubmissionPanel {
            position: fixed; /* Hoặc 'sticky' nếu bạn muốn nó cuộn cùng một chút */
            top: 90px;
            right: 20px;
            width: 250px;
            background: var(--card-bg);
            backdrop-filter: blur(25px);
            border: 2px solid #4ade80; /* Màu xanh lá cây cho thành công */
            border-radius: var(--radius);
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.6);
            z-index: 150;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation: fadeInRight 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #correctSubmissionPanel h4 {
            color: #4ade80;
            text-align: center;
            font-size: 1.1rem;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #correctSubmissionImageContainer {
            width: 100%;
            aspect-ratio: 16 / 9;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        #correctSubmissionImageContainer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #correctSubmissionPanel .reset-note {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            margin: 0;
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        /* ## END: CORRECT SUBMISSION PANEL STYLES ## */

        /* ## START: SUBMISSION STATUS STYLES ## */
        .result-item.submitting {
            opacity: 0.6;
            pointer-events: none; /* Vô hiệu hóa click khi đang nộp */
        }

        .result-item.submitted-wrong .teamwork-item-user-label {
            background: #ef4444; /* Màu đỏ cho nộp sai */
            border-left-color: #f87171;
        }

        .result-item.submitted-wrong {
            border-color: #ef4444 !important;
            box-shadow: 0 0 12px #ef4444;
        }

        .result-item.submitted-duplicate .teamwork-item-user-label {
            background: #f59e0b; /* Màu vàng cho trùng lặp */
            border-left-color: #fbbf24;
        }

        .result-item.submitted-duplicate {
            border-color: #f59e0b !important;
            box-shadow: 0 0 12px #f59e0b;
        }

        #correctSubmissionImageContainer .result-item {
            /* Ép item lấp đầy container cha của nó */
            width: 100%;
            height: 100%;
            
            /* Ghi đè các thuộc tính có thể gây ra hiển thị sai */
            margin: 0;
            border: none; /* Container cha đã có border xanh */
            box-shadow: none !important; /* Vô hiệu hóa bóng đổ khi hover */
            transform: none !important; /* Vô hiệu hóa hiệu ứng 'nhấc' lên khi hover */
            cursor: default; /* Bỏ cursor pointer của chính item */
        }

        #correctSubmissionImageContainer .result-item img {
            cursor: pointer; /* Đặt lại cursor pointer cho ảnh bên trong */
        }

        /* Đảm bảo hiệu ứng hover scale trên ảnh vẫn hoạt động */
        #correctSubmissionImageContainer .result-item:hover img {
            transform: scale(1.05);
        }
        /* ## END: CSS FIX ## */

        /* ## START: SUBMISSION STATUS OVERLAY STYLES ## */
        .submission-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 26, 0.7);
            backdrop-filter: blur(5px);
            border-radius: inherit; /* Kế thừa bo góc của item cha */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: white;
            
            /* Hiệu ứng */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 5;
            pointer-events: none; /* Cho phép click xuyên qua nếu cần */
        }

        .submission-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .submission-overlay i {
            font-size: 2.2rem;
            margin-bottom: 5px;
        }

        /* Trạng thái: Đang xử lý */
        .submission-overlay.status-pending {
            color: var(--accent-blue);
        }

        /* Trạng thái: Đúng */
        .submission-overlay.status-correct {
            background: rgba(74, 222, 128, 0.7); /* Xanh lá */
            color: white;
        }

        /* Trạng thái: Sai */
        .submission-overlay.status-wrong {
            background: rgba(244, 63, 94, 0.7); /* Đỏ */
            color: white;
        }

        /* Trạng thái: Trùng lặp */
        .submission-overlay.status-duplicate {
            background: rgba(245, 158, 11, 0.7); /* Vàng */
            color: white;
        }
        /* ## END: SUBMISSION STATUS OVERLAY STYLES ## */
        .theme-btn-wrapper { position: relative; }
        .theme-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: var(--shadow-heavy);
            padding: 12px;
            z-index: 101;
            width: 220px;
        }
        .theme-dropdown-item {
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }
        .theme-dropdown-item:hover { background: var(--glass-bg); }
        .theme-color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }
        /* ## END: THEME SWITCHER STYLES ## */

        /* ## START: TRAKE PANEL STYLES ## */
        #trakePanelContainer {
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(15px);
            z-index: 49; /* Below teamwork panel */
        }
        #trakePanelContainer h3 {
            font-size: 1.3rem;
            color: var(--accent-pink);
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 24px 24px 0 24px;
        }
        #trakeGrid {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 16px;
            padding: 16px 24px 24px 24px;
            min-height: 150px; /* Ensure panel has height even when empty */
        }
        #trakeGrid .result-item {
            flex: 0 0 220px; /* Fixed width for trake items */
            border: 2px solid var(--accent-pink);
            cursor: grab;
        }
        #trakeGrid .result-item:active { cursor: grabbing; }
        .trake-item-actions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: flex-end;
            padding: 8px;
            gap: 6px;
        }
        .trake-action-btn {
            background: rgba(10, 14, 26, 0.8);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 6;
        }
        .result-item:hover .trake-action-btn { display: flex; }
        .trake-action-btn:hover {
            background: var(--primary-gradient);
            color: white;
            transform: scale(1.1);
        }
        /* Dragging ghost style */
        .ghost { opacity: 0.4; }
        /* Nearby frames list */
        .nearby-frames-container {
            position: absolute;
            bottom: 105%;
            left: 0;
            width: 100%;
            max-height: 200px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 20;
            padding: 8px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            animation: fadeIn 0.3s;
        }
        .nearby-frame-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .nearby-frame-item:hover { background-color: var(--glass-bg); }
        .nearby-frame-item img {
            width: 80px;
            height: 45px;
            object-fit: cover;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .nearby-frame-item .time-offset { font-weight: 600; }
        .nearby-frame-item.loading { justify-content: center; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
         /* ## START: NEARBY FRAMES SIDEBAR STYLES ## */
        .nearby-frames-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2500;
            display: flex;
            justify-content: flex-end;
        }
        .sidebar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
        }
        .sidebar-content {
            position: relative;
            width: 300px;
            height: 100%;
            background: var(--dark-bg);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-heavy);
            display: flex;
            flex-direction: column;
            animation: slideInFromRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .sidebar-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .sidebar-header h3 { color: var(--accent-blue); font-size: 1.2rem; }
        .sidebar-grid {
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-grow: 1;
        }
        .sidebar-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background: var(--glass-bg);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .sidebar-item:hover {
            border-color: var(--accent-blue);
            background: rgba(79, 172, 254, 0.1);
        }
        .sidebar-item img {
            width: 128px;
            height: 72px;
            object-fit: cover;
            border-radius: 6px;
            flex-shrink: 0;
        }
        .sidebar-item .time-offset { font-weight: 600; font-size: 1rem; }
        @keyframes slideInFromRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        /* ## END: NEARBY FRAMES SIDEBAR STYLES ## */
        body.video-modal-active.theme-gits-rain #digitalRainCanvas {
            display: none !important;
        }
        body.video-modal-active.theme-jujutsu-domain .stage-card,
        body.video-modal-active.theme-jujutsu-domain .modal-content,
        body.video-modal-active.theme-jujutsu-domain .result-item {
            filter: none !important;
        }
        body.video-modal-active.theme-akira-red {
            animation: none !important;
        }
    </style>
</head>
<body>
    <video autoplay loop muted playsinline id="cursedDomainVideo">
        <source src="/static/jujutsu_kaisen.mp4" type="video/mp4">
    </video>
    <canvas id="digitalRainCanvas"></canvas>

    <!-- SVG Filter cho hiệu ứng Cursed Energy của theme Jujutsu Kaisen -->
    <svg style="display:none">
        <filter id="cursed-energy-wobble">
            <feTurbulence baseFrequency="0.02 0.05" numOctaves="3" seed="2" type="fractalNoise" result="turbulence" />
            <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="5" xChannelSelector="R" yChannelSelector="G" />
            <animate attributeName="baseFrequency" dur="10s" keyTimes="0;0.5;1" values="0.02 0.05;0.03 0.08;0.02 0.05" repeatCount="indefinite" />
        </filter>
    </svg>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="app-title">
                <img src="/static/logo.png" alt="OpenCubee Logo" class="app-logo">
                <span>OpenCubee</span>
            </div>
            <div id="userInfo" style="color: var(--text-secondary);"></div>
        </div>
        <div class="toolbar-right">
            <div id="userInfo" style="color: var(--text-secondary);"></div>
            <!-- START: THEME SWITCHER -->
            <div class="theme-btn-wrapper">
                <button id="themeSwitcherBtn" class="toolbar-btn" title="Change Theme">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-palette"></i> Theme</span>
                </button>
                <div id="themeDropdown" class="theme-dropdown">
                    <!-- Theme options will be added by JS -->
                </div>
            </div>
            <!-- END: THEME SWITCHER -->
            <button class="toolbar-btn" id="dresBtn" title="DRES Submission"><div class="btn-hover-bg"></div><span><i class="fas fa-trophy"></i> DRES</span></button>
            <!-- START: TRAKE BUTTON -->
            <button class="toolbar-btn" id="trakeBtn" title="Toggle Trake Panel"><div class="btn-hover-bg"></div><span><i class="fas fa-stream"></i> Trake</span></button>
            <!-- END: TRAKE BUTTON -->
            <div class="model-btn-wrapper">
                <button id="modelSelectBtn" class="toolbar-btn" title="Toggle Models (Ctrl+M)"><div class="btn-hover-bg"></div><span><i class="fas fa-layer-group"></i> Models</span></button>
                <div id="modelDropdown" class="model-dropdown">
                    <div class="model-dropdown-item"><input type="checkbox" id="model-beit3" value="beit3" checked><label for="model-beit3">BEiT-3</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-bge" value="bge" checked><label for="model-bge">BGE-VL</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-unite" value="unite" checked><label for="model-unite">Unite</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-ops_mm" value="ops_mm" checked><label for="model-ops_mm">Ops-MM</label></div>
                </div>
            </div>
            <button class="toolbar-btn" id="objectFilterBtn" title="Object Filters (Ctrl+F)"><div class="btn-hover-bg"></div><span><i class="fas fa-shapes"></i> Filters</span></button>
            <button class="toolbar-btn" id="clusterBtn" title="Toggle Clustering (Ctrl+G)"><div class="btn-hover-bg"></div><span><i class="fas fa-object-group"></i> Cluster</span></button>
            <button class="toolbar-btn" id="ambiguousBtn" title="Toggle Ambiguous Temporal Search (Ctrl+Shift+G)"><div class="btn-hover-bg"></div><span><i class="fas fa-random"></i> Ambiguous</span></button>
            <button class="toolbar-btn" id="resetBtn" title="Reset Search (Ctrl+Shift+R)"><div class="btn-hover-bg"></div><span><i class="fas fa-redo"></i> Reset Search</span></button>
        </div>
    </div>
    <div class="main-content-wrapper">
        <div id="left-search-panel">
            <div id="google-image-search-container">
                <div class="google-search-header">
                </div>
                <div class="google-search-input-wrapper">
                    <input type="text" id="googleSearchInput" class="stage-input" placeholder="Tìm ảnh trên Google...">
                    <button id="googleSearchBtn" class="control-btn" title="Search"><i class="fas fa-search"></i></button>
                </div>
                <div id="google-image-results-wrapper" style="display: none;">
                    <div id="google-image-results">
                        <!-- Fetched images will appear here -->
                    </div>
                </div>
            </div>
            <div class="stages-container" id="stagesContainer"></div>
            <div class="panel-controls">
                <div class="stage-controls">
                    <button class="control-btn" id="addStageBtn" title="Add Stage to End (Ctrl+])"><i class="fas fa-plus"></i></button>
                    <button class="control-btn" id="removeStageBtn" title="Remove Last Stage (Ctrl+Shift+])"><i class="fas fa-minus"></i></button>
                </div>
                <button class="search-btn" id="searchBtn" title="Search (Enter)"><i class="fas fa-search"></i> Search</button>
            </div>
        </div>
        <div id="right-results-panel">
            <div id="correctSubmissionPanel" style="display: none;">
                <h4><i class="fas fa-check-circle"></i> Correct Submission</h4>
                <div id="correctSubmissionImageContainer">
                </div>
                <p class="reset-note">This will be cleared on 'Reset Search'.</p>
            </div>
            <div id="teamworkPanelContainer" style="display: none;">
                <h3><i class="fas fa-users"></i> Teamwork Submission Panel</h3>
                <div id="teamworkGrid"></div>
            </div>
             <div id="trakePanelContainer" style="display: none;">
                <h3><i class="fas fa-stream"></i> Trake Panel</h3>
                <div id="trakeGrid"></div>
            </div>
            <div id="timingInfoDisplay" class="timing-info-container"></div>
            <div id="loadingIndicator" style="display: none; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Performing Search...</div>
            <div id="resultsContainer">
                <p style="text-align: center; color: var(--text-secondary); padding-top: 100px; font-size: 1.2rem;">Sử dụng bảng điều khiển bên trái để bắt đầu tìm kiếm.</p>
            </div>
        </div>
    </div>

    <div id="usernameModal" class="modal-overlay" style="display: flex; z-index: 3000;">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title" style="width: 100%; text-align: center; color: var(--text-primary); font-weight: 600;">Welcome to OpenCubee!</h2>
            </div>
            <div class="modal-body" style="flex-direction: column; gap: 20px;">
                <p style="color: var(--text-secondary);">Please enter your name to join the session.</p>
                <input type="text" id="usernameInput" class="filter-input" placeholder="Your Name...">
                <button id="usernameSubmitBtn" class="search-btn" style="width: 100%;">Join</button>
            </div>
        </div>
    </div>

    <div id="objectFilterModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 class="modal-title"><i class="fas fa-shapes"></i> Object Filters</h2><span class="modal-close" id="modalCloseBtn">&times;</span></div><div class="modal-body"><div class="filter-section"><div class="filter-section-header"><h3 class="filter-section-title">Object Counting</h3><label class="switch"><input type="checkbox" id="enableCountFilter"><span class="slider"></span></label></div><div id="countFilterControls" class="filter-controls-container"></div><button class="add-custom-btn" id="addCustomCountBtn" style="margin-top: 15px; width: 100%;"><i class="fas fa-plus"></i> Add Custom Object</button></div><div class="filter-section"><div class="filter-section-header"><h3 class="filter-section-title">Object Positioning</h3><label class="switch"><input type="checkbox" id="enablePositionFilter"><span class="slider"></span></label></div><div class="position-controls"><canvas id="positioningCanvas" width="640" height="360"></canvas><div id="drawnBoxesList" class="drawn-boxes-list"></div><p class="shortcuts-info"><b>Shortcuts:</b> Draw box with mouse. <br><b>1-6:</b> person, car, truck, dog, cat, toaster. <b>7:</b> Custom. <br><b>Backspace:</b> Delete last box. <b>C:</b> Clear all.</p></div></div></div></div></div>
    <div id="imageModal" class="image-modal-overlay"><span class="image-modal-close" title="Close (Esc)">&times;</span><img class="image-modal-content" id="zoomedImage"></div>
    <div id="temporalContextModal" class="image-modal-overlay"><div class="temporal-modal-content"><div class="temporal-modal-header"><h2 id="temporalModalTitle"></h2><span class="image-modal-close" id="closeTemporalModalBtn" title="Close (Esc)">&times;</span></div><div class="temporal-modal-body"><div class="temporal-grid" id="temporalGrid"></div></div><div class="temporal-modal-footer">Shortcuts: Click to zoom. Ctrl+Click/Space on button to Push. Ctrl+Shift+Click/Space on button to Submit Direct.</div></div></div>
    
    <!-- ## START: MODIFIED DRES MODAL WITH NEW FLOW ## -->
    <div id="dresModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-trophy"></i> DRES Submission</h2>
                <span class="modal-close" id="dresModalCloseBtn">&times;</span>
            </div>
            <div class="modal-body" style="flex-direction: column; gap: 20px;">
                
                <!-- View 1: Initial Login Button -->
                <div id="dresInitialView">
                    <button id="dresShowLoginBtn" class="search-btn" style="width: 100%;">Login to DRES</button>
                </div>
                
                <!-- View 2: Login Form (hidden by default) -->
                <div id="dresLoginView" style="display: none; flex-direction: column; gap: 20px;">
                    <div>
                        <label for="dresUsername">Username</label>
                        <input type="text" id="dresUsername" class="filter-input" placeholder="Enter your username...">
                    </div>
                    <div>
                        <label for="dresPassword">Password</label>
                        <input type="password" id="dresPassword" class="filter-input" placeholder="Enter your password...">
                    </div>
                    <button id="dresLoginBtn" class="search-btn" style="width: 100%;">Login & Get Evaluations</button>
                </div>
                
                <!-- View 3: Evaluation Selector (hidden by default) -->
                <div id="dresEvaluationView" style="display: none; width: 100%;">
                    <label for="dresEvaluationSelect">Select Evaluation</label>
                    <select id="dresEvaluationSelect" class="filter-input" disabled></select>
                </div>

                <!-- Status message is always visible -->
                <div id="dresStatus" class="dres-status">Status: Not logged in.</div>
            </div>
        </div>
    </div>
    <!-- ## END: MODIFIED DRES MODAL ## -->

    <!-- ## START: MODIFIED VIDEO PREVIEW MODAL ## -->
    <div id="videoPreviewModal" class="image-modal-overlay">
        <span class="image-modal-close" id="closeVideoModalBtn" title="Close (Esc)">&times;</span>
        <div class="video-player-container">
            <video id="videoPlayer" class="image-modal-content" controls autoplay style="background-color: #000;"></video>

            <!-- NEW: Frame and Time Display -->
            <div id="videoFrameInfo" class="video-frame-info-display">
                Frame: <span id="currentFrameDisplay">-</span> | Time: <span id="currentTimeDisplay">-</span>s
            </div>
            
            <!-- Container for the action buttons -->
            <div id="videoActionButtons" style="margin-top: 20px; display: flex; gap: 15px;">
                <button id="pushCurrentFrameBtn" class="toolbar-btn" title="Push to Team (Ctrl+Space in player)">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-users"></i> Team</span>
                </button>
                <button id="pushToTrakeBtn" class="toolbar-btn" title="Push to Trake Panel">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-stream"></i> Trake</span>
                </button>
                <button id="submitCurrentFrameBtn" class="search-btn" title="Submit to DRES (Ctrl+Shift+Space in player)">
                    <i class="fas fa-paper-plane"></i> Submit
                </button>
            </div>
        </div>
    </div>
    <!-- ## END: MODIFIED VIDEO PREVIEW MODAL ## -->
     <div id="nearbyFramesSidebar" class="nearby-frames-sidebar" style="display: none;">
        <div class="sidebar-overlay"></div>
        <div class="sidebar-content">
            <div class="sidebar-header">
                <h3 id="sidebarTitle">Nearby Frames</h3>
                <span id="sidebarCloseBtn" class="modal-close">&times;</span>
            </div>
            <div id="sidebarGrid" class="sidebar-grid">
                <!-- Nearby frames will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ## MERGED & CORRECTED SCRIPT ##
        let ws;
        let username = '';
        let userColor = '';
        let currentlyHoveredItemData = null;
        let currentlyHoveredItemElement = null;
        let lastSuccessfulSubmission = null;
        let pushedFrames = new Set();
        let currentPage = 1;
        let totalResults = 0;
        let isLoadingMore = false;
        let lastSearchPayload = null;
        let currentVideoPreviewData = null; // <<< ADD THIS LINE
        let submittedFrames = new Map(); // Key: filepath, Value: 'CORRECT', 'WRONG', 'DUPLICATE', 'PENDING'
        let isMouseOverTrakePanel = false; // For bulk submission shortcut
        const THEMES = {
            'default': 'Default Dark',
            'theme-cyberpunk-neon': 'Cyberpunk Neon',
            'theme-doraemon-pocket': 'Doraemon',
            'theme-persona-5': 'Persona 5',
            'theme-jojo-menacing': 'JoJo',
            'theme-aot-rumbling': 'AOT',
            'theme-chainsaw-man': 'Chainsaw Man',
            'theme-cyberpunk-glitch': 'CP2077',
            'theme-demon-slayer': 'Demon Slayer',
            'theme-gits-rain': 'GITS',
            'theme-eva-nerv': 'Evangelion',
            'theme-jujutsu-domain': 'JJK',
            'theme-akira-red': 'AKIRA: Neo-Tokyo',
            'theme-naruto-leaf': 'Naruto',
            'theme-bleach-soul': 'Bleach',
            'theme-zero-two-franxx': 'Zero Two'
        };
        let targetFrameTime = 0;
        let isScrubbing = false;
        let scrubbingTimeout = null;
        let scrubAnimationId = null;
        const rainCanvas = document.getElementById('digitalRainCanvas');
        const cursedDomainVideo = document.getElementById('cursedDomainVideo');
        const rainCtx = rainCanvas.getContext('2d');
        let animationFrameId;

        function startDigitalRain() {
            rainCanvas.style.display = 'block';
            
            rainCanvas.width = window.innerWidth;
            rainCanvas.height = window.innerHeight;

            const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
            const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const nums = '0123456789';
            const alphabet = katakana + latin + nums;

            const fontSize = 16;
            const columns = rainCanvas.width / fontSize;
            const rainDrops = [];

            for (let x = 0; x < columns; x++) {
                rainDrops[x] = 1;
            }

            const draw = () => {
                rainCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                rainCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height);

                rainCtx.fillStyle = '#00FF41';
                rainCtx.font = fontSize + 'px Share Tech Mono';

                for (let i = 0; i < rainDrops.length; i++) {
                    const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                    rainCtx.fillText(text, i * fontSize, rainDrops[i] * fontSize);

                    if (rainDrops[i] * fontSize > rainCanvas.height && Math.random() > 0.975) {
                        rainDrops[i] = 0;
                    }
                    rainDrops[i]++;
                }
                animationFrameId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopDigitalRain() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            rainCanvas.style.display = 'none';
        }

        const PAGE_SIZE = 30;

        // ## LAZY LOADING ##
        let imageObserver = null;
        // ##################

        function displayTimingInfo(serverTimings, clientStartTime) { const container = document.getElementById('timingInfoDisplay'); const clientTotalTime = (performance.now() - clientStartTime) / 1000; if ((!serverTimings || Object.keys(serverTimings).length === 0) && !clientTotalTime) { container.style.display = 'none'; return; } container.innerHTML = ''; const createTimingItem = (label, value, icon, extraClass = '') => { if (typeof value !== 'number') return ''; return `<div class="timing-item ${extraClass}"><span class="timing-label"><i class="${icon}"></i> ${label}:</span><span class="timing-value">${value.toFixed(3)} s</span></div>`; }; container.innerHTML += createTimingItem('Total User Time', clientTotalTime, 'fas fa-desktop', 'total-time client-time'); if (serverTimings && serverTimings.total_request_s) { container.innerHTML += createTimingItem('Total Server Time', serverTimings.total_request_s, 'fas fa-server', 'total-time server-time'); } if (serverTimings) { const timingLabels = {'query_processing_s': { label: 'Query Prep', icon: 'fas fa-cogs' }, 'ocr_asr_filtering_s': { label: 'Text Filter', icon: 'fas fa-filter' }, 'embedding_generation_s': { label: 'Embedding', icon: 'fas fa-brain' }, 'vector_search_s': { label: 'Vector Search', icon: 'fas fa-search-plus' }, 'post_processing_s': { label: 'Post-Process', icon: 'fas fa-sitemap' }, 'object_filter_precomputation_s': {label: 'Object Filter', icon: 'fas fa-th-large'}, 'stage_candidate_gathering_s': { label: 'Stage Search', icon: 'fas fa-tasks' }, 'sequence_assembly_s': { label: 'Sequence Assembly', icon: 'fas fa-link' }, 'final_processing_s': { label: 'Final Process', icon: 'fas fa-check-double' }}; const detailedKeys = Object.keys(serverTimings).filter(key => key !== 'total_request_s'); for (const key of detailedKeys) { if (timingLabels[key] && serverTimings[key] > 0) { const info = timingLabels[key]; container.innerHTML += createTimingItem(info.label, serverTimings[key], info.icon); } } } container.style.display = 'flex'; }
        function urlSafeB64Encode(str) { try { const utf8Bytes = new TextEncoder().encode(str); let binaryString = ''; utf8Bytes.forEach(byte => { binaryString += String.fromCharCode(byte); }); return btoa(binaryString).replace(/\+/g, '-').replace(/\//g, '_'); } catch (e) { console.error("Failed to encode string:", str, e); return ""; } }

        document.addEventListener('DOMContentLoaded', () => {
            // --- BƯỚC 3: KHỞI TẠO SPEECH RECOGNITION ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition;
            let activeSpeechInput = null;
            let isRecording = false;
            // ### FIX START: Thêm biến để lưu trữ văn bản đã được xác nhận ###
            let currentTranscriptBase = ''; 
            // ### FIX END ###

            if (!SpeechRecognition) {
                console.warn("Trình duyệt không hỗ trợ nhận dạng giọng nói.");
            } else {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'vi-VN';

                recognition.onstart = () => {
                    isRecording = true;
                    // ### FIX START: Reset transcript base khi bắt đầu ###
                    currentTranscriptBase = ''; 
                    // ### FIX END ###
                    if (activeSpeechInput) {
                        const stageCard = activeSpeechInput.closest('.stage-card');
                        stageCard.querySelector('.mic-btn')?.classList.add('recording');
                    }
                };
                
                recognition.onend = () => {
                    isRecording = false;
                    // ### FIX START: Dọn dẹp state khi kết thúc ###
                    activeSpeechInput = null; 
                    currentTranscriptBase = ''; 
                    // ### FIX END ###
                    document.querySelectorAll('.mic-btn.recording').forEach(btn => btn.classList.remove('recording'));
                };
                
                // ### FIX START: Sửa toàn bộ logic onresult ###
                recognition.onresult = (event) => {
                    if (!activeSpeechInput) return;

                    let interimTranscript = '';
                    // Lặp qua tất cả các kết quả từ lần cuối cùng
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        // Nếu kết quả là final, nối nó vào chuỗi base đã xác nhận
                        if (event.results[i].isFinal) {
                            currentTranscriptBase += event.results[i][0].transcript.trim() + ' ';
                        } else {
                        // Nếu không, nó là kết quả tạm thời
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    // Cập nhật giá trị của input bằng chuỗi base + chuỗi tạm thời
                    activeSpeechInput.value = (currentTranscriptBase + interimTranscript).trim();
                };
                // ### FIX END ###
            }
            // --- KẾT THÚC KHỞI TẠO ---
            
            const stagesContainer = document.getElementById('stagesContainer'); const addStageBtn = document.getElementById('addStageBtn'); const removeStageBtn = document.getElementById('removeStageBtn'); const searchBtn = document.getElementById('searchBtn'); const resultsContainer = document.getElementById('resultsContainer'); const loadingIndicator = document.getElementById('loadingIndicator'); const modelSelectBtn = document.getElementById('modelSelectBtn'); const modelDropdown = document.getElementById('modelDropdown'); const clusterBtn = document.getElementById('clusterBtn'); const ambiguousBtn = document.getElementById('ambiguousBtn'); const objectFilterBtn = document.getElementById('objectFilterBtn'); const objectFilterModal = document.getElementById('objectFilterModal'); const modalCloseBtn = document.getElementById('modalCloseBtn'); const imageModal = document.getElementById('imageModal'); const zoomedImage = document.getElementById('zoomedImage'); const closeImageModalBtn = document.querySelector('#imageModal .image-modal-close'); const temporalContextModal = document.getElementById('temporalContextModal'); const temporalGrid = document.getElementById('temporalGrid'); const temporalModalTitle = document.getElementById('temporalModalTitle'); const closeTemporalModalBtn = document.getElementById('closeTemporalModalBtn'); const enableCountFilter = document.getElementById('enableCountFilter'); const enablePositionFilter = document.getElementById('enablePositionFilter'); const countFilterControls = document.getElementById('countFilterControls'); const addCustomCountBtn = document.getElementById('addCustomCountBtn'); const posCanvas = document.getElementById('positioningCanvas'); const drawnBoxesList = document.getElementById('drawnBoxesList'); const posCtx = posCanvas.getContext('2d');
            
            const dresBtn = document.getElementById('dresBtn'); 
            const dresModal = document.getElementById('dresModal');
            const dresModalCloseBtn = document.getElementById('dresModalCloseBtn');
            const dresInitialView = document.getElementById('dresInitialView');
            const dresShowLoginBtn = document.getElementById('dresShowLoginBtn');
            const dresLoginView = document.getElementById('dresLoginView');
            const dresUsername = document.getElementById('dresUsername');
            const dresPassword = document.getElementById('dresPassword');
            const dresLoginBtn = document.getElementById('dresLoginBtn'); 
            const dresEvaluationView = document.getElementById('dresEvaluationView');
            const dresEvaluationSelect = document.getElementById('dresEvaluationSelect');
            const dresStatus = document.getElementById('dresStatus');

            const googleSearchInput = document.getElementById('googleSearchInput');
            const googleSearchBtn = document.getElementById('googleSearchBtn');
            const googleResultsWrapper = document.getElementById('google-image-results-wrapper');
            const googleResultsContainer = document.getElementById('google-image-results');
            const rightResultsPanel = document.getElementById('right-results-panel');
            const videoPreviewModal = document.getElementById('videoPreviewModal');
            const videoPlayer = document.getElementById('videoPlayer');
            const closeVideoModalBtn = document.getElementById('closeVideoModalBtn');
            const submitCurrentFrameBtn = document.getElementById('submitCurrentFrameBtn');
            const pushCurrentFrameBtn = document.getElementById('pushCurrentFrameBtn');

            const frameInfoDisplay = document.getElementById('videoFrameInfo');
            const currentFrameSpan = document.getElementById('currentFrameDisplay');
            const currentTimeSpan = document.getElementById('currentTimeDisplay');
            const themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
            const themeDropdown = document.getElementById('themeDropdown');
            const trakeBtn = document.getElementById('trakeBtn');
            const trakePanelContainer = document.getElementById('trakePanelContainer');
            const trakeGrid = document.getElementById('trakeGrid');
            const pushToTrakeBtn = document.getElementById('pushToTrakeBtn');
            const nearbyFramesSidebar = document.getElementById('nearbyFramesSidebar');
            const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
            const sidebarGrid = document.getElementById('sidebarGrid');
            const sidebarOverlay = document.querySelector('.sidebar-overlay');
            const sidebarTitle = document.getElementById('sidebarTitle');
            let activeTrakeItemForSidebar = null; // To track which trake item is being edited

            /**
             * Updates the on-screen display with the current frame and time.
             */
            function scrubUpdateLoop() {
                if (!isScrubbing) {
                    cancelAnimationFrame(scrubAnimationId);
                    scrubAnimationId = null;
                    return;
                }
                // Chỉ gửi lệnh seek nếu có sự chênh lệch đáng kể
                if (Math.abs(videoPlayer.currentTime - targetFrameTime) > 0.01) {
                    videoPlayer.currentTime = targetFrameTime;
                }
                scrubAnimationId = requestAnimationFrame(scrubUpdateLoop);
            }

            // Hàm điều khiển việc tua phim
            function handleScrub(direction) {
                if (!currentVideoPreviewData || !currentVideoPreviewData.fps) return;

                videoPlayer.pause();
                const frameTime = 1 / currentVideoPreviewData.fps;
                
                // Cập nhật thời gian mục tiêu
                targetFrameTime += direction * frameTime;
                targetFrameTime = Math.max(0, Math.min(videoPlayer.duration, targetFrameTime));

                // Bắt đầu vòng lặp nếu chưa chạy
                if (!isScrubbing) {
                    isScrubbing = true;
                    if (!scrubAnimationId) {
                        scrubAnimationId = requestAnimationFrame(scrubUpdateLoop);
                    }
                }

                // Dọn dẹp và đặt hẹn giờ để dừng vòng lặp khi người dùng không tua nữa
                clearTimeout(scrubbingTimeout);
                scrubbingTimeout = setTimeout(() => {
                    isScrubbing = false;
                }, 250); // Dừng sau 250ms không hoạt động
            }

            function updateFrameDisplay() {
                if (!videoPlayer.paused && document.activeElement !== videoPlayer) {
                    // Don't update while video is playing normally to save performance,
                    // unless the video element itself is focused.
                }

                if (currentVideoPreviewData && currentVideoPreviewData.fps) {
                    const currentTime = videoPlayer.currentTime;
                    const currentFrame = Math.round(currentTime * currentVideoPreviewData.fps);
                    
                    currentFrameSpan.textContent = currentFrame;
                    currentTimeSpan.textContent = currentTime.toFixed(3);
                } else {
                    currentFrameSpan.textContent = '-';
                    currentTimeSpan.textContent = '-';
                }
            }

            // Listen for the 'wheel' event (mouse scroll) on the video player
            videoPlayer.addEventListener('wheel', (event) => {
                event.preventDefault();
                const direction = event.deltaY < 0 ? 1 : -1;
                handleScrub(direction);
            });

            // Update the display whenever the video time changes
            // This covers playback, seeking, and our custom scrolling
            videoPlayer.addEventListener('timeupdate', updateFrameDisplay);
            videoPlayer.addEventListener('seeked', updateFrameDisplay);

            
            const usernameModal = document.getElementById('usernameModal'); const usernameInput = document.getElementById('usernameInput'); const usernameSubmitBtn = document.getElementById('usernameSubmitBtn'); const userInfoDisplay = document.getElementById('userInfo'); const teamworkPanelContainer = document.getElementById('teamworkPanelContainer'); const teamworkGrid = document.getElementById('teamworkGrid');
            let dresSessionId = sessionStorage.getItem('dresSessionId'); let dresEvaluationId = sessionStorage.getItem('dresEvaluationId'); let currentResponse = {}; let drawnBoxes = []; let isDrawing = false; let startX, startY, currentX, currentY; const PREDEFINED_OBJECTS = ['person', 'car', 'truck', 'dog', 'cat', 'cow', 'toaster']; const LABEL_SHORTCUTS = { '1': 'person', '2': 'car', '3': 'truck', '4': 'dog', '5': 'cat', '6': 'toaster'}; let focusedModelIndex = -1;

            function setupImageObserver() {
                if (imageObserver) {
                    imageObserver.disconnect();
                }
                const options = {
                    root: rightResultsPanel, 
                    rootMargin: '0px 0px 500px 0px', 
                    threshold: 0.01
                };
                imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target.querySelector('img.lazy-load');
                            if (img && img.dataset.src) {
                                img.src = img.dataset.src;
                                img.onload = () => img.classList.add('loaded');
                                observer.unobserve(entry.target);
                            }
                        }
                    });
                }, options);
            }
            
            // --- BƯỚC 4: THÊM EVENT DELEGATION CHO NÚT MICRO ---
            stagesContainer.addEventListener('click', (e) => {
                const micBtn = e.target.closest('.mic-btn');
                if (micBtn && recognition) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const stageCard = micBtn.closest('.stage-card');
                    
                    // ## BẮT ĐẦU SỬA ĐIỀU 2: LOGIC NHẬP LIỆU GIỌNG NÓI ##

                    // 1. Xác định ô input mục tiêu một cách thông minh.
                    // Ưu tiên ô đang được focus trong stage hiện tại.
                    let targetInput = stageCard.querySelector('.main-query-input'); // Mặc định
                    const activeEl = document.activeElement;
                    // Kiểm tra xem có phần tử nào đang được focus không, và nó có nằm trong stage card này không
                    if (activeEl && stageCard.contains(activeEl) && (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT')) {
                        targetInput = activeEl; // Nếu có, đó chính là mục tiêu của chúng ta
                    }

                    // 2. Xóa bỏ logic cũ tự động chuyển sang tab "Text".
                    // Điều này cho phép ghi âm vào các ô filter như OCR, ASR.
                    /* 
                    // ĐOẠN CODE CŨ BỊ XÓA:
                    const textTypeBtn = stageCard.querySelector('.type-btn[data-type="text"]');
                    if (!textTypeBtn.classList.contains('active')) {
                        textTypeBtn.click();
                    }
                    */

                    // 3. Sử dụng `targetInput` đã được xác định chính xác để xử lý ghi âm.
                    if (isRecording) {
                        if (activeSpeechInput === targetInput) {
                            // Nếu đang ghi âm đúng ô này thì dừng lại
                            recognition.stop();
                        } else { 
                            // Nếu đang ghi âm ở ô khác, dừng cái cũ và bắt đầu cái mới
                            recognition.stop();
                            setTimeout(() => {
                                activeSpeechInput = targetInput;
                                targetInput.value = ''; // Xóa sạch ô input khi chuyển đổi
                                recognition.start();
                            }, 250); // Đợi một chút để recognition dừng hẳn
                        }
                    } else {
                        // Nếu chưa ghi âm, bắt đầu ghi âm vào ô mục tiêu
                        activeSpeechInput = targetInput;
                        targetInput.value = ''; 
                        targetInput.focus();
                        recognition.start();
                    }
                    // ## KẾT THÚC SỬA ĐIỀU 2 ##
                }
            });
            // --- KẾT THÚC EVENT DELEGATION ---
            
            submitCurrentFrameBtn.addEventListener('click', () => {
                if (videoPreviewModal.style.display === 'flex' && currentVideoPreviewData) {
                    const currentTime = videoPlayer.currentTime;
                    const frameId = Math.round(currentTime * currentVideoPreviewData.fps);

                    // BƯỚC 1: TẠO THUMBNAIL TỪ FRAME HIỆN TẠI (GIỐNG NÚT PUSH)
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);

                    console.log("--- [Video Player Submission] ---");
                    console.log(`Video ID: ${currentVideoPreviewData.videoId}`);
                    console.log(`Calculated Frame ID: ${frameId}`);
                    console.log("---------------------------------");

                    // BƯỚC 2: TẠO ĐỐI TƯỢNG DỮ LIỆU ĐẦY ĐỦ HƠN
                    const submissionData = {
                        video_id: currentVideoPreviewData.videoId,
                        frame_id: frameId,
                        fps: currentVideoPreviewData.fps,
                        // Sử dụng một filepath nhất quán và có ý nghĩa
                        filepath: `dynamic-frame-${currentVideoPreviewData.videoId}-${frameId}`, 
                        url: thumbnailUrl, // <-- THÔNG TIN QUAN TRỌNG NHẤT ĐƯỢC THÊM VÀO
                        is_dynamic: true // Đánh dấu đây là frame được tạo động
                    };
                    
                    handleSubmitToDRES(submissionData, true);
                } else {
                    alert("No active video context to submit from. Please open a video preview first.");
                    console.error("Submit button clicked, but 'currentVideoPreviewData' is missing.");
                }
            });

            pushCurrentFrameBtn.addEventListener('click', () => {
                if (videoPreviewModal.style.display === 'flex' && currentVideoPreviewData) {
                    const currentTime = videoPlayer.currentTime;
                    const frameId = Math.round(currentTime * currentVideoPreviewData.fps);
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                    const shotData = {
                        video_id: currentVideoPreviewData.videoId,
                        frame_id: frameId,
                        fps: currentVideoPreviewData.fps,
                        filepath: `dynamic-frame-${currentVideoPreviewData.videoId}-${frameId}`,
                        url: thumbnailUrl,
                        is_dynamic: true
                    };
                    console.log("--- [Video Player Push to Teamwork] ---");
                    console.log(`Video ID: ${shotData.video_id}`);
                    console.log(`Current Time: ${currentTime.toFixed(4)}s`);
                    console.log(`Video FPS: ${shotData.fps}`);
                    console.log(`Calculated Frame ID: ${shotData.frame_id}`);
                    console.log("Pushing shotData object:", shotData);
                    console.log("---------------------------------------");
                    pushToTeamworkPanel(shotData);
                } else {
                    alert("No active video context to push from. Please open a video preview first.");
                    console.error("Push button clicked, but 'currentVideoPreviewData' is missing.");
                }
            });

            rightResultsPanel.addEventListener('scroll', () => {
                if (rightResultsPanel.scrollTop + rightResultsPanel.clientHeight >= rightResultsPanel.scrollHeight - 500) {
                    loadMoreResults();
                }
            });

            async function handleGoogleImageAction(url, action, buttonEl) {
                if (!url || !action) return;
                const originalIcon = buttonEl.innerHTML;
                buttonEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                buttonEl.disabled = true;

                try {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to download image');
                    }
                    const imageData = await downloadResponse.json();
                    
                    if (action === 'search') {
                        addStageToStart();
                        const newStage = stagesContainer.querySelector('.stage-card');
                        if (newStage) {
                            newStage.querySelector('.type-btn[data-type="image"]')?.click();
                            const previewImage = newStage.querySelector('.image-preview');
                            const uploadInstructions = newStage.querySelector('.upload-instructions');
                            const removeImageBtn = newStage.querySelector('.remove-image-btn');
                            
                            newStage.tempImageName = imageData.temp_image_name;
                            previewImage.src = imageData.url;
                            previewImage.style.display = 'block';
                            uploadInstructions.style.display = 'none';
                            removeImageBtn.style.display = 'flex';
                            handleSearch();
                        }
                    } else if (action === 'push') {
                        const shotData = {
                            filepath: imageData.filepath,
                            url: imageData.url,
                            video_id: 'N/A',
                            shot_id: 'N/A',
                            frame_id: 'N/A'
                        };
                        pushToTeamworkPanel(shotData);
                    }

                } catch (error) {
                    console.error(`Google Image Action [${action}] failed:`, error);
                    alert(`Error: ${error.message}`);
                } finally {
                    buttonEl.innerHTML = originalIcon;
                    buttonEl.disabled = false;
                }
            }

            function displayGoogleImages(urls) {
                googleResultsContainer.innerHTML = '';
                if (urls.length === 0) {
                    googleResultsContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9rem;">No images found.</p>';
                    return;
                }
                urls.forEach(url => {
                    const item = document.createElement('div');
                    item.className = 'google-image-item';
                    item.innerHTML = `<img src="${url}" loading="lazy" onerror="this.parentElement.style.display='none'">`;
                    item.title = "Click: Zoom\nCtrl+Shift+Click: Similarity Search";

                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (e.ctrlKey && e.shiftKey) {
                            const fakeShotData = {
                                url: url,
                                filepath: `google-image-${Date.now()}.jpg`,
                                is_external: true
                            };
                            performImageSearchFromClick(fakeShotData);
                        } else {
                            handleGoogleImageAction(url, 'zoom', item);
                        }
                    });

                    item.addEventListener("mouseenter", () => {
                        currentlyHoveredItemData = { external_url: url };
                        currentlyHoveredItemElement = item;
                    });
                    item.addEventListener("mouseleave", () => {
                        currentlyHoveredItemData = null;
                        currentlyHoveredItemElement = null;
                    });

                    googleResultsContainer.appendChild(item);
                });
            }

            async function fetchGoogleImages() {
                const query = googleSearchInput.value.trim();
                if (!query) return;

                googleResultsWrapper.style.display = 'block';
                googleResultsContainer.innerHTML = '<i class="fas fa-spinner fa-spin" style="font-size: 1.5rem; margin: auto;"></i>';
                
                try {
                    const response = await fetch('/google_image_search', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ query })
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Search failed');
                    }
                    const data = await response.json();
                    displayGoogleImages(data.image_urls || []);
                } catch (error) {
                    googleResultsContainer.innerHTML = `<p style="color: #ef4444;">Error: ${error.message}</p>`;
                }
            }

            googleSearchBtn.addEventListener('click', fetchGoogleImages);
            googleSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation(); 
                    fetchGoogleImages();
                }
            });
            
            function djb2(str) { let hash = 5381; for (let i = 0; i < str.length; i++) { hash = ((hash << 5) + hash) + str.charCodeAt(i); } return hash; }
            function generateColor(str) { const hash = djb2(str); const h = hash % 360; const s = ((hash >> 8) % 31) + 70; const l = ((hash >> 16) % 21) + 50; return `hsl(${h}, ${s}%, ${l}%)`; }
            function createResultItem(data, source = 'main') {
                const isTeamworkItem = source === 'teamwork';
                const isTrakeItem = source === 'trake';
                
                const shot = data.shot ? data.shot : data;
                const user = data.user ? data.user : null;
                if (!shot || !shot.url) return null;

                const item = document.createElement('div');
                item.className = 'result-item';
                item.dataset.source = source;
                item.dataset.filepath = shot.filepath;
                item.dataset.videoId = shot.video_id;
                item.dataset.shotId = shot.shot_id;
                item.dataset.frameId = shot.frame_id;

                const isLazy = source === 'main';
                const srcAttribute = isLazy ? `data-src="${shot.url}"` : `src="${shot.url}"`;
                const imgClass = isLazy ? 'lazy-load' : 'loaded';

                let title = '';
                let itemHTML = `<img class="${imgClass}" ${srcAttribute} alt="Frame" loading="lazy" decoding="async" />`;
                let actionsHTML = '';

                if (isTeamworkItem) {
                    item.classList.add('teamwork-item');
                    item.style.setProperty('--user-color', user.color);
                    title = `Pushed by: ${user.name}\nClick: Submit | Ctrl+Click: Submit Direct`;
                    actionsHTML = `
                        <button class="submit-btn" title="Click: Submit | Ctrl+Click: Submit Direct"><i class="fas fa-paper-plane"></i></button>
                        <div class="teamwork-item-user-label">${user.name}</div>
                    `;
                } else if (isTrakeItem) {
                    item.draggable = true;
                    item.shotData = shot; 
                    title = `Video: ${shot.video_id}\nFrame: ${shot.frame_id}\nDrag to reorder.`;
                    actionsHTML = `
                        <div class="trake-item-actions">
                            <button class="trake-action-btn nearby-frames-btn" title="Show Nearby Frames"><i class="fas fa-layer-group"></i></button>
                            <button class="trake-action-btn remove-trake-btn" title="Remove from Trake"><i class="fas fa-times"></i></button>
                        </div>`;
                } else { // This 'else' now ONLY applies to 'main' results
                    title = `Click: Zoom\nRight-Click: Video Preview\nCtrl+Click: View Context`;
                    const score = shot.rrf_score || shot.cluster_score || shot.score || shot.average_rff_score || shot.combined_score;
                    if (score) title += `\nScore: ${score.toFixed(4)}`;
                    
                    if (source === 'main') {
                         actionsHTML = `
                         <div class="trake-item-actions">
                            <button class="trake-action-btn trake-push-btn" title="Push to Trake Panel"><i class="fas fa-thumbtack"></i></button>
                         </div>`;
                    }
                }

                item.innerHTML = itemHTML + actionsHTML;
                item.querySelector('img').title = title;

                item.addEventListener("click", e => handleBaseItemClick(e, shot, source));
                item.addEventListener("contextmenu", e => handleBaseItemClick(e, shot, source));

                const submitBtn = item.querySelector(".submit-btn");
                if (submitBtn) submitBtn.addEventListener("click", e => handleFrameInteraction(e, shot, source));
                
                const pushToTrakeBtn = item.querySelector(".trake-push-btn");
                if(pushToTrakeBtn) pushToTrakeBtn.addEventListener("click", e => { e.stopPropagation(); pushToTrakePanel(shot); });

                const removeTrakeBtn = item.querySelector(".remove-trake-btn");
                if(removeTrakeBtn) removeTrakeBtn.addEventListener("click", e => {
                    e.stopPropagation();
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'trake_remove',
                            data: { filepath: item.dataset.filepath }
                        }));
                    }
                });
                
                const nearbyFramesBtn = item.querySelector(".nearby-frames-btn");
                if(nearbyFramesBtn) nearbyFramesBtn.addEventListener("click", handleNearbyFramesClick);

                item.addEventListener("mouseenter", () => { currentlyHoveredItemData = shot; currentlyHoveredItemElement = item; });
                item.addEventListener("mouseleave", () => { currentlyHoveredItemData = null; currentlyHoveredItemElement = null; });

                return item;
            }
            function createContextItem(shotData) {
                // This function is ONLY for the context view.
                // It creates the simple, original HTML structure with NO buttons.
                const item = document.createElement('div');
                item.className = 'result-item temporal-grid-item'; // Add both classes for correct styling
                
                item.dataset.filepath = shotData.filepath;
                item.dataset.videoId = shotData.video_id;
                item.dataset.shotId = shotData.shot_id; // Added for consistency
                item.dataset.frameId = shotData.frame_id;

                // The original simple HTML structure.
                item.innerHTML = `<img class="loaded" src="${shotData.url}" alt="Context Frame" loading="lazy" decoding="async" />`;
                
                // --- THIS IS THE KEY ---
                // We re-add the standard event listeners that make the shortcuts work.
                // These were missing or incorrectly implemented in my previous attempts.
                item.addEventListener("mouseenter", () => {
                    currentlyHoveredItemData = shotData;
                    currentlyHoveredItemElement = item;
                });
                item.addEventListener("mouseleave", () => {
                    currentlyHoveredItemData = null;
                    currentlyHoveredItemElement = null;
                });

                // Attach the original event handlers for zoom and video preview
                item.addEventListener("click", e => handleBaseItemClick(e, shotData, 'context'));
                item.addEventListener("contextmenu", e => handleBaseItemClick(e, shotData, 'context'));

                return item;
            }

            function initWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

                let reconnectDelay = 1000;

                ws.onopen = () => {
                    console.log('WebSocket connection established.');
                    teamworkPanelContainer.style.display = 'block';
                    reconnectDelay = 1000; // Reset delay on success
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    const type = message.type;
                    const data = message.data;

                    // --- Teamwork Panel ---
                    if (type === 'new_frame') {
                        const newItem = createResultItem(data, 'teamwork');
                        if (newItem) teamworkGrid.prepend(newItem);
                    } else if (type === 'remove_frame') {
                        const itemToRemove = teamworkGrid.querySelector(`.result-item[data-filepath="${data.filepath}"]`);
                        if (itemToRemove) itemToRemove.remove();
                    } else if (type === 'clear_panel') {
                        teamworkGrid.innerHTML = '';
                        pushedFrames.clear();
                        if (message.status === 'success' && lastSuccessfulSubmission) {
                            pushToTeamworkPanel(lastSuccessfulSubmission);
                            lastSuccessfulSubmission = null;
                        }
                    }
                    // --- Trake Panel ---
                    else if (type === 'trake_sync') {
                        trakeGrid.innerHTML = '';
                        data.forEach(shot => {
                            const trakeItem = createResultItem(shot, 'trake');
                            if (trakeItem) trakeGrid.appendChild(trakeItem);
                        });
                    } else if (type === 'trake_add') {
                        // Avoid adding duplicates if message arrives
                        if (!trakeGrid.querySelector(`.result-item[data-filepath="${data.shot.filepath}"]`)) {
                            const trakeItem = createResultItem(data.shot, 'trake');
                            if (trakeItem) trakeGrid.appendChild(trakeItem);
                        }
                    } else if (type === 'trake_remove') {
                        const itemToRemove = trakeGrid.querySelector(`.result-item[data-filepath="${data.filepath}"]`);
                        if (itemToRemove) itemToRemove.remove();
                    } else if (type === 'trake_reorder') {
                        const orderedElements = data.order.map(filepath => trakeGrid.querySelector(`.result-item[data-filepath="${filepath}"]`)).filter(Boolean);
                        trakeGrid.innerHTML = ''; // Clear and re-append in the new order
                        orderedElements.forEach(el => trakeGrid.appendChild(el));
                    } else if (type === 'trake_replace') {
                        const itemToReplace = trakeGrid.querySelector(`.result-item[data-filepath="${data.filepath}"]`);
                        if (itemToReplace) {
                           // Update the DOM element directly
                           itemToReplace.shotData = data.newShot;
                           itemToReplace.dataset.frameId = data.newShot.frame_id;
                           itemToReplace.querySelector('img').src = data.newShot.url;
                        }
                    }
                };

                ws.onclose = () => {
                    console.log('WebSocket connection closed. Retrying in', reconnectDelay, 'ms');
                    setTimeout(() => {
                        reconnectDelay = Math.min(reconnectDelay * 2, 30000); // Exponential backoff
                        initWebSocket();
                    }, reconnectDelay);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            
            function setupUser() {
                username = sessionStorage.getItem('username');
                userColor = sessionStorage.getItem('userColor');
                if (!username) {
                    usernameModal.style.display = 'flex';
                    usernameInput.focus();
                } else {
                    usernameModal.style.display = 'none';
                    userInfoDisplay.textContent = `User: ${username}`;
                    userInfoDisplay.style.color = userColor;
                    initWebSocket();
                }
            }
            usernameSubmitBtn.addEventListener('click', () => { const name = usernameInput.value.trim(); if (name) { sessionStorage.setItem('username', name); sessionStorage.setItem('userColor', generateColor(name)); setupUser(); } });
            usernameInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') usernameSubmitBtn.click(); });
            function pushToTeamworkPanel(shotData) {
                if (!shotData || !shotData.filepath) { console.error("Attempted to push invalid shot data:", shotData); return; }
                if (pushedFrames.has(shotData.filepath)) { console.log("This frame has already been pushed."); return; }
                if (!ws || ws.readyState !== WebSocket.OPEN) { alert("Teamwork connection is not available."); return; }
                pushedFrames.add(shotData.filepath);
                const payload = { type: 'new_frame', data: { shot: shotData, user: { name: username, color: userColor } } };
                ws.send(JSON.stringify(payload));
                console.log("Pushed to teamwork panel:", shotData.filepath);
            }

        async function handleSubmitToDRES(shot, bypassConfirmation = false) {
            // === PHASE 1: PRE-SUBMISSION VALIDATION ===

            // 1. Check DRES login status.
            if (!dresSessionId || !dresEvaluationId) {
                showToast("Please log in to DRES first!", 3000, 'error');
                dresModal.style.display = 'flex';
                return;
            }

            // 2. Validate the incoming shot data.
            if (!shot || shot.frame_id === undefined || !shot.video_id || !shot.url) {
                console.error("Invalid or incomplete shot data for submission.", shot);
                showToast("Error: Invalid data for submission.", 4000, 'error');
                return;
            }

            // 3. Create a reliable, unique key for the frame to track its submission status.
            const submissionKey = `${shot.video_id}-${shot.frame_id}`;

            // 4. Prevent re-submission if the frame has already been processed.
            const submissionStatus = submittedFrames.get(submissionKey);
            if (submissionStatus && submissionStatus !== 'PENDING') {
                showToast(`Already submitted! Status: ${submissionStatus}`, 3000, 'warning');
                return;
            }
            if (submissionStatus === 'PENDING') {
                showToast("Submission for this frame is already in progress...", 2000, 'info');
                return;
            }

            // === PHASE 2: SUBMISSION EXECUTION & UI FEEDBACK ===

            // Find the corresponding UI element (this will be null for video player submissions, which is expected).
            const itemElement = document.querySelector(`.result-item[data-filepath="${shot.filepath}"]`);

            try {
                // Set state to 'PENDING' to prevent race conditions and provide immediate feedback.
                submittedFrames.set(submissionKey, 'PENDING');
                showSubmissionStatusOnItem(itemElement, 'pending', 'Submitting...');

                // Perform the API call to the DRES server.
                const response = await fetch('/dres/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: dresSessionId,
                        evaluationId: dresEvaluationId,
                        video_id: shot.video_id,
                        filepath: shot.filepath,
                        frame_id: shot.frame_id
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.detail || 'Submission request failed');
                }

                // === PHASE 3: PROCESS RESULT & FINALIZE UI ===
                
                const resultText = result.description.toUpperCase();
                let finalStatus = 'UNKNOWN';

                if (resultText.includes('CORRECT')) {
                    finalStatus = 'CORRECT';
                    submittedFrames.set(submissionKey, finalStatus);
                    
                    showSubmissionStatusOnItem(itemElement, 'correct', 'CORRECT');
                    showToast('CORRECT! Great find!', 3000, 'success');

                    // === PHẦN SỬA LỖI LOGIC HIỂN THỊ ===
                    // 1. Lấy tham chiếu đến cả panel LỚN và container BÊN TRONG
                    const correctSubmissionPanel = document.getElementById('correctSubmissionPanel');
                    const correctSubmissionContainer = document.getElementById('correctSubmissionImageContainer');
                    
                    // 2. Dọn dẹp container và tạo item ảnh mới
                    correctSubmissionContainer.innerHTML = '';
                    const correctItem = createResultItem(shot, 'correct-submission');

                    // 3. Kiểm tra mọi thứ tồn tại trước khi hành động
                    if (correctItem && correctSubmissionContainer && correctSubmissionPanel) {
                        // Đặt ảnh vào container
                        correctSubmissionContainer.appendChild(correctItem);
                        
                        // **DÒNG QUAN TRỌNG NHẤT:** Bật hiển thị cho cả panel lớn
                        correctSubmissionPanel.style.display = 'flex'; 
                    }
                    // === KẾT THÚC PHẦN SỬA LỖI ===

                    // Lưu lại lượt nộp thành công để có thể push lại sau khi reset
                    lastSuccessfulSubmission = shot;

                    // Xóa panel teamwork cho tất cả user
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Gửi thông điệp kèm theo trạng thái thành công để server có thể xử lý logic push lại
                        ws.send(JSON.stringify({"type": "clear_panel", "status": "success"}));
                    }

                } else if (resultText.includes('WRONG')) {
                    finalStatus = 'WRONG';
                    submittedFrames.set(submissionKey, finalStatus);
                    
                    showSubmissionStatusOnItem(itemElement, 'wrong', 'WRONG');
                    showToast('Wrong submission. Keep trying!', 3000, 'error');
                    if (itemElement) itemElement.classList.add('submitted-wrong');

                } else if (resultText.includes('DUPLICATE')) {
                    finalStatus = 'DUPLICATE';
                    submittedFrames.set(submissionKey, finalStatus);

                    showSubmissionStatusOnItem(itemElement, 'duplicate', 'DUPLICATE');
                    showToast('Duplicate submission. Already noted.', 3000, 'warning');
                    if (itemElement) itemElement.classList.add('submitted-duplicate');
                
                } else {
                    // Handle any other response from DRES.
                    finalStatus = result.description;
                    showToast(`Status: ${result.description}`, 3000, 'info');
                }

            } catch (error) {
                // === PHASE 4: ERROR HANDLING ===
                
                // Provide clear feedback to the user about the failure.
                showSubmissionStatusOnItem(itemElement, 'wrong', 'Error');
                showToast(error.message, 4000, 'error');
                
                // CRITICAL: Reset the submission state on failure to allow the user to retry.
                submittedFrames.delete(submissionKey);
                
                console.error("DRES Submission failed:", error);

            } finally {
                // === PHASE 5: CLEANUP ===
                
                // The overlay logic now handles hiding itself, but this class could be used for other effects.
                if (itemElement) {
                    itemElement.classList.remove('submitting');
                }
            }
        }

            function showToast(message, duration = 3000, type = 'info') {
                const toast = document.createElement('div');
                
                let backgroundStyle = '';
                let iconHTML = '';

                switch (type) {
                    case 'success':
                        backgroundStyle = 'linear-gradient(135deg, #28a745 0%, #218838 100%)';
                        iconHTML = '<i class="fas fa-check-circle" style="margin-right: 10px;"></i>';
                        break;
                    case 'error':
                        backgroundStyle = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                        iconHTML = '<i class="fas fa-times-circle" style="margin-right: 10px;"></i>';
                        break;
                    case 'warning':
                        backgroundStyle = 'linear-gradient(135deg, #ffc107 0%, #e0a800 100%)';
                        iconHTML = '<i class="fas fa-exclamation-triangle" style="margin-right: 10px;"></i>';
                        break;
                    default: // 'info'
                        backgroundStyle = 'var(--primary-gradient)';
                        iconHTML = '<i class="fas fa-info-circle" style="margin-right: 10px;"></i>';
                        break;
                }

                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${backgroundStyle};
                    color: white;
                    padding: 14px 22px;
                    border-radius: 8px;
                    box-shadow: var(--shadow-heavy);
                    z-index: 10000;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                `;
                
                toast.innerHTML = `${iconHTML}<span>${message}</span>`;
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards';
                    toast.addEventListener('animationend', () => toast.remove());
                }, duration);
            }

            function showSubmissionStatusOnItem(itemElement, status, message) {
                if (!itemElement) return;

                // Tìm hoặc tạo overlay
                let overlay = itemElement.querySelector('.submission-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'submission-overlay';
                    itemElement.appendChild(overlay);
                }

                // Thiết lập icon và nội dung dựa trên trạng thái
                let iconClass = '';
                switch (status) {
                    case 'pending':   iconClass = 'fas fa-spinner fa-spin'; break;
                    case 'correct':   iconClass = 'fas fa-check-circle'; break;
                    case 'wrong':     iconClass = 'fas fa-times-circle'; break;
                    case 'duplicate': iconClass = 'fas fa-exclamation-triangle'; break;
                }
                
                overlay.innerHTML = `<i class="${iconClass}"></i><span>${message}</span>`;

                // Cập nhật class để thay đổi màu sắc và hiển thị
                overlay.className = 'submission-overlay'; // Reset class
                overlay.classList.add(`status-${status}`);
                overlay.classList.add('visible');

                // Tự động ẩn đi sau một khoảng thời gian (trừ trạng thái pending)
                if (status !== 'pending') {
                    setTimeout(() => {
                        overlay.classList.remove('visible');
                    }, 2500); // Overlay sẽ hiển thị trong 2.5 giây
                }
            }

            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);

            async function handleGoogleImageAction(url, action, element) {
                if (!url || !action) return;

                if (action === 'zoom') {
                    imageModal.style.display = "flex";
                    zoomedImage.src = url;
                    return;
                }
                
                element.style.cursor = 'wait';
                try {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to prepare image');
                    }
                    const imageData = await downloadResponse.json();
                    
                    const shotData = {
                        filepath: imageData.filepath,
                        url: imageData.url,
                        video_id: 'N/A',
                        shot_id: 'N/A',
                        frame_id: 'N/A',
                        external_url: url
                    };

                    if (action === 'search') {
                        addStageToStart();
                        const newStage = stagesContainer.querySelector('.stage-card');
                        if (newStage) {
                            newStage.querySelector('.type-btn[data-type="image"]')?.click();
                            const previewImage = newStage.querySelector('.image-preview');
                            const uploadInstructions = newStage.querySelector('.upload-instructions');
                            const removeImageBtn = newStage.querySelector('.remove-image-btn');
                            newStage.tempImageName = imageData.temp_image_name;
                            previewImage.src = imageData.url;
                            previewImage.style.display = 'block';
                            uploadInstructions.style.display = 'none';
                            removeImageBtn.style.display = 'flex';
                            handleSearch();
                        }
                    } else if (action === 'push') {
                        pushToTeamworkPanel(shotData);
                    } else if (action === 'submit') {
                        handleSubmitToDRES(shotData, true);
                    }

                } catch (error) {
                    console.error(`Google Image Action [${action}] failed:`, error);
                    alert(`Error: ${error.message}`);
                } finally {
                    element.style.cursor = 'pointer';
                }
            }
            function handleFrameInteraction(event, shotData, source) {
                event.preventDefault();
                event.stopPropagation();
                if (source === 'teamwork') {
                    const isCtrl = event.ctrlKey || event.metaKey;
                    handleSubmitToDRES(shotData, isCtrl);
                }
            }
            function handleBaseItemClick(event, shotData, source) {
                event.preventDefault();
                event.stopPropagation();
                
                if (event.ctrlKey && event.shiftKey) {
                    performImageSearchFromClick(shotData);
                } 
                else if (event.type === 'contextmenu') {
                    openVideoPreview(shotData); 
                } 
                else if (event.ctrlKey || event.metaKey) {
                    openTemporalContextView(shotData);
                }
                else {
                    imageModal.style.display = "flex";
                    zoomedImage.src = shotData.url;
                }
            }
            let fpsCache = new Map(); 

            async function openVideoPreview(shotData) {
                if (!shotData || !shotData.video_id || !shotData.filepath) {
                    alert("Error: Invalid data for video preview (missing video_id or filepath).");
                    return;
                }
                const frameId = shotData.frame_id;
                if (frameId === null || frameId === undefined) {
                    alert(`Error: Frame ID is missing for this result.`);
                    return;
                }
                
                document.body.classList.add('video-modal-active'); // THÊM DÒNG NÀY

                videoPreviewModal.style.display = "flex";
                videoPlayer.pause();
                videoPlayer.src = "";
                currentVideoPreviewData = null;
                //... (phần còn lại của hàm giữ nguyên)
                try {
                    let fps = fpsCache.get(shotData.video_id);
                    if (!fps) {
                        const infoResponse = await fetch(`/video_info/${shotData.video_id}`);
                        if (!infoResponse.ok) throw new Error(`Could not fetch video info (status: ${infoResponse.status})`);
                        const videoInfo = await infoResponse.json();
                        fps = videoInfo.fps;
                        fpsCache.set(shotData.video_id, fps);
                    }
                    currentVideoPreviewData = { videoId: shotData.video_id, fps };
                    const startTime = frameId / fps;
                    targetFrameTime = startTime;
                    const videoUrl = `/videos/${shotData.video_id}`;
                    videoPlayer.src = videoUrl;
                    videoPlayer.addEventListener('loadedmetadata', () => {
                        if (isFinite(startTime) && startTime < videoPlayer.duration) {
                            videoPlayer.currentTime = startTime;
                        }
                        updateFrameDisplay(); 
                    }, { once: true });
                    videoPlayer.load();
                } catch (error) {
                    console.error("Error setting up video preview:", error);
                    alert("Error loading video preview: " + error.message);
                    currentVideoPreviewData = null;
                }
            }

            async function openTemporalContextView(e){
                if(!e||!e.filepath)return void alert("Error: Invalid data for context view.");
                if (e.is_dynamic) { alert("Temporal context view is not available for frames pushed directly from the video player."); return; }
                temporalModalTitle.textContent=`Loading context for Video: ${e.video_id}, Frame: ${e.frame_id}...`;
                temporalGrid.innerHTML='<p style="color: white; text-align: center; padding: 20px;">Checking available frames...</p>';
                temporalContextModal.style.display="flex";
                try{
                    const t=await fetch("/check_temporal_frames",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({base_filepath:e.filepath})});
                    if(!t.ok){const o=await t.json();throw new Error(o.detail||"Failed to check frames.")}
                    const o=await t.json();
                    if(0===o.length)return void(temporalGrid.innerHTML='<p style="color: #ffcccc; text-align: center;">No context frames found.</p>');
                    temporalModalTitle.textContent=`Frame Context – Video: ${e.video_id||"N/A"}, Frame: ${e.frame_id||"N/A"}`;
                    temporalGrid.innerHTML="";
                    const r=e.filepath.match(/_(\d+)\./),s=r?parseInt(r[1],10):null;
                    o.forEach(t=>{
                        const frame_id_match = t.match(/_(\d+)\.[^.]+$/);
                        const temporalShotItem = createContextItem({
                            url: `/images/${urlSafeB64Encode(t)}`,
                            filepath: t,
                            video_id: e.video_id,
                            shot_id: e.shot_id,
                            frame_id: frame_id_match ? parseInt(frame_id_match[1], 10) : null
                        }, 'context');
                        if(temporalShotItem) {
                            temporalShotItem.classList.add('temporal-grid-item');
                            const label = document.createElement('div');
                            label.className = 'temporal-item-label';
                            const a = t.match(/_(\d+)\./);
                            if (a && s !== null) {
                                const l = parseInt(a[1], 10) - s;
                                label.textContent = l > 0 ? `+${l}` : `${l}`;
                                if (l === 0) temporalShotItem.classList.add("center-frame");
                            }
                            temporalShotItem.prepend(label);
                            temporalGrid.appendChild(temporalShotItem);
                        }
                    })
                } catch(t) { console.error("Error loading context view:",t),temporalGrid.innerHTML=`<p style="color: #ffcccc; text-align: center;">Error: ${t.message}</p>` }
            }
            
            function displayResults(data, append = false) {
                const fragment = document.createDocumentFragment();

                if (!append) {
                    resultsContainer.innerHTML = "";
                    if (imageObserver) imageObserver.disconnect();
                    setupImageObserver();
                }

                const moreLoader = document.getElementById('moreLoader');
                if (moreLoader) moreLoader.remove();

                if (!Array.isArray(data) || data.length === 0) {
                    if (!append) resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Không tìm thấy kết quả.</p>';
                    return;
                }

                const isClusteredMode = clusterBtn.classList.contains("active");
                const createGridWithItems = (items) => {
                    const gridFragment = document.createDocumentFragment();
                    const grid = document.createElement('div');
                    grid.className = 'results-grid';
                    items.forEach(shot => {
                        const itemElement = createResultItem(shot, 'main');
                        if (itemElement) {
                            grid.appendChild(itemElement);
                            if (imageObserver) imageObserver.observe(itemElement);
                        }
                    });
                    gridFragment.appendChild(grid);
                    return gridFragment;
                };

                const isTemporalSearch = currentResponse.is_temporal_search;
                const isAmbiguousSearch = currentResponse.is_ambiguous_search;

                if (isTemporalSearch || isAmbiguousSearch) {
                    data.forEach((sequence, seqIndex) => {
                        const sequenceContainer = document.createElement('div');
                        const sequenceHeader = document.createElement("div");
                        sequenceHeader.className = "sequence-header";
                        const headerText = isAmbiguousSearch ? `Ambiguous Match in Video: ${sequence.video_id || "N/A"}` : `Sequence ${seqIndex + 1 + ((currentPage - 1) * PAGE_SIZE)} (Video: ${sequence.video_id || "N/A"})`;
                        sequenceHeader.innerHTML = `<i class="fas fa-stream"></i> ${headerText}`;
                        sequenceContainer.appendChild(sequenceHeader);

                        if (isClusteredMode) {
                            (sequence.clusters || []).forEach((cluster) => {
                                const stageContainer = document.createElement('div');
                                const sortedShots = [...(cluster.shots || [])].sort((a, b) => (a.shot_id_int || 0) - (b.shot_id_int || 0) || (a.frame_id || 0) - (b.frame_id || 0));
                                stageContainer.appendChild(createGridWithItems(sortedShots));
                                sequenceContainer.appendChild(stageContainer);
                            });
                        } else {
                            sequenceContainer.appendChild(createGridWithItems(sequence.shots || []));
                        }
                        fragment.appendChild(sequenceContainer);
                        if (seqIndex < data.length - 1) {
                            const separator = document.createElement('hr');
                            separator.className = 'cluster-separator';
                            fragment.appendChild(separator);
                        }
                    });
                } else { 
                    if (isClusteredMode) {
                        data.forEach((cluster, index) => {
                            const newClusterContainer = document.createElement('div');
                            if (cluster.shots && cluster.shots.length > 0) {
                                const clusterHeader = document.createElement('h3');
                                clusterHeader.className = 'cluster-header';
                                clusterHeader.textContent = `Cluster from Video: ${cluster.shots[0].video_id}`;
                                newClusterContainer.appendChild(clusterHeader);
                            }
                            const sortedShots = [...(cluster.shots || [])].sort((a, b) => (a.shot_id_int || 0) - (b.shot_id_int || 0) || (a.frame_id || 0) - (b.frame_id || 0));
                            newClusterContainer.appendChild(createGridWithItems(sortedShots));
                            fragment.appendChild(newClusterContainer);
                            if (index < data.length - 1) {
                                const separator = document.createElement('hr');
                                separator.className = 'cluster-separator';
                                fragment.appendChild(separator);
                            }
                        });
                    } else {
                        const allShots = data.flatMap(item => item.shots ? item.shots : (item.best_shot ? [item.best_shot] : (item.filepath ? [item] : [])));
                        allShots.sort((a, b) => (b.rrf_score || 0) - (a.rrf_score || 0));
                        const uniqueShots = Array.from(new Map(allShots.filter(Boolean).map(shot => [shot.filepath, shot])).values());
                        
                        if (append) {
                            const grid = resultsContainer.querySelector('.results-grid');
                            if(grid) {
                                uniqueShots.forEach(shot => {
                                    const itemElement = createResultItem(shot, 'main');
                                    if (itemElement) {
                                        grid.appendChild(itemElement);
                                        if (imageObserver) imageObserver.observe(itemElement);
                                    }
                                });
                            }
                        } else {
                            fragment.appendChild(createGridWithItems(uniqueShots));
                        }
                    }
                }
                resultsContainer.appendChild(fragment);
            }

        async function performImageSearchFromClick(shot) {
            if (!shot || !shot.url || !shot.filepath) {
                alert("Dữ liệu không hợp lệ để tìm kiếm bằng hình ảnh.");
                return;
            }
            if (temporalContextModal.style.display === "flex") { temporalContextModal.style.display = "none"; }
            if (imageModal.style.display === "flex") { imageModal.style.display = "none"; }

            loadingIndicator.style.display = 'block';
            resultsContainer.innerHTML = '';
            
            try {
                let imageBlob;
                
                if (shot.is_external) {
                    const downloadResponse = await fetch('/download_external_image', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ url: shot.url })
                    });
                    if (!downloadResponse.ok) {
                        const err = await downloadResponse.json();
                        throw new Error(err.detail || 'Failed to prepare external image');
                    }
                    const imageData = await downloadResponse.json();
                    const localImageResponse = await fetch(imageData.url);
                    if (!localImageResponse.ok) {
                        throw new Error(`Không thể tải ảnh đã xử lý: ${localImageResponse.statusText}`);
                    }
                    imageBlob = await localImageResponse.blob();
                } else {
                    const response = await fetch(shot.url);
                    if (!response.ok) {
                        throw new Error(`Không thể tải ảnh: ${response.statusText}`);
                    }
                    imageBlob = await response.blob();
                }

                const filename = shot.filepath.split("/").pop() || "clicked-image.jpg";
                const imageFile = new File([imageBlob], filename, { type: imageBlob.type });
                await handleSearch(imageFile);

            } catch (error) {
                console.error("Lỗi khi tìm kiếm bằng ảnh từ click:", error);
                alert(`Đã xảy ra lỗi: ${error.message}`);
                loadingIndicator.style.display = 'none';
            }
        }
            function clearModelFocus() { modelDropdown.querySelectorAll('.model-dropdown-item').forEach(item => item.classList.remove('focused')); focusedModelIndex = -1; }
            function updateModelFocus() { const items = modelDropdown.querySelectorAll('.model-dropdown-item'); items.forEach((item, index) => { item.classList.toggle('focused', index === focusedModelIndex); }); }
            function focusOnStageInput(stageElement) { if (!stageElement) return; const input = stageElement.querySelector('.main-query-input'); if (input) { input.focus(); input.setSelectionRange(input.value.length, input.value.length); } }
            
            function createStageCard(number) {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                stageCard.dataset.stageNumber = number;
                const queryTypes = [{ id: 'text', icon: 'fas fa-font', label: 'Text (Ctrl+Alt+U)', type: 'primary' }, { id: 'image', icon: 'fas fa-image', label: 'Image (Ctrl+Alt+I)', type: 'primary' }, { id: 'ocr', icon: 'fas fa-text-height', label: 'OCR Filter (Ctrl+Alt+O)', type: 'filter' }, { id: 'asr', icon: 'fas fa-microphone', label: 'ASR Filter (Ctrl+Alt+P)', type: 'filter' }];
                
                // ## BẮT ĐẦU SỬA ĐIỀU 1: ĐỔI ICON ##
                // Đã đổi icon từ "fa-microphone" thành "fa-microphone-lines" để trực quan hơn.
                let typesHTML = queryTypes.map(type => `<button class="type-btn ${type.id === 'text' ? 'active' : ''}" data-type="${type.id}" data-basetype="${type.type}" title="${type.label}"><i class="${type.icon}"></i></button>`).join('') +
                                `<button class="type-btn mic-btn" title="Ghi âm giọng nói (Ctrl+Alt+M)"><i class="fas fa-headphones"></i></button>`;
                // ## KẾT THÚC SỬA ĐIỀU 1 ##
                
                stageCard.innerHTML = `
                    <div class="stage-number">${number}</div>
                    <button class="delete-stage" title="Delete Stage" style="display: ${stagesContainer.children.length > 0 ? 'flex' : 'none'}"><i class="fas fa-times"></i></button>
                    <div class="stage-header"><div class="query-types">${typesHTML}</div></div>
                    <div class="query-input-area">
                        <textarea class="stage-input main-query-input" placeholder="Nhập truy vấn tiếng Việt..." rows="3"></textarea>
                        <div class="processed-query-display-wrapper main-processed-query-wrapper">
                            <i class="fas fa-cogs" title="Processed Query"></i>
                            <span class="processed-query-display"></span>
                        </div>
                        <div class="image-search-container" style="display: none;">
                            <label for="file-input-${number}" class="image-upload-zone">
                                <div class="upload-instructions"><i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p></div>
                                <img class="image-preview" style="display: none;">
                                <button class="remove-image-btn" style="display: none;" title="Xóa ảnh"><i class="fas fa-times"></i></button>
                            </label>
                            <input type="file" id="file-input-${number}" class="stage-input-file" accept="image/*">
                            <input type="text" class="stage-input image-search-text-input" placeholder="Thêm mô tả văn bản cho ảnh (tùy chọn)..." style="margin-top: 10px;">
                            <div class="processed-query-display-wrapper image-processed-query-wrapper">
                                <i class="fas fa-cogs" title="Processed Image Text"></i>
                                <span class="processed-query-display"></span>
                            </div>
                        </div>
                        <div class="filter-input-wrapper" data-filter-type="ocr" style="display: none; margin-top: 10px;">
                            <input type="text" class="stage-input ocr-filter-input" placeholder="Lọc theo từ khóa OCR...">
                        </div>
                        <div class="filter-input-wrapper" data-filter-type="asr" style="display: none; margin-top: 10px;">
                            <input type="text" class="stage-input asr-filter-input" placeholder="Lọc theo từ khóa ASR...">
                        </div>
                    </div>
                    <div class="stage-options">
                        <button class="option-btn" data-option="enhance" title="Enhance Query (Ctrl+Q)">Enhance</button>
                        <button class="option-btn" data-option="unite_fusion" title="Use Unite Fusion Search (Ctrl+U)">Fusion</button>
                    </div>`;

                const mainTextInput = stageCard.querySelector('.main-query-input');
                const imageSearchContainer = stageCard.querySelector('.image-search-container');
                const stageOptions = stageCard.querySelector('.stage-options');
                const imageUploadZone = stageCard.querySelector('.image-upload-zone');
                const mainProcessedWrapper = stageCard.querySelector('.main-processed-query-wrapper');
                
                stageCard.querySelectorAll('.type-btn:not(.mic-btn)').forEach(button => {
                    button.addEventListener('click', () => {
                        const type = button.dataset.type;
                        const baseType = button.dataset.basetype;

                        if (baseType === 'primary') {
                            stageCard.querySelectorAll('.type-btn[data-basetype="primary"]').forEach(btn => { if (btn !== button) btn.classList.remove('active'); });
                            button.classList.add('active');
                            
                            const isTextMode = type === 'text';
                            mainTextInput.style.display = isTextMode ? 'block' : 'none';
                            mainProcessedWrapper.style.display = isTextMode ? 'flex' : 'none';
                            imageSearchContainer.style.display = isTextMode ? 'none' : 'block';
                            stageOptions.style.display = isTextMode ? 'flex' : 'none';

                        } else {
                            button.classList.toggle('active');
                            const filterWrapper = stageCard.querySelector(`.filter-input-wrapper[data-filter-type="${type}"]`);
                            if (filterWrapper) {
                                filterWrapper.style.display = button.classList.contains('active') ? 'block' : 'none';
                                if (button.classList.contains('active')) { filterWrapper.querySelector('input').focus(); }
                            }
                        }
                        
                        const genImageBtn = stageCard.querySelector('.type-btn[data-type="gen_image"]');
                        if (genImageBtn && genImageBtn.classList.contains('active')) {
                            const textBtn = stageCard.querySelector('.type-btn[data-type="text"]');
                            if (!textBtn.classList.contains('active')) {
                                textBtn.click();
                            }
                        }
                    });
                });

                const handleFileSelect = async (file) => {
                    if (!file || !file.type.startsWith('image/')) return;
                    const previewImage = stageCard.querySelector('.image-preview');
                    const uploadInstructions = stageCard.querySelector('.upload-instructions');
                    const removeImageBtn = stageCard.querySelector('.remove-image-btn');

                    previewImage.src = URL.createObjectURL(file);
                    previewImage.style.display = 'block';
                    uploadInstructions.style.display = 'none';
                    removeImageBtn.style.display = 'none';

                    const formData = new FormData();
                    formData.append('image', file);

                    try {
                        const response = await fetch('/upload_image', { method: 'POST', body: formData });
                        if (!response.ok) throw new Error(`Upload failed: ${response.statusText}`);
                        const data = await response.json();
                        stageCard.tempImageName = data.temp_image_name;
                        removeImageBtn.style.display = 'flex';
                    } catch (error) {
                        console.error("Image upload error:", error);
                        alert("Lỗi upload ảnh. Vui lòng thử lại.");
                        previewImage.style.display = 'none';
                        uploadInstructions.innerHTML = `<i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p>`;
                        uploadInstructions.style.display = 'block';
                        removeImageBtn.style.display = 'none';
                        delete stageCard.tempImageName;
                    }
                };

                
                stageCard.querySelector('.remove-image-btn').addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); stageCard.querySelector('.stage-input-file').value = ''; const previewImage = stageCard.querySelector('.image-preview'); const uploadInstructions = stageCard.querySelector('.upload-instructions'); const removeImageBtn = stageCard.querySelector('.remove-image-btn'); previewImage.src = ''; previewImage.style.display = 'none'; uploadInstructions.innerHTML = `<i class="fas fa-cloud-upload-alt"></i><p>Kéo & thả ảnh hoặc <strong>nhấn để chọn file</strong></p>`; uploadInstructions.style.display = 'block'; removeImageBtn.style.display = 'none'; delete stageCard.tempImageName; });
                stageCard.querySelector('.stage-input-file').addEventListener('change', e => handleFileSelect(e.target.files[0]));
                imageUploadZone.addEventListener('dragover', e => { e.preventDefault(); imageUploadZone.classList.add('dragover'); });
                imageUploadZone.addEventListener('dragleave', e => { e.preventDefault(); imageUploadZone.classList.remove('dragover'); });
                imageUploadZone.addEventListener('drop', e => { e.preventDefault(); imageUploadZone.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files[0]); });
                stageCard.querySelector('.delete-stage')?.addEventListener('click', () => { stageCard.remove(); renumberStages(); });
                stageCard.querySelectorAll('.option-btn').forEach(button => {
                    if (button.dataset.option !== 'expand') {
                        button.addEventListener('click', () => {
                            button.classList.toggle('active');
                        });
                    }
                });
                return stageCard;
            }

            async function handleSearch(imageFileFromClick = null) {
                const clientStartTime = performance.now();
                currentPage = 1;
                isLoadingMore = false;
                lastSearchPayload = null;

                loadingIndicator.style.display = 'block';
                resultsContainer.innerHTML = '';
                document.getElementById('timingInfoDisplay').style.display = 'none';
                currentResponse = {};
                pushedFrames.clear();

                const allStages = Array.from(stagesContainer.querySelectorAll('.stage-card'));

                allStages.forEach(stage => {
                    const displayWrapper = stage.querySelector('.main-processed-query-wrapper');
                    if (displayWrapper) {
                        displayWrapper.style.display = 'none';
                        displayWrapper.querySelector('.processed-query-display').textContent = '';
                    }
                });
                
                try {
                    const precomputationPromises = allStages.map(async (stage) => {
                        const genImageBtn = stage.querySelector('.type-btn[data-type="gen_image"]');
                    });

                    await Promise.all(precomputationPromises);
                
                    const objectFilters = getObjectFilterData();
                    let response;
                    let searchEndpoint;
                    let requestBody;

                    if (imageFileFromClick) {
                        searchEndpoint = '/search';
                        const searchData = { models: ["bge"], filters: objectFilters, image_search_text: "", page: 1, page_size: PAGE_SIZE };
                        lastSearchPayload = searchData;
                        const formData = new FormData();
                        formData.append('query_image', imageFileFromClick, imageFileFromClick.name);
                        formData.append('search_data', JSON.stringify(searchData));
                        requestBody = formData;
                    } else if (allStages.length === 1) {
                        searchEndpoint = '/search';
                        const firstStage = allStages[0];
                        const useUniteFusion = firstStage.querySelector('.option-btn[data-option="unite_fusion"]').classList.contains('active');
                        const searchData = { filters: objectFilters, page: 1, page_size: PAGE_SIZE, use_unite_fusion: useUniteFusion };
                        let hasPrimaryQuery = false;

                        if (firstStage.querySelector('.type-btn[data-type="gen_image"]')?.classList.contains('active')) {
                            const mainInput = firstStage.querySelector('.main-query-input');
                            searchData.query_text = mainInput.value.trim();
                            searchData.generated_image_name = firstStage.generatedImageName;
                            searchData.models = ["unite"];
                            if (searchData.query_text) hasPrimaryQuery = true;
                        } else if (firstStage.querySelector('.type-btn[data-type="image"].active')) {
                            const imageTextInput = firstStage.querySelector('.image-search-text-input');
                            if (firstStage.tempImageName) {
                                searchData.query_image_name = firstStage.tempImageName;
                                searchData.image_search_text = imageTextInput.value.trim();
                                searchData.models = ["bge"];
                                hasPrimaryQuery = true;
                            }
                        } else {
                            const mainInput = firstStage.querySelector('.main-query-input');
                            searchData.query_text = mainInput.value.trim();
                            searchData.models = Array.from(document.querySelectorAll('#modelDropdown input:checked')).map(cb => cb.value);
                            searchData.enhance = firstStage.querySelector('.option-btn[data-option="enhance"]').classList.contains('active');
                            if (searchData.query_text) hasPrimaryQuery = true;
                        }

                        if (firstStage.querySelector('.type-btn[data-type="ocr"].active')) searchData.ocr_query = firstStage.querySelector('.ocr-filter-input').value.trim();
                        if (firstStage.querySelector('.type-btn[data-type="asr"].active')) searchData.asr_query = firstStage.querySelector('.asr-filter-input').value.trim();
                        if (!hasPrimaryQuery && !searchData.ocr_query && !searchData.asr_query) throw new Error("Please provide a main query or a filter.");
                        if (hasPrimaryQuery && searchData.models && searchData.models.length === 0) throw new Error("Please select at least one model.");
                        
                        lastSearchPayload = searchData;
                        const formData = new FormData();
                        formData.append('search_data', JSON.stringify(searchData));
                        requestBody = formData;
                    } else {
                        searchEndpoint = '/temporal_search';
                        const stagesData = allStages.map(stage => {
                            const mainInput = stage.querySelector('.main-query-input');
                            
                            // ## BẮT ĐẦU SỬA LỖI TEMPORAL SEARCH ##
                            // Sử dụng Optional Chaining (?.) để kiểm tra sự tồn tại của element trước khi truy cập classList.
                            // Điều này ngăn lỗi "Cannot read properties of null" khi querySelector không tìm thấy element (ví dụ: data-option="expand").
                            const stageDatum = {
                                query: mainInput.value.trim(),
                                query_image_name: stage.tempImageName || null,
                                generated_image_name: stage.generatedImageName || null,
                                enhance: stage.querySelector('.option-btn[data-option="enhance"]')?.classList.contains('active') || false,
                                expand: stage.querySelector('.option-btn[data-option="expand"]')?.classList.contains('active') || false, // Dòng này là nguyên nhân chính gây lỗi
                                use_unite_fusion: stage.querySelector('.option-btn[data-option="unite_fusion"]')?.classList.contains('active') || false,
                                ocr_query: stage.querySelector('.type-btn[data-type="ocr"].active') ? stage.querySelector('.ocr-filter-input').value.trim() : null,
                                asr_query: stage.querySelector('.type-btn[data-type="asr"].active') ? stage.querySelector('.asr-filter-input').value.trim() : null,
                            };
                            // ## KẾT THÚC SỬA LỖI ##

                            return stageDatum;
                        });
                        
                        const payload = { stages: stagesData, models: Array.from(document.querySelectorAll('#modelDropdown input:checked')).map(cb => cb.value), filters: objectFilters, ambiguous: ambiguousBtn.classList.contains('active'), page: 1, page_size: PAGE_SIZE };
                        lastSearchPayload = payload;
                        requestBody = JSON.stringify(payload);
                    }
                    
                    const fetchOptions = { method: 'POST' };
                    if (requestBody instanceof FormData) {
                        fetchOptions.body = requestBody;
                    } else {
                        fetchOptions.headers = { 'Content-Type': 'application/json' };
                        fetchOptions.body = requestBody;
                    }
                    
                    response = await fetch(searchEndpoint, fetchOptions);
                    if (!response.ok) { const err = await response.json(); throw new Error(err.detail || 'Unknown error from server.'); }
                    currentResponse = await response.json();

                    if (currentResponse.processed_query) {
                        const firstStage = allStages[0];
                        if (firstStage) {
                            const displayWrapper = firstStage.querySelector('.main-processed-query-wrapper');
                            const displaySpan = displayWrapper.querySelector('.processed-query-display');
                            displaySpan.textContent = currentResponse.processed_query;
                            displayWrapper.style.display = 'flex';
                        }
                    }
                    if (currentResponse.processed_queries && Array.isArray(currentResponse.processed_queries)) {
                        allStages.forEach((stage, index) => {
                            const processedQueryText = currentResponse.processed_queries[index];
                            if (processedQueryText) {
                                const displayWrapper = stage.querySelector('.main-processed-query-wrapper');
                                if (displayWrapper) {
                                    const displaySpan = displayWrapper.querySelector('.processed-query-display');
                                    displaySpan.textContent = processedQueryText;
                                    displayWrapper.style.display = 'flex';
                                }
                            }
                        });
                    }

                    totalResults = currentResponse.total_results || 0;
                    displayTimingInfo(currentResponse.timing_info, clientStartTime);
                    displayResults(currentResponse.results, false);

                } catch (error) {
                    console.error("[ERROR] Search failed:", error);
                    resultsContainer.innerHTML = `<p style="color: #ef4444; font-size: 1.1rem; text-align: center;"><strong>Error:</strong> ${error.message}</p>`;
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }
            
            let debounceTimer = null;
            function loadMoreResults() {
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(async () => {
                    const resultsCount = resultsContainer.querySelectorAll('.result-item, .sequence-result-container').length;
                    if (isLoadingMore || !lastSearchPayload || (totalResults > 0 && resultsCount >= totalResults)) {
                        return;
                    }

                    isLoadingMore = true;
                    currentPage++;

                    const loader = document.createElement('div');
                    loader.id = 'moreLoader';
                    loader.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading more...';
                    loader.style.textAlign = 'center';
                    loader.style.padding = '20px';
                    loader.style.fontSize = '1.2rem';
                    resultsContainer.appendChild(loader);

                    try {
                        let response;
                        let searchEndpoint;
                        let requestBody;
                        lastSearchPayload.page = currentPage;

                        if (lastSearchPayload.stages) {
                            searchEndpoint = '/temporal_search';
                            requestBody = JSON.stringify(lastSearchPayload);
                        } else {
                            searchEndpoint = '/search';
                            const formData = new FormData();
                            formData.append('search_data', JSON.stringify(lastSearchPayload));
                            requestBody = formData;
                        }

                        const fetchOptions = { method: 'POST' };
                        if (requestBody instanceof FormData) {
                            fetchOptions.body = requestBody;
                        } else {
                            fetchOptions.headers = { 'Content-Type': 'application/json' };
                            fetchOptions.body = requestBody;
                        }

                        response = await fetch(searchEndpoint, fetchOptions);
                        if (!response.ok) {
                            const err = await response.json();
                            throw new Error(err.detail || 'Failed to load more results.');
                        }
                        const data = await response.json();
                        displayResults(data.results, true);
                    } catch (error) {
                        console.error("Error loading more results:", error);
                        loader.textContent = `Error: ${error.message}`;
                    } finally {
                        isLoadingMore = false;
                        const existingLoader = document.getElementById('moreLoader');
                        if (existingLoader) existingLoader.remove();
                        debounceTimer = null;
                    }
                }, 300); // debounce 300ms
            }
            
            function getObjectFilterData(){const e={};if(enableCountFilter.checked){const t={};countFilterControls.querySelectorAll(".count-filter-row").forEach(e=>{const o=e.querySelector(".count-checkbox");if(o.checked){const r=e.querySelector(".condition-input").value.trim();if(r){let s=e.classList.contains("custom")?e.querySelector(".custom-object-name").value.trim().toLowerCase():o.dataset.object;s&&(t[s]=r)}}}),Object.keys(t).length>0&&(e.counting={conditions:t})}if(enablePositionFilter.checked&&drawnBoxes.length>0){const o=drawnBoxes.filter(e=>e.label).map(e=>({label:e.label,box:[e.x/posCanvas.width,e.y/posCanvas.height,(e.x+e.w)/posCanvas.width,(e.y+e.h)/posCanvas.height]}));o.length>0&&(e.positioning={boxes:o})}return objectFilterBtn.classList.toggle("active",enableCountFilter.checked||enablePositionFilter.checked),(enableCountFilter.checked||enablePositionFilter.checked)&&Object.keys(e).length>0?e:null}

            function createCountRow(e = "", t = !1) { const o = document.createElement("div"); o.className = "count-filter-row" + (t ? " custom" : ""); const r = `<input type="checkbox" class="count-checkbox" data-object="${e || "custom"}">`, s = t ? `<input type="text" class="filter-input custom-object-name" placeholder="object name">` : `<label>${e}</label>`, n = `<input type="text" class="filter-input condition-input" placeholder="e.g., >=1">`, i = t ? `<button class="remove-custom-btn">&times;</button>` : ""; o.innerHTML = `${r}${s}${n}${i}`; const a = o.querySelector(".count-checkbox"); const l = () => o.classList.toggle("active-row", a.checked); o.addEventListener("click", e => { e.target.tagName !== "INPUT" && e.target.tagName !== "BUTTON" && (a.checked = !a.checked, l()) }); a.addEventListener("change", l); const conditionInput = o.querySelector('.condition-input'); conditionInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); if (conditionInput.value.trim() !== '') { a.checked = true; l(); } conditionInput.blur(); } }); t && o.querySelector(".remove-custom-btn").addEventListener("click", () => o.remove()); l(); return o; }
            PREDEFINED_OBJECTS.forEach(e=>countFilterControls.appendChild(createCountRow(e))),addCustomCountBtn.addEventListener("click",()=>countFilterControls.appendChild(createCountRow("",!0)));
            function redrawCanvas(){if(!posCtx)return;posCtx.clearRect(0,0,posCanvas.width,posCanvas.height),posCtx.strokeStyle="#FFD700",posCtx.lineWidth=2,drawnBoxes.forEach((e,t)=>{posCtx.strokeRect(e.x,e.y,e.w,e.h),posCtx.font="14px 'Poppins'",posCtx.fillStyle="#FFD700",posCtx.fillText(`${t+1}: ${e.label||"no label"}`,e.x+5,e.y+16)}),isDrawing&&(posCtx.strokeStyle="var(--accent-pink)",posCtx.strokeRect(startX,startY,currentX-startX,currentY-startY))}
            function updateDrawnBoxesList(){drawnBoxesList.innerHTML="",drawnBoxes.forEach((e,t)=>{const o=document.createElement("div");o.className="drawn-box-item",o.textContent=`Box ${t+1}: ${e.label||"(unlabeled)"}`,drawnBoxesList.appendChild(o)})}posCanvas.addEventListener("pointerdown",e=>{isDrawing=!0,startX=e.offsetX,startY=e.offsetY}),posCanvas.addEventListener("pointermove",e=>{isDrawing&&(currentX=e.offsetX,currentY=e.offsetY,redrawCanvas())}),posCanvas.addEventListener("pointerup",e=>{if(!isDrawing)return;isDrawing=!1;const t=e.offsetX,o=e.offsetY,r={x:Math.min(startX,t),y:Math.min(startY,o),w:Math.abs(t-startX),h:Math.abs(o-startY),label:""};r.w>5&&r.h>5&&drawnBoxes.push(r),redrawCanvas(),updateDrawnBoxesList()});

            function renumberStages() {
                stagesContainer.querySelectorAll('.stage-card').forEach((card, index) => {
                    const stageNumberEl = card.querySelector('.stage-number');
                    if (stageNumberEl) stageNumberEl.textContent = index + 1;
                    const deleteBtn = card.querySelector('.delete-stage');
                    if (deleteBtn) {
                        deleteBtn.style.display = stagesContainer.children.length > 1 ? 'flex' : 'none';
                    }
                });
            }
            function addStageToEnd() {
                const newStage = createStageCard(0);
                stagesContainer.appendChild(newStage);
                renumberStages();
                focusOnStageInput(newStage);
            }
            function addStageToStart() {
                const newStage = createStageCard(0);
                stagesContainer.insertAdjacentElement('afterbegin', newStage);
                renumberStages();
                focusOnStageInput(newStage);
            }
            function removeStageFromEnd() {
                if (stagesContainer.children.length > 1) {
                    stagesContainer.lastChild.remove();
                    renumberStages();
                    focusOnStageInput(stagesContainer.lastChild);
                }
            }
            function removeStageFromStart() {
                if (stagesContainer.children.length > 1) {
                    stagesContainer.firstChild.remove();
                    renumberStages();
                    focusOnStageInput(stagesContainer.firstChild);
                }
            }
            
            setupImageObserver();
            setupUser();
            initializeDresState();
            function applyTheme(themeName) {
                document.body.className = themeName === 'default' ? '' : themeName;
                localStorage.setItem('videoSearchTheme', themeName);
                
                const themeLabel = THEMES[themeName] || 'Default Dark';
                themeSwitcherBtn.querySelector('span').innerHTML = `<i class="fas fa-palette"></i> ${themeLabel}`;

                // --- Logic bật/tắt hiệu ứng đặc biệt ---

                // Digital Rain
                if (themeName === 'theme-gits-rain') {
                    cursedDomainVideo.style.display = 'none'; // Tắt video JJK
                    cursedDomainVideo.pause();
                    startDigitalRain();
                } 
                // Cursed Domain Video
                else if (themeName === 'theme-jujutsu-domain') {
                    stopDigitalRain(); // Tắt Digital Rain
                    cursedDomainVideo.style.display = 'block';
                    cursedDomainVideo.play().catch(e => console.error("Video autoplay failed:", e));
                } 
                // Các theme khác
                else {
                    stopDigitalRain();
                    cursedDomainVideo.style.display = 'none';
                    cursedDomainVideo.pause();
                }
            }

            function initTheme() {
                // Populate dropdown
                const fragment = document.createDocumentFragment();
                for (const [className, name] of Object.entries(THEMES)) {
                    const item = document.createElement('div');
                    item.className = 'theme-dropdown-item';
                    item.dataset.theme = className;
                    const swatch = document.createElement('div');
                    swatch.className = 'theme-color-swatch';
                    
                    // Create a dummy div to get theme colors
                    const dummy = document.createElement('div');
                    dummy.style.display = 'none';
                    document.body.appendChild(dummy);
                    const originalClass = document.body.className;
                    document.body.className = className === 'default' ? '' : className;
                    const primaryGradient = getComputedStyle(dummy).getPropertyValue('--primary-gradient');
                    swatch.style.background = primaryGradient;
                    document.body.className = originalClass;
                    dummy.remove();
                    
                    item.appendChild(swatch);
                    item.append(name);
                    item.addEventListener('click', () => {
                        applyTheme(className);
                        themeDropdown.style.display = 'none';
                    });
                    fragment.appendChild(item);
                }
                themeDropdown.appendChild(fragment);

                // Apply saved theme
                const savedTheme = localStorage.getItem('videoSearchTheme') || 'default';
                applyTheme(savedTheme);
            }

            initTheme();
            function closeSidebar() {
                nearbyFramesSidebar.style.display = 'none';
                activeTrakeItemForSidebar = null;
            }
            sidebarCloseBtn.addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);

            themeSwitcherBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                themeDropdown.style.display = themeDropdown.style.display === 'block' ? 'none' : 'block';
            });
            // ############ END: THEME SWITCHER LOGIC ############


            // ############ START: TRAKE PANEL LOGIC ############
            trakeBtn.addEventListener('click', () => {
                const isActive = trakeBtn.classList.toggle('active');
                trakePanelContainer.style.display = isActive ? 'block' : 'none';
            });

            function pushToTrakePanel(shotData) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    showToast("Real-time connection not active.", 3000, 'error');
                    return;
                }
                if (!shotData || !shotData.filepath) return;

                // The server will handle duplicate prevention, but a local check is still good for UI responsiveness
                if (trakeGrid.querySelector(`.result-item[data-filepath="${shotData.filepath}"]`)) {
                    showToast("Frame is already in the Trake Panel.", 2000, 'warning');
                    return;
                }

                ws.send(JSON.stringify({
                    type: 'trake_add',
                    data: { shot: shotData }
                }));

                if (!trakeBtn.classList.contains('active')) {
                    trakeBtn.click();
                }
            }

            pushToTrakeBtn.addEventListener('click', () => {
                if (videoPreviewModal.style.display === 'flex' && currentVideoPreviewData) {
                    const currentTime = videoPlayer.currentTime;
                    const frameId = Math.round(currentTime * currentVideoPreviewData.fps);
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                    const shotData = {
                        video_id: currentVideoPreviewData.videoId,
                        frame_id: frameId,
                        fps: currentVideoPreviewData.fps,
                        filepath: `dynamic-frame-${currentVideoPreviewData.videoId}-${frameId}`,
                        url: thumbnailUrl,
                        is_dynamic: true
                    };
                    pushToTrakePanel(shotData);
                }
            });

            // --- Drag & Drop for Trake Panel ---
            let draggedItem = null;
            trakeGrid.addEventListener('dragstart', e => {
                draggedItem = e.target.closest('.result-item');
                setTimeout(() => {
                    if(draggedItem) draggedItem.classList.add('ghost');
                }, 0);
            });
            trakeGrid.addEventListener('dragend', e => {
                if(draggedItem) {
                    draggedItem.classList.remove('ghost');
                    draggedItem = null;

                    // After dropping, get the new order and send it to the server
                    const newOrder = [...trakeGrid.querySelectorAll('.result-item')].map(item => item.dataset.filepath);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'trake_reorder',
                            data: { order: newOrder }
                        }));
                    }
                }
            });
            trakeGrid.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(trakeGrid, e.clientX);
                const dragging = document.querySelector('.ghost');
                if (dragging) {
                    if (afterElement == null) {
                        trakeGrid.appendChild(dragging);
                    } else {
                        trakeGrid.insertBefore(dragging, afterElement);
                    }
                }
            });

            function getDragAfterElement(container, x) {
                const draggableElements = [...container.querySelectorAll('.result-item:not(.ghost)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            function handleNearbyFramesClick(event) {
                event.stopPropagation();
                const itemElement = event.target.closest('.result-item');
                if (itemElement && itemElement.shotData) {
                    toggleNearbyFrames(itemElement, itemElement.shotData);
                } else {
                    console.error("Could not find shot data for nearby frames button.", itemElement);
                    showToast("Error: Data for this frame is missing.", 3000, 'error');
                }
            }

            // --- Nearby Frames Logic ---
            async function toggleNearbyFrames(trakeItemElement, shotData) {
                // This function now opens the sidebar
                activeTrakeItemForSidebar = trakeItemElement;
                sidebarGrid.innerHTML = '<div class="sidebar-item loading" style="justify-content: center;"><i class="fas fa-spinner fa-spin"></i></div>';
                sidebarTitle.textContent = `Nearby: V${shotData.video_id}, F${shotData.frame_id}`;
                nearbyFramesSidebar.style.display = 'flex';

                let currentShotData = { ...shotData };

                if (!currentShotData.fps) {
                    try {
                        if (!currentShotData.video_id) throw new Error("Missing video_id");
                        const infoResponse = await fetch(`/video_info/${currentShotData.video_id}`);
                        if (!infoResponse.ok) throw new Error(`Server error ${infoResponse.status}`);
                        const videoInfo = await infoResponse.json();
                        currentShotData.fps = videoInfo.fps;
                        trakeItemElement.shotData.fps = videoInfo.fps; // Persist it
                    } catch (error) {
                        sidebarGrid.innerHTML = `<div style="color: #ef4444;">Error: ${error.message}</div>`;
                        return;
                    }
                }
                
                try {
                    const originalTime = currentShotData.frame_id / currentShotData.fps;
                    const timeOffsets = [-1.0, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1.0];
                    const framePromises = timeOffsets.map(offset => fetchFrameAtTime(currentShotData.video_id, originalTime + offset));
                    const frameResults = await Promise.all(framePromises);
                    
                    sidebarGrid.innerHTML = ''; // Clear loading spinner
                    frameResults.forEach((result, index) => {
                        if (result.success) {
                            const offset = timeOffsets[index];
                            const newItem = document.createElement('div');
                            newItem.className = 'sidebar-item';
                            newItem.innerHTML = `
                                <img src="${result.imageData}" />
                                <span class="time-offset">${offset === 0 ? 'Original' : (offset > 0 ? `+${offset.toFixed(1)}s` : `${offset.toFixed(1)}s`)}</span>
                            `;
                            
                            newItem.addEventListener('click', () => {
                                const newFrameId = Math.round((originalTime + offset) * currentShotData.fps);
                                const newShotData = { ...currentShotData, frame_id: newFrameId, url: result.imageData };
                                
                                if (activeTrakeItemForSidebar && ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({
                                        type: 'trake_replace',
                                        data: {
                                            filepath: activeTrakeItemForSidebar.dataset.filepath, // The original filepath to identify the item
                                            newShot: newShotData // The complete new shot data
                                        }
                                    }));
                                }
                                closeSidebar();
                            });
                            sidebarGrid.appendChild(newItem);
                        }
                    });
                } catch (error) {
                    sidebarGrid.innerHTML = `<div style="color: #ef4444;">Error loading frames: ${error.message}</div>`;
                }
            }

            async function fetchFrameAtTime(videoId, timestamp) {
                try {
                    const formData = new FormData();
                    formData.append('video_id', videoId);
                    formData.append('timestamp', timestamp);

                    const response = await fetch('/get_frame_at_timestamp', { method: 'POST', body: formData });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Server error');
                    }
                    const data = await response.json();
                    return { success: true, imageData: data.image_data };
                } catch (error) {
                    console.error(`Failed to fetch frame for ${videoId} at ${timestamp}s:`, error);
                    return { success: false, error: error.message };
                }
            }

            // --- Bulk Submission Logic ---
            trakePanelContainer.addEventListener('mouseenter', () => { isMouseOverTrakePanel = true; });
            trakePanelContainer.addEventListener('mouseleave', () => { isMouseOverTrakePanel = false; });
            
            async function submitAllTrakeFrames() {
                if (!isMouseOverTrakePanel) return;

                const itemsToSubmit = Array.from(trakeGrid.querySelectorAll('.result-item'));
                if (itemsToSubmit.length === 0) {
                    showToast("Trake Panel is empty.", 2000, 'info');
                    return;
                }
                
                if (!confirm(`Submit all ${itemsToSubmit.length} frames in the Trake Panel to DRES?`)) {
                    return;
                }

                showToast(`Submitting ${itemsToSubmit.length} frames...`, 5000, 'info');

                const submissionPromises = itemsToSubmit.map(item => {
                    const shotData = {
                        video_id: item.dataset.videoId,
                        frame_id: parseInt(item.dataset.frameId, 10),
                        filepath: item.dataset.filepath,
                        url: item.querySelector('img').src
                    };
                    return handleSubmitToDRES(shotData, true);
                });

                await Promise.all(submissionPromises);
                showToast("All submissions from Trake Panel processed.", 3000, 'success');
            }
            const initialStage = createStageCard(1);
            stagesContainer.appendChild(initialStage);
            focusOnStageInput(initialStage);

            addStageBtn.addEventListener('click', addStageToEnd);
            removeStageBtn.addEventListener('click', removeStageFromEnd);
            searchBtn.addEventListener('click', () => handleSearch(null));
            document.getElementById('resetBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the search panel?')) {
                    stagesContainer.innerHTML = '';
                    addStageToStart();
                    currentResponse = {};
                    resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding-top: 100px; font-size: 1.5rem;">Sử dụng bảng điều khiển bên trái để bắt đầu tìm kiếm.</p>';
                    document.getElementById('timingInfoDisplay').style.display = 'none';
                    teamworkGrid.innerHTML = '';
                    pushedFrames.clear();
                    submittedFrames.clear(); // Xóa lịch sử các lượt nộp
                    document.getElementById('correctSubmissionPanel').style.display = 'none'; // Ẩn panel nộp đúng
                    googleSearchInput.value = '';
                    googleResultsContainer.innerHTML = '';
                    googleResultsWrapper.style.display = 'none';
                }
            });            
            clusterBtn.addEventListener('click', () => {
                clusterBtn.classList.toggle('active');
                if (currentResponse.results && !isLoadingMore) {
                    currentPage = 1; 
                    const allData = currentResponse.results;
                    displayResults(allData, false);
                }
            });
            ambiguousBtn.addEventListener('click', () => { ambiguousBtn.classList.toggle('active'); });
            modelSelectBtn.addEventListener('click', (event) => { event.stopPropagation(); const isOpening = modelDropdown.style.display !== 'block'; modelDropdown.style.display = isOpening ? 'block' : 'none'; if (isOpening) { focusedModelIndex = 0; updateModelFocus(); } else { clearModelFocus(); } });
            window.addEventListener('click', (e) => { if (!modelDropdown.contains(e.target) && !modelSelectBtn.contains(e.target)) { if (modelDropdown.style.display === 'block') { modelDropdown.style.display = 'none'; clearModelFocus(); } } });
            closeImageModalBtn.addEventListener('click', () => { imageModal.style.display = "none"; });
            imageModal.addEventListener('click', (e) => { if (e.target === imageModal) { imageModal.style.display = "none"; } });
            closeTemporalModalBtn.addEventListener('click', () => { temporalContextModal.style.display = "none"; });
            temporalContextModal.addEventListener('click', (e) => { if (e.target === temporalContextModal) { temporalContextModal.style.display = "none"; } });
            
            function closeVideoModal() {
                document.body.classList.remove('video-modal-active'); // THÊM DÒNG NÀY
                videoPreviewModal.style.display = "none";
                videoPlayer.pause();
                videoPlayer.src = "";
                currentVideoPreviewData = null;
            }

            closeVideoModalBtn.addEventListener('click', closeVideoModal);
            videoPreviewModal.addEventListener('click', (e) => { 
                if (e.target === videoPreviewModal) { 
                    closeVideoModal(); 
                } 
            });
            modalCloseBtn.addEventListener('click', () => objectFilterModal.style.display = 'none');

            function resetDresState() {
                dresSessionId = null;
                dresEvaluationId = null;
                sessionStorage.removeItem('dresSessionId');
                sessionStorage.removeItem('dresEvaluationId');
                
                dresStatus.textContent = 'Status: Not logged in.';
                dresStatus.style.color = 'var(--text-secondary)';
                dresEvaluationSelect.innerHTML = '';
                dresEvaluationSelect.disabled = true;
            }

            /**
             * Fetches evaluations for a given session, populates the dropdown,
             * and updates the UI to the logged-in state.
             */
            async function revalidateAndFetchEvaluations() {
                if (!dresSessionId) return;

                dresStatus.textContent = 'Validating session & fetching evaluations...';
                dresStatus.style.color = 'var(--text-secondary)';
                
                try {
                    const evalResponse = await fetch(`/dres/list_evaluations?session=${dresSessionId}`);
                    if (!evalResponse.ok) {
                        // This likely means the session ID has expired.
                        throw new Error('Session invalid or expired. Please log in again.');
                    }
                    const evaluations = await evalResponse.json();
                    
                    dresEvaluationSelect.innerHTML = '';
                    evaluations.forEach(ev => {
                        if (ev.status === 'ACTIVE') {
                            const option = document.createElement('option');
                            option.value = ev.id;
                            option.textContent = ev.name;
                            dresEvaluationSelect.appendChild(option);
                        }
                    });

                    if (dresEvaluationSelect.options.length > 0) {
                        // Try to restore the previously selected evaluation
                        const storedEvalId = sessionStorage.getItem('dresEvaluationId');
                        if (storedEvalId && dresEvaluationSelect.querySelector(`option[value="${storedEvalId}"]`)) {
                            dresEvaluationSelect.value = storedEvalId;
                        }
                        dresEvaluationId = dresEvaluationSelect.value;
                        sessionStorage.setItem('dresEvaluationId', dresEvaluationId);
                        
                        dresStatus.textContent = `Ready to submit to: ${dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex].text}`;
                        dresStatus.style.color = 'var(--accent-blue)';
                    } else {
                        dresStatus.textContent = 'Logged in, but no active evaluations found.';
                        dresStatus.style.color = 'var(--text-secondary)';
                    }
                    dresEvaluationSelect.disabled = false;

                } catch (error) {
                    console.error("DRES Re-validation Error:", error.message);
                    showToast(error.message, 4000, 'error');
                    resetDresState(); // Critical: Clear bad session data
                }
            }
            
            /**
             * Checks sessionStorage on page load to restore DRES login state.
             */
            function initializeDresState() {
                dresSessionId = sessionStorage.getItem('dresSessionId');
                if (dresSessionId) {
                    revalidateAndFetchEvaluations();
                }
            }
            
            dresModalCloseBtn.addEventListener('click', () => dresModal.style.display = 'none');

            dresBtn.addEventListener('click', () => {
                if (dresSessionId) {
                    dresInitialView.style.display = 'none';
                    dresLoginView.style.display = 'none';
                    dresEvaluationView.style.display = 'block';
                    
                    const selectedOption = dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex];
                    dresStatus.textContent = selectedOption ? `Ready to submit to: ${selectedOption.text}` : 'Logged in, please select an evaluation.';
                    dresStatus.style.color = 'var(--accent-blue)';
                } else {
                    dresInitialView.style.display = 'block';
                    dresLoginView.style.display = 'none';
                    dresEvaluationView.style.display = 'none';
                    dresStatus.textContent = 'Status: Not logged in.';
                    dresStatus.style.color = 'var(--text-secondary)';
                }
                dresModal.style.display = 'flex';
            });

            dresShowLoginBtn.addEventListener('click', () => {
                dresInitialView.style.display = 'none';
                dresLoginView.style.display = 'flex';
                dresUsername.focus();
            });

            dresLoginBtn.addEventListener('click', async () => {
                const user = dresUsername.value;
                const pass = dresPassword.value;
                if (!user || !pass) {
                    alert('Please enter username and password.');
                    return;
                }
                dresStatus.textContent = 'Logging in...';
                dresStatus.style.color = 'var(--text-secondary)';
                try {
                    const response = await fetch('/dres/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username: user, password: pass })
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.detail || 'Login failed');
                    }
                    const data = await response.json();
                    dresSessionId = data.sessionId;
                    sessionStorage.setItem('dresSessionId', dresSessionId);
                    
                    // Now, just call our reusable function!
                    await revalidateAndFetchEvaluations();
                    
                    showToast('DRES Login successful!', 3000, 'success');
                    dresModal.style.display = 'none';

                } catch (error) {
                    dresStatus.textContent = `Error: ${error.message}`;
                    dresStatus.style.color = '#ef4444';
                    resetDresState(); // Reset on login failure
                }
            });

            dresEvaluationSelect.addEventListener('change', () => {
                dresEvaluationId = dresEvaluationSelect.value;
                sessionStorage.setItem('dresEvaluationId', dresEvaluationId);
                dresStatus.textContent = `Ready to submit to: ${dresEvaluationSelect.options[dresEvaluationSelect.selectedIndex].text}`;
            });
            
            objectFilterBtn.addEventListener('click', () => {
                objectFilterModal.style.display = 'flex';
            });
            

            window.addEventListener('keydown', (event) => {
                const activeElement = document.activeElement;
                const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');

                if (videoPreviewModal.style.display === 'flex' && event.code === 'Space' && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault();
                    if (event.shiftKey) {
                        submitCurrentFrameBtn.click();
                    } else {
                        pushCurrentFrameBtn.click();
                    }
                    return;
                }

                if (event.key === 'Escape') {
                    event.preventDefault();
                    if (isTyping) { activeElement.blur(); return; }
                    if (videoPreviewModal.style.display === 'flex') { closeVideoModal(); return; }
                    if (imageModal.style.display === 'flex') { imageModal.style.display = 'none'; return; }
                    if (temporalContextModal.style.display === 'flex') { temporalContextModal.style.display = 'none'; return; }
                    if (objectFilterModal.style.display === 'flex') { objectFilterModal.style.display = 'none'; return; }
                    if (dresModal.style.display === 'flex') { dresModal.style.display = 'none'; return; }
                    if (modelDropdown.style.display === 'block') { modelDropdown.style.display = 'none'; clearModelFocus(); return; }
                }
                
                const isModalVisible = Array.from(document.querySelectorAll('.modal-overlay')).some(m => m.style.display === 'flex' || m.style.display === 'block');
                
                if ((event.ctrlKey || event.metaKey)) {
                    if (event.key.toLowerCase() === 'f' && !event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        if (objectFilterModal.style.display === 'flex') {
                            objectFilterModal.style.display = 'none';
                        } else {
                            objectFilterModal.style.display = 'flex';
                        }
                        return;
                    }
                    if (event.key.toLowerCase() === 'f' && event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        document.getElementById('enableCountFilter').click();
                        document.getElementById('enablePositionFilter').click();
                        objectFilterBtn.classList.toggle('active', document.getElementById('enableCountFilter').checked || document.getElementById('enablePositionFilter').checked);
                        return;
                    }
                    if (event.key.toLowerCase() === 'm' && !event.shiftKey && !event.altKey) {
                        event.preventDefault();
                        modelSelectBtn.click();
                        return;
                    }
                }

                if (event.code === 'Space' && (event.ctrlKey || event.metaKey)) {
                    if (!isModalVisible && currentlyHoveredItemData && currentlyHoveredItemElement) {
                        event.preventDefault();
                        const itemData = currentlyHoveredItemData;
                        const itemElement = currentlyHoveredItemElement;
                        const source = itemElement.dataset.source;

                        if (event.shiftKey) {
                            console.log(`Direct Submit action on item from source: ${source}`);
                            if (itemData.external_url) {
                                handleGoogleImageAction(itemData.external_url, 'submit', itemElement);
                            } else {
                                handleSubmitToDRES(itemData, true);
                            }
                        } else {
                            if (source === 'teamwork') {
                                if (!ws || ws.readyState !== WebSocket.OPEN) { alert("Teamwork connection is not available."); return; }
                                console.log(`Requesting to remove frame: ${itemData.filepath}`);
                                ws.send(JSON.stringify({ type: 'remove_frame', data: { filepath: itemData.filepath, user: { name: username } } }));
                            } else {
                                console.log(`Push action on item from source: ${source}`);
                                if (itemData.external_url) {
                                    handleGoogleImageAction(itemData.external_url, 'push', itemElement);
                                } else {
                                    pushToTeamworkPanel(itemData);
                                }
                            }
                        }
                        return;
                    }
                    else if (isMouseOverTrakePanel && event.shiftKey) {
                        event.preventDefault();
                        submitAllTrakeFrames();
                    }
                }

                if (modelDropdown.style.display === 'block') {
                    event.preventDefault();
                    const items = modelDropdown.querySelectorAll('.model-dropdown-item');
                    if (items.length > 0) {
                        switch (event.key) {
                            case 'ArrowDown': focusedModelIndex = (focusedModelIndex + 1) % items.length; updateModelFocus(); break;
                            case 'ArrowUp': focusedModelIndex = (focusedModelIndex - 1 + items.length) % items.length; updateModelFocus(); break;
                            case 'Enter': case ' ': if (focusedModelIndex > -1) { items[focusedModelIndex].querySelector('input[type="checkbox"]')?.click(); } break;
                        }
                    }
                    return;
                }

                if (event.key === 'Enter') {
                    if (isTyping && event.shiftKey) { return; }
                    if (dresModal.style.display === 'flex') {
                        event.preventDefault();
                        if (dresLoginView.style.display === 'flex') {
                            dresLoginBtn.click();
                        } else if (dresInitialView.style.display === 'block') {
                            dresShowLoginBtn.click();
                        }
                        return;
                    }
                    if (usernameModal.style.display === 'flex') { event.preventDefault(); usernameSubmitBtn.click(); return; }
                    event.preventDefault();
                    searchBtn.click();
                    return;
                }
                
                if (isModalVisible) {
                    const isObjectFilterModalVisible = objectFilterModal.style.display === 'flex';
                    if (isObjectFilterModalVisible && !isTyping) {
                        if (event.key in LABEL_SHORTCUTS && drawnBoxes.length > 0) { event.preventDefault(); drawnBoxes[drawnBoxes.length - 1].label = LABEL_SHORTCUTS[event.key]; }
                        else if (event.key === '7' && drawnBoxes.length > 0) { event.preventDefault(); const customLabel = prompt("Enter custom object label:", "person"); if (customLabel) drawnBoxes[drawnBoxes.length - 1].label = customLabel.toLowerCase(); }
                        else if (event.key === 'Backspace' && drawnBoxes.length > 0) { event.preventDefault(); drawnBoxes.pop(); }
                        else if (event.key.toLowerCase() === 'c') { event.preventDefault(); if (confirm("Clear all drawn boxes?")) drawnBoxes = []; }
                        redrawCanvas(); updateDrawnBoxesList();
                    }
                    return;
                }

                const stageToModify = isTyping ? activeElement.closest('.stage-card') : stagesContainer.querySelector('.stage-card:last-child');

                if ((event.ctrlKey || event.metaKey) && event.altKey && !event.shiftKey) {
                    let handled = true;
                    if (stageToModify) {
                        switch(event.key.toLowerCase()) {
                            case 'u': stageToModify.querySelector('.type-btn[data-type="text"]')?.click(); break;
                            case 'i': stageToModify.querySelector('.type-btn[data-type="image"]')?.click(); break;
                            case 'o': stageToModify.querySelector('.type-btn[data-type="ocr"]')?.click(); break;
                            case 'p': stageToModify.querySelector('.type-btn[data-type="asr"]')?.click(); break;
                            case 'g': stageToModify.querySelector('.type-btn[data-type="gen_image"]')?.click(); break;
                            case 'm': stageToModify.querySelector('.mic-btn')?.click(); break;
                            default: handled = false;
                        }
                    } else { handled = false; }
                    if(handled) { event.preventDefault(); return; }
                }
                else if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                    let handled = true;
                    switch (event.code) {
                        case 'KeyR': document.getElementById('resetBtn')?.click(); break;
                        case 'KeyG': ambiguousBtn.click(); break;
                        case 'BracketRight': removeStageFromEnd(); break;
                        case 'BracketLeft': removeStageFromStart(); break;
                        default: handled = false;
                    }
                    if (handled) event.preventDefault();
                }
                else if ((event.ctrlKey || event.metaKey) && !event.altKey) {
                    const targetStageNum = parseInt(event.key);
                    if (!isNaN(targetStageNum) && targetStageNum >= 1 && targetStageNum <= 9) {
                        event.preventDefault();
                        const allStages = stagesContainer.querySelectorAll('.stage-card');
                        if (targetStageNum <= allStages.length) focusOnStageInput(allStages[targetStageNum - 1]);
                        return;
                    }

                    let handled = true;
                    switch (event.code) {
                        case 'BracketRight': addStageToEnd(); break;
                        case 'BracketLeft': addStageToStart(); break;
                        default:
                            switch (event.key.toLowerCase()) {
                                case 'g': clusterBtn.click(); break;
                                case 'q': stageToModify?.querySelector('.option-btn[data-option="enhance"]')?.click(); break;
                                case 'u': stageToModify?.querySelector('.option-btn[data-option="unite_fusion"]')?.click(); break;
                                default: handled = false;
                            }
                    }
                    if (handled) event.preventDefault();
                }
                else if (isTyping && ['ArrowUp', 'ArrowDown'].includes(event.key)) {
                    const allStages = Array.from(stagesContainer.querySelectorAll('.stage-card'));
                    if (allStages.length > 1) {
                        const currentStage = activeElement.closest('.stage-card');
                        let currentIndex = currentStage ? allStages.indexOf(currentStage) : -1;
                        if (currentIndex !== -1) {
                            event.preventDefault();
                            if (event.key === 'ArrowUp') { currentIndex = (currentIndex - 1 + allStages.length) % allStages.length; }
                            else if (event.key === 'ArrowDown') { currentIndex = (currentIndex + 1) % allStages.length; }
                            focusOnStageInput(allStages[currentIndex]);
                        }
                    }
                }

                if (videoPreviewModal.style.display !== 'flex') {
                    return;
                }

                if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
                    event.preventDefault();
                    const direction = event.key === 'ArrowRight' ? 1 : -1;
                    handleScrub(direction);
                }

                // If one of our target keys was pressed...
                if (direction !== 0) {
                    // Prevent the default browser action for arrow keys (like horizontal scrolling).
                    event.preventDefault();

                    // Ensure we have the necessary FPS data before proceeding.
                    if (!currentVideoPreviewData || !currentVideoPreviewData.fps) {
                        return;
                    }
                    
                    // Pause the video for precise control.
                    videoPlayer.pause();
                    
                    // The calculation is the same as for the mouse wheel.
                    const frameTime = 1 / currentVideoPreviewData.fps;
                    const newTime = videoPlayer.currentTime + (direction * frameTime);
                    
                    // Set the new time, ensuring it stays within the video's bounds.
                    videoPlayer.currentTime = Math.max(0, Math.min(videoPlayer.duration, newTime));
                }
            });
        });
    </script>
</body>
</html>